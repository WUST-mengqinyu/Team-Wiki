
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.badcw.cn/Personal%20Page/Verly/%E7%BD%91%E7%BB%9C%E6%B5%81/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/">
      
      <link rel="icon" href="../../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>网络流24题 - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.1dff34a1.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CUbuntu+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Ubuntu Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="Team Wiki" class="md-header__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Team Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              网络流24题
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Team Wiki" class="md-nav__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          主页
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="主页" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          主页
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        赛季列表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          个人页面
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="个人页面" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          个人页面
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        Verly
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../badcw/" class="md-nav__link">
        badcw
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          关于
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="关于" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          关于
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../About/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1.飞行员配对方案问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#include" class="md-nav__link">
    include
  </a>
  
    <nav class="md-nav" aria-label="include">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3.  最小路径覆盖问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#include_1" class="md-nav__link">
    include
  </a>
  
    <nav class="md-nav" aria-label="include">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5.  圆桌问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6.  最长递增子序列问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7.试题库问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#9" class="md-nav__link">
    9.方格取数问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10.餐巾计划问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    11.航空路线问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    12.软件补丁问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    13.星际转移问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    14. 孤岛营救问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    15.汽车加油行驶问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    16.数字梯形问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#17" class="md-nav__link">
    17.运输问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    18.分配问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    19.负载平衡问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#20" class="md-nav__link">
    20.深海机器人问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#21k" class="md-nav__link">
    21.最长k可重区间集问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22k" class="md-nav__link">
    22.最长k可重线段集问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    23.火星探险问题
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    24.骑士共存问题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<table>
<thead>
<tr>
<th>No</th>
<th>Problem</th>
<th>model</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>飞行员配对方案问题</td>
<td>二分图最大匹配</td>
</tr>
<tr>
<td>2</td>
<td>太空飞行计划问题</td>
<td>最大权闭合子图</td>
</tr>
<tr>
<td>3</td>
<td>最小路径覆盖问题</td>
<td>最小路径覆盖</td>
</tr>
<tr>
<td>4</td>
<td>魔术球问题</td>
<td>最小路径覆盖</td>
</tr>
<tr>
<td>5</td>
<td>圆桌问题</td>
<td>二分图多重匹配</td>
</tr>
<tr>
<td>6</td>
<td>最长递增子序列问题</td>
<td>最多不相交路径</td>
</tr>
<tr>
<td>7</td>
<td>试题库问题</td>
<td>二分图多重匹配</td>
</tr>
<tr>
<td>8</td>
<td>机器人路径规划问题</td>
<td>//////</td>
</tr>
<tr>
<td>9</td>
<td>方格取数问题</td>
<td>最大点权独立集</td>
</tr>
<tr>
<td>10</td>
<td>餐巾计划问题</td>
<td>费用流</td>
</tr>
<tr>
<td>11</td>
<td>航空路线问题</td>
<td>费用流</td>
</tr>
<tr>
<td>12</td>
<td>软件补丁问题</td>
<td>最短路径</td>
</tr>
<tr>
<td>13</td>
<td>星际转移问题</td>
<td>残量网络最大流</td>
</tr>
<tr>
<td>14</td>
<td>孤岛营救问题</td>
<td>分层图最短路</td>
</tr>
<tr>
<td>15</td>
<td>汽车加油行驶问题</td>
<td>分层图最短路</td>
</tr>
<tr>
<td>16</td>
<td>数字梯形问题</td>
<td>费用流</td>
</tr>
<tr>
<td>17</td>
<td>运输问题</td>
<td>二分图最大权多重匹配</td>
</tr>
<tr>
<td>18</td>
<td>分配问题</td>
<td>二分图最大权匹配</td>
</tr>
<tr>
<td>19</td>
<td>负载平衡问题</td>
<td>费用流</td>
</tr>
<tr>
<td>20</td>
<td>深海机器人问题</td>
<td>费用流</td>
</tr>
<tr>
<td>21</td>
<td>最长k可重区间集问题</td>
<td>最大权不相交路径</td>
</tr>
<tr>
<td>22</td>
<td>最长k可重线段集问题</td>
<td>费用流</td>
</tr>
<tr>
<td>23</td>
<td>火星探险问题</td>
<td>费用流</td>
</tr>
<tr>
<td>24</td>
<td>骑士共存问题</td>
<td>最大独立集</td>
</tr>
</tbody>
</table>
<h2 id="1">1.飞行员配对方案问题<a class="headerlink" href="#1" title="Permanent link">Link</a></h2>
<p>二分图最大匹配，直接建图跑最大流。</p>
<p>```cpp linenums=&rdquo;1&rdquo;</p>
<h1 id="include">include<bits/stdc++.h><a class="headerlink" href="#include" title="Permanent link">Link</a></h1>
<p>using namespace std;</p>
<p>const int MAX_V=200+10;
const int INF=0x3f3f3f3f;</p>
<p>//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};</p>
<p>vector<edge> G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧</p>
<p>void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}</p>
<p>//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue<int> que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i<G[v].size();i++)
        {
            edge &e=G[v][i];
            if(e.cap>0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}</p>
<p>//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i<G[v].size();i++)
    {
        edge &e=G[v][i];
        if(e.cap>0 &amp;&amp; level[v]<level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d>0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}</p>
<p>//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
}</p>
<p>int main()
{
    int n,m,u,v;
    scanf(&ldquo;%d%d&rdquo;,&amp;n,&amp;m);
    int S=0,T=n+1;
    for(int i=1;i&lt;=n;i++)
    {
        if(i&lt;=m) add(S,i,1);
        else add(i,T,1);
    }
    while(scanf(&ldquo;%d%d&rdquo;,&amp;u,&amp;v)!=EOF) add(u,v,1);
    printf(&ldquo;%d\n&rdquo;,max_flow(S,T));
    return 0;
}</p>
<pre class="codehilite"><code class="linenums">## 2.太空飞行计划问题

必须选择所有左端点才能选择右端点获得收益，最大权闭合子图模型。最大权闭合子图=总权值和-最小割

输出方案时选择与S/T相连满流的割边。

```cpp linenums=&quot;1&quot;
#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=2500+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

int n,m;

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) break;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
    int cnt=0;
    for(int i=1;i&lt;=m;i++)
    {
        if(level[i]&gt;0)
        {
            if(cnt++) printf(&quot; &quot;);
            printf(&quot;%d&quot;,i);
        }
    }
    printf(&quot;\n&quot;);
    cnt=0;
    for(int i=1+m;i&lt;=n+m;i++)
    {
        if(level[i]&gt;0)
        {
            if(cnt++) printf(&quot; &quot;);
            printf(&quot;%d&quot;,i-m);
        }
    }
    printf(&quot;\n&quot;);
    return flow;
}

int main()
{
    int val,sum=0,a[55],b[55];
    char tools[10000];
    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
    int S=0,T=m+n+1;
    for(int i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d&quot;,&amp;val);
        b[i]=val;
        sum+=val;
        add(S,i,val);
        memset(tools,0,sizeof tools);
        cin.getline(tools,10000);
        int ulen=0,tool;
        while(sscanf(tools+ulen,&quot;%d&quot;,&amp;tool)==1)
        {
            add(i,tool+m,INF);
            if(tool==0) ulen++;
            else
            {
                while(tool)
                {
                    tool/=10;
                    ulen++;
                }
            }
            ulen++;
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;val);
        add(i+m,T,val);
        a[i]=val;
    }
    printf(&quot;%d\n&quot;,sum-max_flow(S,T));
    return 0;
}
</code></pre>

<h2 id="3">3.  最小路径覆盖问题<a class="headerlink" href="#3" title="Permanent link">Link</a></h2>
<p>拆点求最小路径覆盖，最小路径覆盖数=|G|-二分图最大匹配数（｜Ｇ｜是有向图中的总边数）</p>
<p>输出路径：并查集维护同一路径上的点，从根节点递归向下找满流的点。</p>
<p>```cpp linenums=&rdquo;1&rdquo;</p>
<h1 id="include_1">include<bits/stdc++.h><a class="headerlink" href="#include_1" title="Permanent link">Link</a></h1>
<p>using namespace std;</p>
<p>const int MAX_V=400+10;
const int INF=0x3f3f3f3f;</p>
<p>//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};</p>
<p>vector<edge> G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧</p>
<p>void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}</p>
<p>//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue<int> que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i<G[v].size();i++)
        {
            edge &e=G[v][i];
            if(e.cap>0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}</p>
<p>//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i<G[v].size();i++)
    {
        edge &e=G[v][i];
        if(e.cap>0 &amp;&amp; level[v]<level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d>0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}</p>
<p>//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
}</p>
<p>int n;</p>
<p>void print(int x)
{
    for(auto e:G[x])
    {
        if(e.cap==0&amp;&amp;e.to&gt;n)
        {
            printf(&rdquo; %d&rdquo;,e.to-n);
            print(e.to-n);
        }
    }
}</p>
<p>int pre[400+10];</p>
<p>int Find(int x) {return x==pre[x]?x:pre[x]=Find(pre[x]); }</p>
<p>int main()
{
    int m,u,v;
    scanf(&ldquo;%d%d&rdquo;,&amp;n,&amp;m);
    int S=0,T=2*n+1;
    for(int i=1;i&lt;=n;i++)
    {
        add(S,i,1);
        add(i+n,T,1);
    }
    for(int i=0;i&lt;m;i++)
    {
        scanf(&ldquo;%d%d&rdquo;,&amp;u,&amp;v);
        add(u,v+n,1);
    }
    int ans=n-max_flow(S,T);
    for(int i=S;i&lt;=T;i++) pre[i]=i;
    for(int i=1;i&lt;=n;i++)
        for(auto e:G[i])
            if(e.to&gt;n&amp;&amp;e.to&lt;T&amp;&amp;e.cap==0) pre[e.to-n]=Find(i);
    for(int i=1;i&lt;=n;i++)
    {
        if(i==Find(i))
        {
            printf(&ldquo;%d&rdquo;,i);
            print(i);
            printf(&ldquo;\n&rdquo;);
        }
    }
    printf(&ldquo;%d\n&rdquo;,ans);
    return 0;
}</p>
<pre class="codehilite"><code class="linenums">## 4.魔术球问题

拆点建二分图，枚举答案A，在原图上直接加点并在残量网络中直接增广，所求答案为最小路径覆盖，当最小路径覆盖≤n时均为可行解。向前取满流边输出路径

```cpp
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int nex[MAX_V];
bool vis[MAX_V];

int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    int m = 0, ans = 0, s = 0, t = 10000;
    for(;;)
    {
        m ++;
        for(int i = 1; i &lt; m; i ++)
            if(sqrt(i + m) == (int)sqrt(i + m)) add(i, m + 5000, 1);
        add(s, m, 1), add(m + 5000, t, 1);
        ans += max_flow(s, t);
        if(m - ans &gt; n) break;
    }
    printf(&quot;%d\n&quot;, m - 1);
    for(int i = 1; i &lt; m; i ++) for(auto x : G[i]) if(x.cap == 0) {nex[i] = x.to - 5000; break; }
    for(int i = 1; i &lt; m; i ++)
    {
        if(vis[i]) continue;
        printf(&quot;%d&quot;, i);
        int p = nex[i];
        while(p != -5000)
        {
            vis[p] = 1;
            printf(&quot; %d&quot;, p);
            p = nex[p];
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

<h2 id="5">5.  圆桌问题<a class="headerlink" href="#5" title="Permanent link">Link</a></h2>
<p>二分图多重匹配，建图跑最大流。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int main()
{
    int n, m, x, sum = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int s = 0, t = n + m + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(s, i, x);
        sum += x;
    }
    for(int i = 1 + n; i &lt;= m + n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(i, t, x);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1 + n; j &lt;= m + n; j ++) add(i, j, 1);
    if(sum &gt; max_flow(s, t)) return puts(&quot;0&quot;), 0;
    puts(&quot;1&quot;);
    for(int i = 1; i &lt;= n; i ++)
    {
        bool flag = false;
        for(auto x : G[i]) if(x.cap == 0)
        {
            if(flag) printf(&quot; &quot;);
            flag = true;
            if(x.to != 0) printf(&quot;%d&quot;, x.to - n);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

<h2 id="6">6.  最长递增子序列问题<a class="headerlink" href="#6" title="Permanent link">Link</a></h2>
<p>第一问跑n方的dp，第二问对于<code>f[j]=f[i]+1</code>且<code>a[i]&lt;a[j]</code>的点连流量为1的边跑最大流，第三问将点1和n的边改为INF跑最大流。</p>
<p>最长长度为1时后两问直接输出个数。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, k;
int a[MAX_V], f[MAX_V];

int solve1()
{
    int S = 0, T = 2 * n + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        if(f[i] == 1) add(S, i, 1);
        if(f[i] == k) add(i + n, T, 1);
        add(i, i + n, 1);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = i + 1; j &lt;= n; j ++)
            if(a[i] &lt;= a[j] &amp;&amp; f[j] == f[i] + 1) add(i + n, j, 1);
    int ans = max_flow(S, T);
    printf(&quot;%d\n&quot;, ans);
    return ans;
}

void solve2()
{
    int S = 0, T = 2 * n + 1, v;
    for(int i = S; i &lt;= T; i ++) G[i].clear();
    for(int i = 1; i &lt;= n; i ++)
    {
        v = (i == 1 || i == n) ? INF : 1;
        if(f[i] == 1) add(S, i, v);
        if(f[i] == k) add(i + n, T, v);
        add(i, i + n, v);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = i + 1; j &lt;= n; j ++)
            if(a[i] &lt;= a[j] &amp;&amp; f[j] == f[i] + 1) add(i + n, j, 1);
    printf(&quot;%d\n&quot;, max_flow(S, T));
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= n; i ++)
    {
        f[i] = 1;
        for(int j = 1; j &lt; i; j ++)
            if(a[i] &gt;= a[j]) f[i] = max(f[i], f[j] + 1);
        k = max(k, f[i]);
    }
    printf(&quot;%d\n&quot;, k);
    int ans = solve1();
    if(k &gt; 1) solve2();
    else printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

<h2 id="7">7.试题库问题<a class="headerlink" href="#7" title="Permanent link">Link</a></h2>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1200 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int main()
{
    int n, k, t, x, sum = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    int S = 0, T = n + k + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(i + k, T, x);
        sum += x;
    }
    for(int i = 1; i &lt;= k; i ++)
    {
        scanf(&quot;%d&quot;, &amp;t);
        add(S, i, 1);
        while(t --)
        {
            scanf(&quot;%d&quot;, &amp;x);
            add(i, k + x, 1);
        }
    }
    if(max_flow(S, T) &lt; sum) return 0 * puts(&quot;No Solution!&quot;);
    for(int i = k + 1; i &lt;= k + n; i ++)
    {
        printf(&quot;%d:&quot;, i - k);
        for(auto v : G[i]) if(v.cap) printf(&quot; %d&quot;, v.to);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

<h2 id="9">9.方格取数问题<a class="headerlink" href="#9" title="Permanent link">Link</a></h2>
<p>对方格上的点根据行列奇偶黑白染色，建二分图，黑点向四周白点连边，要求的答案是没有边相连的权值和最大的点集。</p>
<p>二分图最大点权独立集=点权和-二分图最小点权覆盖集</p>
<p>跑最大流减一下</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, m;
inline int pt(int x, int y) { return x * m + y; }

int main()
{
    int x, sum = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int S = 0, T = 1001;
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m; j ++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            if((i + j) % 2)
            {
                add(S, pt(i, j), x);
                if(j + 1 &lt;= m) add(pt(i, j), pt(i, j + 1), INF);
                if(j - 1 &gt; 0) add(pt(i, j), pt(i, j - 1), INF);
                if(i + 1 &lt;= n) add(pt(i, j), pt(i + 1, j), INF);
                if(i - 1 &gt; 0) add(pt(i, j), pt(i - 1, j), INF);
            }
            else add(pt(i, j), T, x);
            sum += x;
        }
    }
    printf(&quot;%d\n&quot;, sum - max_flow(S, T));
    return 0;
}
</code></pre>

<h2 id="10">10.餐巾计划问题<a class="headerlink" href="#10" title="Permanent link">Link</a></h2>
<p>拆点建图，<span class="arithmatex">\(A_i\)</span>表示当天可以提供的餐巾数，<span class="arithmatex">\(B_i\)</span>表示当天获得的餐巾数。</p>
<p><span class="arithmatex">\(S\)</span>向<span class="arithmatex">\(A_i\)</span>连边，流量为当天所需的总数x，费用为0，表示当天最多可以提供x个餐巾。</p>
<p><span class="arithmatex">\(B_i\)</span>向<span class="arithmatex">\(T\)</span>连边，流量为当天所需的总数x，费用为0，表示当天最少需要获得x个餐巾。</p>
<p><span class="arithmatex">\(S\)</span>向<span class="arithmatex">\(B_i\)</span>连边，流量为INF，费用为<span class="arithmatex">\(P\)</span>，表示在当天购买新餐巾的花费。</p>
<p><span class="arithmatex">\(A_i\)</span>向<span class="arithmatex">\(B_{i+M}\)</span>连边，流量为INF，费用为<span class="arithmatex">\(F\)</span>，表示在第i天经过M天的快洗可以获得餐巾。</p>
<p><span class="arithmatex">\(A_i\)</span>向<span class="arithmatex">\(B_{i+N}\)</span>连边，流量为INF，费用为<span class="arithmatex">\(S\)</span>，表示在第i天经过N天的慢洗可以获得餐巾。</p>
<p>跑费用流即可。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int main()
{
    int n, P, M, F, N, S, x;
    scanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;P, &amp;M, &amp;F, &amp;N, &amp;S);
    int s = 0, t = 2 * n + 1;
    ans.init(t);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        ans.addEdge(s, i * 2 - 1, x, 0);
        ans.addEdge(i * 2, t, x, 0);
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(s, i * 2, inf, P);
    for(int i = 1; i &lt; n; i ++) ans.addEdge(i * 2 - 1, i * 2 + 1, inf, 0);
    for(int i = 1; i + M &lt;= n; i ++) ans.addEdge(i * 2 - 1, (i + M) * 2, inf, F);
    for(int i = 1; i + N &lt;= n; i ++) ans.addEdge(i * 2 - 1, (i + N) * 2, inf, S);
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(s, t));
    return 0;
}
</code></pre>

<h2 id="11">11.航空路线问题<a class="headerlink" href="#11" title="Permanent link">Link</a></h2>
<p>建图跑费用流，根据流量变化输出路径。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 200 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };
string name[15];

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }

    void printPath(int s, int t, int n)
    {
        cout &lt;&lt; name[1] &lt;&lt; endl;
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to &gt; x - n &amp;&amp; edges[i].flow &gt; 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    cout &lt;&lt; name[v] &lt;&lt; endl;
                    break;
                }
            }
        }
        vector&lt;int&gt; ans;
        ans.push_back(1);
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to &gt; x - n &amp;&amp; edges[i].flow &gt; 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    ans.push_back(v);
                    break;
                }
            }
        }
        for(int i = ans.size() - 2; i &gt;= 0; i --) cout &lt;&lt; name[ans[i]] &lt;&lt; endl;
    }
}ans;

int main()
{
    int n, m;
    string x, y;
    map&lt;string, int&gt; mp;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
    {
        cin &gt;&gt; x;
        mp[x] = i;
        name[i] = x;
    }
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    while(m --)
    {
        cin &gt;&gt; x &gt;&gt; y;
        int u = mp[x], v = mp[y];
        if(u &gt; v) swap(u, v);
        ans.addEdge(u + n, v, 2, 0);
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i, i + n, 1, -1);
    ans.addEdge(1, 1 + n, 1, 0);
    ans.addEdge(n, n + n, 1, 0);
    ans.addEdge(S, 1, 2, 0);
    ans.addEdge(2 * n, T, 2, 0);
    int res = -ans.mincostMaxFlow(S, T);
    if(res == 0) return 0 * puts(&quot;No Solution!&quot;);
    cout &lt;&lt; res &lt;&lt; endl;
    ans.printPath(S, T, n);
    return 0;
}
</code></pre>

<h2 id="12">12.软件补丁问题<a class="headerlink" href="#12" title="Permanent link">Link</a></h2>
<p>我缓缓打出一个问号</p>
<p>这是个锤子的网络流，这是最短路啊</p>
<p>状压一下转移方案然后跑从(1&lt;&lt;n)-1到0的最短路</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = (1 &lt;&lt; 21);
const int inf = 0x3f3f3f3f;

struct node
{
    int b1, b2, f1, f2, w;
    bool check(int x) { return ((x &amp; b1) == b1) &amp;&amp; ((x &amp; b2) == 0); }
    int change(int x)
    {
        x ^= x &amp; f1;
        x |= f2;
        return x;
    }
}a[105];

int n, m, dis[maxn];

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = 0; i &lt; m; i ++) if(a[i].check(u))
        {
            int v = a[i].change(u);
            if(dis[v] &gt; dis[u] + a[i].w)
            {
                dis[v] = dis[u] + a[i].w;
                que.push({dis[v], v});
            }
        }
    }
}

int main()
{
    char s1[55], s2[55];
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 0; i &lt; m; i ++)
    {
        scanf(&quot;%d%s%s&quot;, &amp;a[i].w, s1, s2);
        for(int j = 0; j &lt; n; j ++)
        {
            if(s1[j] == '+') a[i].b1 |= (1 &lt;&lt; j);
            else if(s1[j] == '-') a[i].b2 |= (1 &lt;&lt; j);
            if(s2[j] == '-') a[i].f1 |= (1 &lt;&lt; j);
            else if(s2[j] == '+') a[i].f2 |= (1 &lt;&lt; j);
        }
    }
    dijkstra((1 &lt;&lt; n) - 1);
    printf(&quot;%d\n&quot;, dis[0] == inf ? 0 : dis[0]);
    return 0;
}
</code></pre>

<h2 id="13">13.星际转移问题<a class="headerlink" href="#13" title="Permanent link">Link</a></h2>
<p>拆点建图，枚举天数。对于第i天上的点x，从i-1天的x点连容量为INF的边；并对当天的转移方案连边，每次直接在残量网络上跑最大流，总流量等于k时的天数即为答案。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int pos[105][105], x[105], t[105];

int main()
{
    int n, m, k;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    for(int i = 0; i &lt; m; i ++)
    {
        scanf(&quot;%d%d&quot;, &amp;x[i], &amp;t[i]);
        for(int j = 0; j &lt; t[i]; j ++)
        {
            scanf(&quot;%d&quot;, &amp;pos[i][j]);
            pos[i][j] += 2;
        }
    }
    int S = 0, T, ans = 0;
    add(S, 2, k);
    n += 2;
    for(int tt = 1; tt &lt;= 100; tt ++)
    {
        T = tt * n + 1;
        for(int i = 0; i &lt; m; i ++)
        {
            int u = (tt - 1) % t[i], v = tt % t[i];
            u = pos[i][u], v = pos[i][v];
            add((tt - 1) * n + u, tt * n + v, x[i]);
        }
        for(int i = 1; i &lt;= n; i ++) add((tt - 1) * n + i, tt * n + i, INF);
        ans += max_flow(S, T);
        if(ans &gt;= k) return 0 * printf(&quot;%d\n&quot;, tt);
    }
    puts(&quot;0&quot;);
    return 0;
}
</code></pre>

<h2 id="14">14. 孤岛营救问题<a class="headerlink" href="#14" title="Permanent link">Link</a></h2>
<p>状压+分层图最短路，代码能力丢人，调一下午</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 2e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[20*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int n, m, sum;

int pt(int x, int y, int dep)
{
    int id = (x - 1) * m + y;
    return id + dep * sum;
}

int mp[105][105], key[105][105], lim;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int p, x1, y1, x2, y2, g, k;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p);
    lim = (1 &lt;&lt; p);
    sum = n * m;
    scanf(&quot;%d&quot;, &amp;k);
    memset(head, 0xff, sizeof dis);
    while(k --)
    {
        scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;g);
        int u = pt(x1, y1, 0), v = pt(x2, y2, 0);
        if(g == 0) mp[u][v] = mp[v][u] = -1;
        else mp[u][v] = mp[v][u] = (1 &lt;&lt; (g - 1));
    }
    scanf(&quot;%d&quot;, &amp;k);
    while(k --)
    {
        scanf(&quot;%d%d%d&quot;, &amp;x1, &amp;y1, &amp;g);
        key[x1][y1] |= (1 &lt;&lt; (g - 1));
    }
    for(int i = 0; i &lt; lim; i ++)
    {
        for(int x = 1; x &lt;= n; x ++)
        {
            for(int y = 1; y &lt;= m; y ++)
            {
                for(int k = 0; k &lt; 4; k ++)
                {
                    int xx = x + dx[k], yy = y + dy[k];
                    if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;
                    if(mp[pt(x, y, 0)][pt(xx, yy, 0)] == -1) continue;
                    int op = mp[pt(x, y, 0)][pt(xx, yy, 0)];
                    if((op &amp; i) == op) add(pt(x, y, i), pt(xx, yy, i | key[xx][yy]), 1);
                }
            }
        }
    }
    int s = pt(1, 1, 0), t = pt(n, m, lim - 1) + 1;
    for(int i = 0; i &lt; lim; i ++) add(pt(n, m, i), t, 0);
    dijkstra(s);
    printf(&quot;%d\n&quot;, dis[t] == inf ? -1 : dis[t]);
    return 0;
}
</code></pre>

<h2 id="15">15.汽车加油行驶问题<a class="headerlink" href="#15" title="Permanent link">Link</a></h2>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 5e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[2*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int p[105][105], n;

int pt(int x, int y, int dep)
{
    return (x - 1) * n + y + dep * n * n;
}

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int k, a, b, c;
    scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;k, &amp;a, &amp;b, &amp;c);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            scanf(&quot;%d&quot;, &amp;p[i][j]);
    int s = 0, t = pt(n, n, k) + 1;
    memset(head, 0xff, sizeof head);
    add(s, pt(1, 1, k), 0);
    for(int x = 1; x &lt;= n; x ++)
    {
        for(int y = 1; y &lt;= n; y ++)
        {
            for(int i = 0; i &lt;= k; i ++) add(pt(x, y, i), pt(x, y, k), a + c);
            for(int i = 0; i &lt; 4; i ++)
            {
                int fx = dx[i] + x, fy = dy[i] + y;
                if(fx &lt; 1 || fx &gt; n || fy &lt; 1 || fy &gt; n) continue;
                for(int j = 1; j &lt;= k; j ++)
                {
                    if(p[fx][fy])
                    {
                        if(fx &lt; x || fy &lt; y)add(pt(x, y, j), pt(fx, fy, k), a + b);
                        else add(pt(x, y, j), pt(fx, fy, k), a);
                    }
                    else
                    {
                        if(fx &lt; x || fy &lt; y) add(pt(x, y, j), pt(fx, fy, j - 1), b);
                        else add(pt(x, y, j), pt(fx, fy, j - 1), 0);
                    }
                }
            }
        }
    }
    for(int i = 0; i &lt;= k; i ++) add(pt(n, n, i), t, 0);
    dijkstra(s);
    printf(&quot;%d\n&quot;,dis[t]);
    return 0;
}
</code></pre>

<h2 id="16">16.数字梯形问题<a class="headerlink" href="#16" title="Permanent link">Link</a></h2>
<p>第一问求不相交路径，拆点使i到i+n的流量为1</p>
<p>第二问点可以多次使用，把上面拆点的流量改成INF</p>
<p>第三问边也可以多次使用，把加的边的流量也改成INF，注意最下层到T的边也要改</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, p, a[55][55];

void solve1()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, 1, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, 1, 0);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

void solve3()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, inf, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, inf, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    p = (n + (n + m - 1)) * m / 2;
    for(int i = 0; i &lt; m; i ++)
        for(int j = 1; j &lt;= n + i; j ++)
            scanf(&quot;%d&quot;, &amp;a[i][j]);
    solve1();
    solve2();
    solve3();
    return 0;
}
</code></pre>

<h2 id="17">17.运输问题<a class="headerlink" href="#17" title="Permanent link">Link</a></h2>
<p>二分图最大权多重匹配，无脑费用流</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, a[105], b[105], cost[105][105];

void solve1()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i &lt;= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            ans.addEdge(i, j + n, inf, -cost[i][j]);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i &lt;= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            ans.addEdge(i, j + n, inf, cost[i][j]);
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= m; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            scanf(&quot;%d&quot;, &amp;cost[i][j]);
    solve2();
    solve1();
    return 0;
}
</code></pre>

<h2 id="18">18.分配问题<a class="headerlink" href="#18" title="Permanent link">Link</a></h2>
<p>二分图最大权匹配，无脑费用流*2</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, cost[105][105];

void solve1()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            ans.addEdge(i, j + n, 1, cost[i][j]);
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            ans.addEdge(i, j + n, 1, -cost[i][j]);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            scanf(&quot;%d&quot;, &amp;cost[i][j]);
    solve1();
    solve2();
    return 0;
}
</code></pre>

<h2 id="19">19.负载平衡问题<a class="headerlink" href="#19" title="Permanent link">Link</a></h2>
<p>拆点跑费用流，<span class="arithmatex">\(S\)</span>向<span class="arithmatex">\(A_i\)</span>连边，流量为当前点原来的大小，费用为0；<span class="arithmatex">\(A_i\)</span>向<span class="arithmatex">\(B_i\)</span>连边，费用为0，向<span class="arithmatex">\(B_{i-1}\)</span>和<span class="arithmatex">\(B_{i+1}\)</span>连边，费用为1，容量为INF;<span class="arithmatex">\(B_i\)</span>向<span class="arithmatex">\(T\)</span>连边，流量为目标值大小，费用为0.</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 1000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;


int main()
{
    int n, sum = 0, x;
    scanf(&quot;%d&quot;, &amp;n);
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        sum += x;
        ans.addEdge(S, i, x, 0);
    }
    sum /= n;
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, inf, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i, i + n, sum, 0);
    for(int i = 1; i &lt;= n; i ++)
    {
        int x = i - 1, y = i + 1;
        if(x &lt; 1) x += n;
        if(y &gt; n) y -= n;
        ans.addEdge(i, x, inf, 1);
        ans.addEdge(i, y, inf, 1);
    }
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="20">20.深海机器人问题<a class="headerlink" href="#20" title="Permanent link">Link</a></h2>
<p>费用流，输入格式令人D区</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int id[25][25];

int main()
{
    int a, b, p, q, k, x, y;
    scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;p, &amp;q);
    int tot = 0;
    p ++; q ++;
    for(int i = 1; i &lt;= p; i ++)
        for(int j = 1; j &lt;= q; j ++) id[i][j] = ++tot;
    int S = 0, T= tot + 1;
    ans.init(T);
    for(int i = 1; i &lt;= p; i ++)
    {
        for(int j = 1; j &lt; q; j ++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            ans.addEdge(id[i][j], id[i][j + 1], 1, -x);
            ans.addEdge(id[i][j], id[i][j + 1], inf, 0);
        }
    }
    for(int j = 1; j &lt;= q; j ++)
    {
        for(int i = 1; i &lt; p; i ++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            ans.addEdge(id[i][j], id[i + 1][j], 1, -x);
            ans.addEdge(id[i][j], id[i + 1][j], inf, 0);
        }
    }
    while(a --)
    {
        scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y);
        ans.addEdge(S, id[x + 1][y + 1], k, 0);
    }
    while(b --)
    {
        scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y);
        ans.addEdge(id[x + 1][y + 1], T, k, 0);
    }
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="21k">21.最长k可重区间集问题<a class="headerlink" href="#21k" title="Permanent link">Link</a></h2>
<p>拆点建图，超级源点<span class="arithmatex">\(S\)</span>向<span class="arithmatex">\(S1\)</span>连边，流量为<span class="arithmatex">\(k\)</span>，费用为0，表示最多取<span class="arithmatex">\(k\)</span>个开头的区间；<span class="arithmatex">\(S1\)</span>向<span class="arithmatex">\(A_i\)</span>连边，流量为1，费用为0；<span class="arithmatex">\(A_i\)</span>向<span class="arithmatex">\(B_i\)</span>连边，费用为该区间权值，表示取这个区间；<span class="arithmatex">\(B_i\)</span>向所有在其右侧且与它不相交的<span class="arithmatex">\(A_i\)</span>连边，流量为1，费用为0；<span class="arithmatex">\(B_i\)</span>向<span class="arithmatex">\(T\)</span>连边，流量为1，费用为0，跑<span class="arithmatex">\(S\)</span>到<span class="arithmatex">\(T\)</span>的费用流。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int l[505], r[505], c[505];

int main()
{
    int n, k;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    int S = 0, T = 2 * n + 1, S1 = T + 1;
    ans.init(S1);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]);
        if(l[i] &gt; r[i]) swap(l[i], r[i]);
        ans.addEdge(i, i + n, 1, -(r[i] - l[i]));
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            if(r[i] &lt;= l[j]) ans.addEdge(i + n, j, 1, 0);
    ans.addEdge(S, S1, k, 0);
    for(int i = 1; i &lt;= n; i ++)
    {
        ans.addEdge(S1, i, 1, 0);
        ans.addEdge(i + n, T, 1, 0);
    }
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="22k">22.最长k可重线段集问题<a class="headerlink" href="#22k" title="Permanent link">Link</a></h2>
<p>跟上一题模型其实是一样的，换了个方法。</p>
<p>把线段投影到X轴上，就转化成了区间集问题，但是因为存在<code>x=r</code>这样的线段，如果直接建图会产生负环，需要拆点。</p>
<p>离散化区间端点，相邻的点连边，流量为INF，费用为0；区间端点<code>L[i]</code>向<code>R[i]</code>连流量为1的边，边权为<code>-val[i]</code>，S和T分别向最左和最右端点连流量为k，费用为0的边。跑费用流即为答案。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

inline int dis(int x1, int y1, int x2, int y2) {
    return sqrt(1ll * (x2 - x1) * (x2 - x1) + 1ll *(y2 - y1) * (y2 - y1));
}

int n, L[505], R[505], val[505];
map&lt;int, int&gt; M;

int discretization()
{
    vector&lt;int&gt; v;
    for(int i = 1; i &lt;= n; i ++) v.push_back(L[i]), v.push_back(R[i]);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for(int i = 0; i &lt; v.size(); i ++) M[v[i]] = i + 1;
    for(int i = 1; i &lt;= n; i ++) L[i] = M[L[i]], R[i] = M[R[i]];
    return v.size();
}

int main()
{
    int k, a, b, c, d;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
        val[i] = dis(a, b, c, d);
        L[i] = a * 2, R[i] = c * 2;
        if(L[i] &gt; R[i]) swap(L[i], R[i]);
        if(L[i] == R[i]) R[i] ++;
        else L[i] ++;
    }
    int m = discretization();
    int S = 0, T = m + 1;
    ans.init(T);
    ans.addEdge(S, 1, k, 0), ans.addEdge(m, T, k, 0);
    for(int i = 1; i &lt; m; i ++) ans.addEdge(i, i + 1, inf, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(L[i], R[i], 1, -val[i]);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="23">23.火星探险问题<a class="headerlink" href="#23" title="Permanent link">Link</a></h2>
<p>拆点跑费用流，输出路径</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

int a[50][50], id[50][50];

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }

    void printPath(int cnt, int n, int m)
    {
        int p = id[1][1];
        while(p != id[n][m])
        {
            int x = (p - 1) / m, y = (p - 1) % m;
            for(auto i : G[p + n * m])
            {
                int tmp = edges[i].to;
                int xx = (tmp - 1) / m, yy = (tmp - 1) % m;
                if(xx &lt;= x &amp;&amp; yy &lt;= y) continue;
                if(edges[i].flow &gt; 0)
                {
                    edges[i].flow --;
                    //printf(&quot;%d %d %d %d\n&quot;, edges[i].from, edges[i].to, edges[i].cap, edges[i].flow);
                    //printf(&quot;%d %d\n&quot;, xx + 1, yy + 1);
                    if(xx &gt; x) printf(&quot;%d 0\n&quot;, cnt);
                    else printf(&quot;%d 1\n&quot;, cnt);
                    p = tmp;
                    break;
                }
            }
        }
    }
}ans;

int main()
{
    int x, n, m;
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;m, &amp;n);
    int S = 0, T = 2 * n * m + 1, tot = 0;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            scanf(&quot;%d&quot;, &amp;a[i][j]), id[i][j] = ++tot;
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m; j ++)
        {
            if(i + 1 &lt;= n) ans.addEdge(id[i][j] + n * m, id[i + 1][j], inf, 0);
            if(j + 1 &lt;= m) ans.addEdge(id[i][j] + n * m, id[i][j + 1], inf, 0);
            if(a[i][j] == 0 || a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, inf, 0);
            if(a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, 1, -1);
        }
    }
    ans.addEdge(S, id[1][1], x, 0);
    ans.addEdge(id[n][m] + n * m, T, x, 0);
    ans.mincostMaxFlow(S, T);
    for(int i = 1; i &lt;= x; i ++) ans.printPath(i, n, m);
    return 0;
}
</code></pre>

<h2 id="24">24.骑士共存问题<a class="headerlink" href="#24" title="Permanent link">Link</a></h2>
<p>显然所给模型是二分图，最大独立集-不可选的边即为答案。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 50000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, vis[205][205];

int dx[8] = {-2, -1, -2, -1, 2, 1, 2, 1};
int dy[8] = {-1, -2, 1, 2, -1, -2, 1, 2};

int id(int x, int y) { return (x - 1) * n + y; }

bool check(int x, int y) { return x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= n &amp;&amp; !vis[x][y]; }

int main()
{
    int m, u, v;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int S = 0, T = n * n + 1;
    for(int i = 0; i &lt; m; i ++)
    {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        vis[u][v] = 1;
    }
    for(int x = 1; x &lt;= n; x ++)
    {
        for(int y = 1; y &lt;= n; y ++)
        {
            if(!check(x, y)) continue;
            if((x + y) % 2) add(S, id(x, y), 1);
            else add(id(x, y), T, 1);
            if((x + y) % 2 == 0) continue;
            for(int i = 0; i &lt; 8; i ++)
            {
                int fx = x + dx[i], fy = y + dy[i];
                if(check(fx, fy)) add(id(x, y), id(fx, fy), 1);
            }
        }
    }
    printf(&quot;%d\n&quot;, n * n - max_flow(S, T) - m);
    return 0;
}
</code></pre>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy;  <a href="https://wiki.badcw.cn" target="_blank">wiki.badcw.cn</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "search": "../../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.c99f48ec.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../../../../search/main.js"></script>
      
    
  </body>
</html>