
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.badcw.cn/Training%20Logs/2020%20Wannafly%20Winter%20Camp/day1/">
      
      <link rel="icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>Day1 - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1dff34a1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CUbuntu+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Ubuntu Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Team Wiki" class="md-header__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Team Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Day1
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Team Wiki" class="md-nav__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          主页
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="主页" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          主页
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        赛季列表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          个人页面
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="个人页面" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          个人页面
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Personal%20Page/Verly/" class="md-nav__link">
        Verly
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Personal%20Page/badcw/" class="md-nav__link">
        badcw
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          关于
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="关于" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          关于
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../About/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    下午比赛
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#to-do-list" class="md-nav__link">
    To-do list
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a" class="md-nav__link">
    A. 期望逆序对
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    B. 密码学
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c" class="md-nav__link">
    C. 染色图
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#e" class="md-nav__link">
    E. 树与路径
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#f" class="md-nav__link">
    F. 乘法
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#h" class="md-nav__link">
    H. 最大公约数
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#i-k" class="md-nav__link">
    I. K小数查询
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


  <h1>Day1</h1>

<p>总之没有什么盐分，强调安全问题</p>
<h2 id="_1">下午比赛<a class="headerlink" href="#_1" title="Permanent link">Link</a></h2>
<p>签到飞快，2 题 rank1，最后一小时回去收拾东西然后鸽了，走的时候 rank8，最后 rank12</p>
<table>
<thead>
<tr>
<th>Name</th>
<th align="center">Date</th>
<th align="center">Solved</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/group/6QKpZkKhsL/contest/265753">2020 CCPC Wannafly Winter Camp Day1 (Div.1&amp;2)</a></td>
<td align="center">2020/1/12</td>
<td align="center">7/10</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
</tr>
</tbody>
</table>
<h2 id="to-do-list">To-do list<a class="headerlink" href="#to-do-list" title="Permanent link">Link</a></h2>
<p><code>E</code></p>
<h2 id="a">A. 期望逆序对<a class="headerlink" href="#a" title="Permanent link">Link</a></h2>
<p>求一个排列，排序一个区间对使得期望逆序对最少求期望。即对于 $[l_i,r_i]$ 中的任何一个整数 $j$，$x_i=j$的概率都是 $(r_i-l_i+1)^{-1}$</p>
<p>显然，对于两个区间 $[a,b]$ 和 $[c,d]$。若 $a + b &lt; c + d$，显然  $[a,b]$ 应该在 $[c,d]$ 前面然后由于这个东西是单向有可传递性的所以直接对区间按权排序，然后计算期望即可</p>
<p>由于 $n\le 5\cdot 10^3$ 计算期望的方法是对于每个点对求它可能是逆序对的期望然后求和即可</p>
<p>所以本题考虑清楚每个点对的期望即可</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *   Copyright (C) 2019 Sangfor Ltd. All rights reserved.
    *
    *   创 建 者： badcw
    *   创建日期： 2020/1/12
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define ll long long
using namespace std;

const int maxn = 5e3+50;
const int mod = 998244353;
ll qp(ll a, ll n) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template &lt;class T&gt;
inline bool scan(T&amp; ret) {
    char c;
    int sgn;
    if (c = getchar(), c == EOF) return 0; // EOF
    while (c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar();
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0');
    ret *= sgn;
    return 1;
}

//template &lt;class T&gt;
//inline void out(T x) {
//    if (x &gt; 9) out(x / 10);
//    putchar(x % 10 + '0');
//}

int n;
int l[maxn], r[maxn];
int idx[maxn];
ll inv[maxn];

ll cal(int i, int j) {
    i = idx[i], j = idx[j];
    ll a = l[i], b = r[i], c = l[j], d = r[j];
    ll res = 0;
    if (c &gt;= b) ;
    else if (c &lt;= a &amp;&amp; d &gt;= b) {
        res = (a - c) * (b - a + 1) + (b - a + 1) * (b - a) / 2;
    } else if (a &lt;= c &amp;&amp; d &lt;= b) {
        res = (b * 2 - c - d) * (d - c + 1) / 2;
    } else if (a &lt;= c &amp;&amp; d &gt;= b) {
        res = (b - c) * (b - c + 1) / 2;
    }
    return res % mod * inv[i] % mod * inv[j] % mod;
}

int main(int argc, char* argv[]) {
//    freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);
//    freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);
//    clock_t ST = clock();
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) {
        scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]), idx[i] = i;
        inv[i] = qp(r[i] - l[i] + 1, mod - 2);
    }
    sort(idx + 1, idx + 1 + n, [](int x, int y) {
        return l[x] + r[x] &lt; l[y] + r[y];
    });
    ll res = 0;
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = i + 1; j &lt;= n; ++j) {
            res = (res + cal(i, j)) % mod;
        }
    }
    printf(&quot;%lld\n&quot;, res % mod);
//    cerr &lt;&lt; &quot;time: &quot; &lt;&lt; ((clock() - ST) * 1000.0 / CLOCKS_PER_SEC) &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
    return 0;
}
```
</code></pre>

<h2 id="b">B. 密码学<a class="headerlink" href="#b" title="Permanent link">Link</a></h2>
<p>有个加模的加密方法，输入加密 $m$ 次后每个串的形式，求原串</p>
<p>签到题，减模倒推即可</p>
<p>??? note &ldquo;Code by Verly&rdquo;
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;</p>
<pre class="codehilite"><code class="linenums">const int maxn = 1000 + 10;
char s[maxn][110];

int x[maxn], y[maxn];

int getid(char c)
{
    if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c - 'a';
    if(c &gt;= 'A' &amp;&amp; c &lt;= 'z') return c - 'A' + 26;
}

int getch(int c)
{
    if(c &gt;= 0 &amp;&amp; c &lt;= 25) return c + 'a';
    return c - 26 + 'A';
}

int len[maxn];

int main()
{
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= m; i ++)
        scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]);
    for(int i = 1; i &lt;= n; i ++) 
    {
        scanf(&quot;%s&quot;, s[i]);
        len[i] = strlen(s[i]);
    }
    for(int i = m; i &gt;= 1; i --)
    {
        int nx = x[i], ny = y[i], lenx = len[nx], leny = len[ny];
        for(int i = 0; s[ny][i]; i ++)
        {
            char a = s[nx][i % lenx], b = s[ny][i];
            int z = (getid(b) + 52 - getid(a)) % 52;
            s[ny][i] = getch(z);
        }
    }
    for(int i = 1; i &lt;= n; i ++) printf(&quot;%s\n&quot;, s[i]);
    return 0;
}

```
</code></pre>

<p>??? note &ldquo;Code by badcw&rdquo;
    <code>cpp
    /*================================================================
    *
    *   创 建 者： badcw
    *   创建日期： 2020/4/18
    *
    ================================================================*/
    #include &lt;bits/stdc++.h&gt;
    #define ll long long
    using namespace std;
    const int maxn = 1e3+50;
    const int mod = 1e9+7;
    int n, m;
    char s[maxn][105];
    int len[maxn];
    int chartoint(char x) {
        if (isupper(x)) return x - 'A' + 26;
        return x - 'a';
    }
    char inttochar(int x) {
        if (x &lt; 26) return x + 'a';
        return x + 'A' - 26;
    }
    void back(char &amp;x, char y) {
        int xx = chartoint(x);
        int yy = chartoint(y);
        xx = (xx - yy + 52) % 52;
        x = inttochar(xx);
    }
    void roll_back(int x, int y) {
        for (int i = 0; i &lt; len[x]; ++i) {
            back(s[x][i], s[y][i % len[y]]);
        }
    }
    int main(int argc, char* argv[]) {
        scanf("%d%d", &amp;n, &amp;m);
        vector&lt;pair&lt;int, int&gt; &gt; a(m);
        for (int i = 0; i &lt; m; ++i) scanf("%d%d", &amp;a[i].first, &amp;a[i].second);
        for (int i = 1; i &lt;= n; ++i) scanf("%s", s[i]), len[i] = strlen(s[i]);
        for (int i = m - 1; i &gt;= 0; --i) roll_back(a[i].second, a[i].first);
        for (int i = 1; i &lt;= n; ++i) {
            printf("%s\n", s[i]);
        }
        return 0;
    }</code></p>
<h2 id="c">C. 染色图<a class="headerlink" href="#c" title="Permanent link">Link</a></h2>
<p>令 $g(n,k)$ 为 $n$ 个点的无向图对点染成 $k$ 种颜色最多的边数，求 $\sum_{i=l}^{r} g(n,i)$
$$
g(n,i)=\frac{n^2-\sum_{i=l}^r{(\lceil\frac{n}{i}\rceil)}^2\cdot(n\%i)+{\lfloor\frac{n}{i}\rfloor}^2\cdot(i-n\%i)}{2}
$$</p>
<p>对该式分块，当$i\le\sqrt{n}$时对每个点单点求值，当$i\ge\sqrt{n}$时对$\lfloor\frac{n}{i}\rfloor$分块求和，其中$\sum_{i=l}^ri$和$n\%i$均为等差数列，而$\lfloor\frac{n}{i}\rfloor$在单个块内相等，每次求$l-1,r$的前缀和差分即可。</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;</p>
<pre class="codehilite"><code class="linenums">#define int ll

const int mod = 998244353;

ll qp(ll a, ll n = mod - 2)
{
    ll ans = 1, base = a;
    while(n)
    {
        if(n &amp; 1) (ans *= base) %= mod;
        (base *= base) %= mod;
        n &gt;&gt;= 1;
    }
    return ans;
}

signed main()
{
    int t;
    scanf(&quot;%lld&quot;, &amp;t);
    while(t --)
    {
        ll n, l, r;
        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;l, &amp;r);
        int m = sqrt(n);
        ll res = 0;
        res = 1ll * n * n % mod * (r - l + 1) % mod;
        if(m &gt; r) m = r;
        for(int i = l; i &lt;= m; i ++)
        {
            res = (res - (n / i + 1) * (n / i + 1) % mod * (n % i) % mod + mod - (n / i) * (n / i) % mod * (i - n % i) % mod + mod) % mod;
        }
        if(m &lt; l - 1) m = l - 1;
        int x = n / (m + 1), posl = m + 1;
        for(int i = x; i &gt;= 1 &amp;&amp; posl &lt;= r; i --)
        {
            int posr = n / i;
            if(posr &gt; r) posr = r;
            ll a = n % posl, b = n % posr;
            ll left = (a + b) * (posr - posl + 1) % mod * qp(2) % mod;
            ll right = ((posl + posr) * (posr - posl + 1) % mod * qp(2) % mod - left + mod) % mod;
            res = (res - 1ll * (i + 1) * (i + 1)  % mod * left % mod + mod - 1ll * i * i % mod * right % mod + mod) % mod;
            posl = posr + 1;
            if(posr == r) break;
        }
        res = res * qp(2) % mod;
        printf(&quot;%lld\n&quot;, res);
    }
    return 0;
}
```
</code></pre>

<h2 id="e">E. 树与路径<a class="headerlink" href="#e" title="Permanent link">Link</a></h2>
<p>??? note &ldquo;Code&rdquo;
    <code>cpp
    #include &lt;bits/stdc++.h&gt;
    using namespace std;
    const int N=500010;
    typedef long long LL;
    int n,m;
    struct edge{
        int b,nt;
    }e[N*2];
    int p[N],nn;
    int fa[N][32];
    LL f[N],g[N],h[N];
    void anode(int x,int y){
        nn++;e[nn].b=y;e[nn].nt=p[x];p[x]=nn;
        swap(x,y);
        nn++;e[nn].b=y;e[nn].nt=p[x];p[x]=nn;
    }
    int deep[N];
    void dfsLCA(int x,int ff=-1,int dd=0){
        for(int i=1;(1&lt;&lt;i)&lt;=dd;i++){
            fa[x][i]=fa[ fa[x][i-1] ][i-1];
        }
        deep[x]=dd;
        for(int i=p[x];i;i=e[i].nt){
            int t=e[i].b;
            if(t==ff)continue;
            fa[t][0]=x;
            dfsLCA(t,x,dd+1);
        }
    }
    int LCA(int x,int y){
        if(deep[x]&lt;deep[y])swap(x,y);
        int t=deep[x]-deep[y];
        for(int i=0;(1&lt;&lt;i)&lt;=t;i++)if(t&amp;(1&lt;&lt;i))x=fa[x][i];
        if(x==y)return y;
        for(int i=30;i&gt;=0;i--){
            if(fa[x][i]!=fa[y][i]){
                x=fa[x][i];
                y=fa[y][i];
            }
        } 
        return fa[x][0];
    }
    int findf(int x,int d){
        for(int i=0;(1&lt;&lt;i)&lt;=d;i++)if(d&amp;(1&lt;&lt;i))x=fa[x][i];
        return x;
    }
    LL ans[N];
    void dfs1(int x){
        for(int i=p[x];i;i=e[i].nt){
            int t=e[i].b;
            if(t==fa[x][0])continue;
            dfs1(t);
            g[x]+=g[t];
            h[x]+=h[t];
        }
        g[x]+=h[x];
    }
    void dfs2(int x){
        for(int i=p[x];i;i=e[i].nt){
            int t=e[i].b;
            if(t==fa[x][0])continue;
            dfs2(t);
            f[x]+=f[t];
        }
        f[x]+=g[x];
    }
    void getAns(int x,LL now){
        ans[x]=now;
        for(int i=p[x];i;i=e[i].nt){
            int t=e[i].b;
            if(t==fa[x][0])continue;
            getAns(t,now-g[t]);
        }
    }
    int main(){
    #ifdef WK
        freopen("in.txt","r",stdin);
    #endif
        scanf("%d%d",&amp;n,&amp;m);
        for(int i=1;i&lt;n;i++){
            int aa,bb;
            scanf("%d%d",&amp;aa,&amp;bb);
            anode(aa,bb);
        }
        dfsLCA(1);
        LL asum=0;
        for(int i=1;i&lt;=m;i++){
            int aa,bb;
            scanf("%d%d",&amp;aa,&amp;bb);
            if(aa==bb)continue;
            if(fa[aa][0]==bb||fa[bb][0]==aa)continue;
            int cc=LCA(aa,bb);
            int dis=2*deep[cc]-deep[aa]-deep[bb];dis=-dis;
            if(deep[aa]&lt;deep[bb])swap(aa,bb);
            f[aa]+=dis-1;f[bb]+=dis-1;
            if(bb==cc){
                g[aa]+=dis-1;
                g[cc]+=dis-1;
                h[fa[aa][0]]-=2;
                h[cc]+=2;
            }else
            {
                g[aa]+=dis-1;
                h[fa[aa][0]]-=2;h[cc]-=2ll*(deep[aa]-deep[cc]-1)+1-dis;
                g[bb]+=dis-1;
                h[fa[bb][0]]-=2;h[cc]-=2ll*(deep[bb]-deep[cc]-1)+1-dis;
                h[cc]+=2;g[cc]-=2;
            }
            asum += 1ll*(deep[aa]-deep[cc])*(deep[bb]-deep[cc]);
        }
        dfs1(1);
        dfs2(1);
        getAns(1,asum);
        for(int i=1;i&lt;=n;i++)printf("%lld\n",ans[i]);
        return 0;
    }</code></p>
<h2 id="f">F. 乘法<a class="headerlink" href="#f" title="Permanent link">Link</a></h2>
<p>给出两个序列，求全积中第 $k$ 大的数</p>
<p>二分答案，然后对答案进行 check，每次求比当前二分的答案小的数的个数，可以考虑将 $B$ 序列排序，枚举所有 $A$ 套一层二分求出小于它的数的个数即可</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N=100010;
    typedef long long LL;
    int n,m;LL k;
    LL MAXN = 1000000000000000ll;
    LL A[N],B[N];
    int L,R;</p>
<pre class="codehilite"><code class="linenums">int findf(int f,LL x,LL y){
    //yz=x;
    if(!f){
        LL l=1,r=m,rtn=0;
        while(l&lt;=r){
            LL mid=l+r&gt;&gt;1;
            if(B[mid]*y&gt;=x){
                rtn=mid;l=mid+1;
            }else r=mid-1;
        }
        return rtn;
    }else{
        LL l=1,r=m,rtn=m+1;
        while(l&lt;=r){
            LL mid=l+r&gt;&gt;1;
            if(B[mid]*y&gt;=x){
                rtn=mid;r=mid-1;
            }else l=mid+1;
        }
        return m-rtn+1;
    }
}

int check(LL x){
    LL cnt = 0;

    for(int i=1;i&lt;=n;i++){

        if(A[i]==0){
            if(x&lt;0)cnt+=m; 
        }else{
            int f = (A[i]&gt;0);

            cnt+=findf(f,x,A[i]);
        }


    }

    return cnt&gt;=k;
}

LL solve(){
    LL l=-MAXN,r=MAXN,rtn=MAXN*10;
    while(l&lt;=r){
        LL mid=l+r&gt;&gt;1;
        if(check(mid)){
            rtn=mid;l=mid+1;
        }else r=mid-1;
    }
    return rtn;
}

int main(){
#ifdef WK
    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
#endif
    scanf(&quot;%d%d%lld&quot;,&amp;n,&amp;m,&amp;k);
    for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;A[i]);
    for(int i=1;i&lt;=m;i++)scanf(&quot;%lld&quot;,&amp;B[i]);
    sort(B+1,B+1+m);
    LL ans=solve();
    printf(&quot;%lld&quot;,ans);
    return 0;
} 
```
</code></pre>

<h2 id="h">H. 最大公约数<a class="headerlink" href="#h" title="Permanent link">Link</a></h2>
<p>求 $y$ 使得在 $[1,n]$ 中不存在 $gcd(i,k)=gcd(y,k)$</p>
<p>队友一看是个大数，因为如果 $n=500, k=1$ 显然是 $n$ 中所有的素数积</p>
<p>然后随便推一推设 $p$ 是 $n$ 中所有的素数集合，答案就是 $k \cdot \prod p$</p>
<p>??? note &ldquo;Code&rdquo;
    ```python
    T = int(input())</p>
<pre class="codehilite"><code class="linenums">def prim(x):
    for i in range(2, x):
        if (x % i == 0):
            return False
    return True


for kase in range(T):
    n, k = map(int, input().split())
    ans = k
    for i in range(2, int(n / k) + 1):
        if prim(i):
            ans *= i
    print(ans)
```
</code></pre>

<h2 id="i-k">I. K小数查询<a class="headerlink" href="#i-k" title="Permanent link">Link</a></h2>
<p>区间推平最大值 + 区间查询第 k 小</p>
<p>分块 + 二分答案复杂度可过</p>
<p>正解树套树不会写</p>
<p>另外区间推平最大值是 segment beats</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *   Copyright (C) 2019 Sangfor Ltd. All rights reserved.
    *
    *   创 建 者： badcw
    *   创建日期： 2020/1/12
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define ll long long
using namespace std;

const int maxn = 8e4+50;
const int mod = 1e9+7;
ll qp(ll a, ll n) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template &lt;class T&gt;
inline bool scan(T&amp; ret) {
    char c;
    int sgn;
    if (c = getchar(), c == EOF) return 0; // EOF
    while (c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar();
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0');
    ret *= sgn;
    return 1;
}

//template &lt;class T&gt;
//inline void out(T x) {
//    if (x &gt; 9) out(x / 10);
//    putchar(x % 10 + '0');
//}

const int maxb = 1005;
const int inf = 8e4+50;
int n, m;
int belong[maxn], lpos[maxb], rpos[maxb];
int val[maxn], lazy[maxn], op[maxb];
int block;

void rebuild(int idx) {
    for (int i = lpos[idx]; i &lt;= rpos[idx]; ++i) {
        if (val[i] &gt; op[idx]) val[i] = op[idx];
        lazy[i] = val[i];
    }
    sort(lazy + lpos[idx], lazy + rpos[idx] + 1);
//    op[idx] = inf;
}

void update(int l, int r, int w) {
    if (belong[l] == belong[r]) {
        for (int i = l; i &lt;= r; ++i) {
            if (val[i] &gt; w) val[i] = w;
        }
        rebuild(belong[l]);
        return;
    }
    for (int i = l; i &lt;= rpos[belong[l]]; ++i) {
        if (val[i] &gt; w) val[i] = w;
    }
    for (int i = belong[l] + 1; i &lt; belong[r]; ++i) {
        if (op[i] &gt; w) op[i] = w;
    }
    for (int i = lpos[belong[r]]; i &lt;= r; ++i) {
        if (val[i] &gt; w) val[i] = w;
    }
    rebuild(belong[l]), rebuild(belong[r]);
}

int sz;

void rebuild() {
    for (int i = 1; i &lt;= sz; ++i) {
        op[i] = 0;
        for (int j = lpos[i]; j &lt;= rpos[i]; ++j) {
//            if (val[j] &gt; op[i]) val[j] = op[i];
            lazy[j] = val[j];
            op[i] = max(op[i], val[j]);
        }
        sort(lazy + lpos[i], lazy + rpos[i] + 1);
//        for (int j = lpos[i]; j &lt;= rpos[i]; ++j) {
//            printf(&quot;%d &quot;, lazy[j]);
//        }
//        printf(&quot; | &quot;);
    }
//    printf(&quot;\n&quot;);
}

bool check(int x, int l, int r, int w) {
    int res = 0;
    if (op[belong[l]] &lt; x) {
        res += rpos[belong[l]] - l + 1;
    } else {
        for (int i = l; i &lt;= rpos[belong[l]]; ++i) {
            if (val[i] &lt; x) res ++;
        }
    }
    for (int i = belong[l] + 1; i &lt; belong[r]; ++i) {
        if (op[i] &lt; x) res += rpos[i] - lpos[i] + 1;
        else {
            res += lower_bound(lazy + lpos[i], lazy + rpos[i] + 1, x) - lazy - lpos[i];
        }
    }
    if (op[belong[r]] &lt; x) {
        res += r - lpos[belong[r]] + 1;
    } else {
        for (int i = lpos[belong[r]]; i &lt;= r; ++i) {
            if (val[i] &lt; x) res ++;
        }
    }
    return res &lt; w;
}

int query(int l, int r, int w) {
    if (belong[l] == belong[r]) {
        vector&lt;int&gt; tmp;
        for (int i = l; i &lt;= r; ++i) {
            if (val[i] &gt; op[belong[i]]) tmp.push_back(op[belong[i]]);
            else tmp.push_back(val[i]);
        }
        sort(tmp.begin(), tmp.end());
        return tmp[w - 1];
    }
    int L = 1, R = inf;
    int res = 0;
    while (L &lt;= R) {
        int mid = L + R &gt;&gt; 1;
        if (check(mid, l, r, w)) {
            res = mid;
            L = mid + 1;
        } else {
            R = mid - 1;
        }
    }
    return res;
}

int main(int argc, char* argv[]) {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
//    block = n;
    block = sqrt(n);
    for (int i = 1; i &lt;= n; ++i) {
        scanf(&quot;%d&quot;, &amp;val[i]);
        lazy[i] = val[i];
        belong[i] = (i - 1) / block + 1;
    }
    sz = (n - 1) / block + 1;
    for (int i = 1; i &lt;= sz; ++i) {
        lpos[i] = 1 + (i - 1) * block;
        rpos[i] = i * block;
    }
    rpos[sz] = n;
    rebuild();
    int op, l, r, x;
    for (int i = 1; i &lt;= m; ++i) {
        scanf(&quot;%d%d%d%d&quot;, &amp;op, &amp;l, &amp;r, &amp;x);
        if (op == 1) {
            update(l, r, x);
        } else {
            printf(&quot;%d\n&quot;, query(l, r, x));
        }
    }
    return 0;
}
```
</code></pre>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy;  <a href="https://wiki.badcw.cn" target="_blank">wiki.badcw.cn</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c99f48ec.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../search/main.js"></script>
      
    
  </body>
</html>