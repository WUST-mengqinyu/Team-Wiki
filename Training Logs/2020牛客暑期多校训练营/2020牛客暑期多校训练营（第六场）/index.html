
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.badcw.cn/Training%20Logs/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89/">
      
      <link rel="icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>2020牛客暑期多校训练营（第六场） - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1dff34a1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CUbuntu+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Ubuntu Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#b-binary-vector" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Team Wiki" class="md-header__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Team Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2020牛客暑期多校训练营（第六场）
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Team Wiki" class="md-nav__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          主页
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="主页" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          主页
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        赛季列表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          个人页面
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="个人页面" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          个人页面
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Verly/index.md" class="md-nav__link">
        Verly
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../badcw/" class="md-nav__link">
        badcw
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          关于
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="关于" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          关于
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../About/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#b-binary-vector" class="md-nav__link">
    B. Binary Vector
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c-combination-of-physics-and-maths" class="md-nav__link">
    C. Combination of Physics and Maths
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#e-easy-construction" class="md-nav__link">
    E. Easy Construction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#g-grid-coloring" class="md-nav__link">
    G. Grid Coloring
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#h-harmony-pairs" class="md-nav__link">
    H. Harmony Pairs
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#j-josephus-transform" class="md-nav__link">
    J. Josephus Transform
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#k-k-bag" class="md-nav__link">
    K. K-Bag
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


  <h1>2020牛客暑期多校训练营（第六场）</h1>

<table>
<thead>
<tr>
<th>Name</th>
<th>Date</th>
<th>Solved</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://ac.nowcoder.com/acm/contest/5671">2020牛客暑期多校训练营（第六场）</a></td>
<td>2020/7/27</td>
<td>5/11</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">Ø</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">Ø</td>
<td align="center">O</td>
</tr>
</tbody>
</table>
<h2 id="b-binary-vector">B. Binary Vector<a class="headerlink" href="#b-binary-vector" title="Permanent link">Link</a></h2>
<p><em>solved by: badcw 02:25:43</em></p>
<p>线性代数，求一个 n 维线性空间内，只有 01 的 n 个向量不线性相关的概率。</p>
<p>就硬找规律或者oeis，因为分母其实是可以很轻易算出来的，<span class="arithmatex"><span class="MathJax_Preview">2^{n*n}</span><script type="math/tex">2^{n*n}</script></span></p>
<div class="arithmatex">
<div class="MathJax_Preview">a_1=1,a_n=a_{n-1}*(2^{2n-1}-2^{n-1}),f_n=\frac{a_n}{2^{n*n}}</div>
<script type="math/tex; mode=display">a_1=1,a_n=a_{n-1}*(2^{2n-1}-2^{n-1}),f_n=\frac{a_n}{2^{n*n}}</script>
</div>
<p>然后处理一下递推性质优化转移即可。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/27 13:55
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 2e7+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, int mod = ::mod) {
    a %= mod;
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

ll a[maxn], f[maxn];

int main(int argc, char* argv[]) {
    a[1] = 1;
    f[1] = 500000004;
    ll q1 = 2, q2 = 8, ls = qp(16, mod - 2), q2inv = qp(q2, mod - 2), inv4 = qp(4, mod - 2);
    for (int i = 2; i &lt;= 20000000; ++i) {
        a[i] = a[i - 1] * (q2 - q1) % mod;
        if (a[i] &lt; 0) a[i] += mod;
        f[i] = a[i] * ls % mod;
        q1 = q1 * 2 % mod;
        q2 = q2 * 4 % mod;
        q2inv = q2inv * inv4 % mod;
        ls = ls * q2inv % mod;
//        if (f[i] &lt; 0 || f[i] &gt;= mod) cerr &lt;&lt; "NO" &lt;&lt; endl;
        f[i] ^= f[i - 1];
//        cerr &lt;&lt; a[i] &lt;&lt; ',';
    }
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        int n;
        R(n);
        W(f[n]);
    }
    return 0;
}</code></pre>
</details>
<h2 id="c-combination-of-physics-and-maths">C. Combination of Physics and Maths<a class="headerlink" href="#c-combination-of-physics-and-maths" title="Permanent link">Link</a></h2>
<p><em>solved by: badcw 00:36:04(-1)</em></p>
<p>找一个可分割取的子矩阵，求子矩阵和与子矩阵最下面一行的和的比值最大值。</p>
<p>非常轻易的就知道 <span class="arithmatex"><span class="MathJax_Preview">\frac{a}{b}+\frac{c}{d} \le max(\frac{a}{b},\frac{c}{d})</span><script type="math/tex">\frac{a}{b}+\frac{c}{d} \le max(\frac{a}{b},\frac{c}{d})</script></span></p>
<p>然后就只取一列，然后每列只要取完上面所有数即可，前缀和一下就做完了。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/27 12:32
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 205;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n, m;
int mp[maxn][maxn];

int main(int argc, char* argv[]) {
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        R(n, m);
        double res = 0;
        for (int i = 1; i &lt;= n; ++i) {
            for (int j = 1; j &lt;= m; ++j) {
                int tmp;
                R(tmp);
                mp[i][j] = tmp + mp[i - 1][j];
                res = max(res, (double)mp[i][j] / tmp);
            }
        }
        W(res);
    }
    return 0;
}</code></pre>
</details>
<h2 id="e-easy-construction">E. Easy Construction<a class="headerlink" href="#e-easy-construction" title="Permanent link">Link</a></h2>
<p><em>solved by: badcw 00:26:22</em></p>
<p>构造一个 n 的 permutation，使得对于 1~n 的所有 i 都满足有一个长度为 i 的子串的和模 n 为 x，x 是读入的。</p>
<p>那么显然首先 x 是一个定值： <span class="arithmatex"><span class="MathJax_Preview">(1+n)*n/2 %n</span><script type="math/tex">(1+n)*n/2 %n</script></span>，因为长度为 n 的模 n 就是它，那么如果 x 和它不等就无解。</p>
<p>很轻易的发现可以分奇偶构造，因为奇数显然是 <span class="arithmatex"><span class="MathJax_Preview">(1+n)/2</span><script type="math/tex">(1+n)/2</script></span>，偶数则为 0</p>
<p>那么考虑把 n 放在最后一位即可，再把成对和为 n 的往前丢即可。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/27 12:15
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 10;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n, k;

int main(int argc, char* argv[]) {
    R(n, k);
    if (n % 2) {
        if (k != 0) W(-1);
        else {
            VI res(n + 1);
            for (int i = 1; i &lt;= n; i += 2) res[i] = i;
            for (int i = 2; i &lt;= n; i += 2) res[i] = n - i + 1;
            for (int i = 1; i &lt;= n; ++i) printf("%d%c", res[i], i == n ? '\n' : ' ');
        }
    } else {
        if (k != n / 2) W(-1);
        else {
            VI res(n + 1);
            int pos = 1;
            for (int i = 1; i &lt; n; i += 2) res[i] = pos ++;
            for (int i = n - 2; i &gt;= 2; i -= 2) res[i] = pos ++;
            res[n] = pos ++;
            for (int i = 1; i &lt;= n; ++i) printf("%d%c", res[i], i == n ? '\n' : ' ');
        }
    }
    return 0;
}</code></pre>
</details>
<h2 id="g-grid-coloring">G. Grid Coloring<a class="headerlink" href="#g-grid-coloring" title="Permanent link">Link</a></h2>
<p><em>upsolved by: Verly</em></p>
<p>题意：给n×n的网格边染k种颜色，要求每行/每列颜色不能完全相同，每个小方格的四条边颜色不能完全相同，求一种合法方案。</p>
<p><code>n=1</code>或<code>k=1</code>或<code>n*(n-1)*2%k!=0</code>无解，否则如果<code>n%k!=0</code>就按顺序123456……123456……放，如果<code>n%k==0</code>在每次换行的时候+1就行。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

int x;

void print(int n, int k)
{
    for(int i = 1; i &lt;= n + 1; i ++)
    {
        for(int j = 1; j &lt;= n; j ++, x = (x + 1) % k)
            printf("%d%c", x + 1, " \n"[j == n]);
        if(n % k == 0) x = (x + 1) % k;
    }
}

int main()
{
    int t;
    scanf("%d", &amp;t);
    while(t --)
    {
        int n, k;
        scanf("%d%d", &amp;n, &amp;k);
        if((n * (n + 1) * 2 % k) || n == 1 || k == 1) { puts("-1"); continue; }
        x = 0;
        print(n, k); print(n, k);
    }
    return 0;
}</code></pre>
</details>
<h2 id="h-harmony-pairs">H. Harmony Pairs<a class="headerlink" href="#h-harmony-pairs" title="Permanent link">Link</a></h2>
<p><em>solved by: badcw 03:33:55(-1)</em></p>
<p>求 1~n 中满足 <span class="arithmatex"><span class="MathJax_Preview">1 \le x \le y \le n</span><script type="math/tex">1 \le x \le y \le n</script></span> 且 <span class="arithmatex"><span class="MathJax_Preview">sum(y) \lt sum(x)</span><script type="math/tex">sum(y) \lt sum(x)</script></span> 的数量。</p>
<p>其中 sum 表示数位和。</p>
<p>就裸的数位 dp 做差即可。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">dp_{i,j,[0/1],[0/1],[0/1]}</span><script type="math/tex">dp_{i,j,[0/1],[0/1],[0/1]}</script></span> 表示前 i 位，x 与 y 的数位差为 j（往右偏移一个 <code>100*9</code> 即可），x 是否达到 n 上界，y 是否达到 n 上界，x 是否已经小于 y 了（因为大的位如果小于 y 就说明后面可以随便排了）的方案数。</p>
<p>然后就做完了。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/27 12:41
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }


char n[101];
int dp[101][2000][2][2][2];

int dfs(int pos, int lim1, int lim2, int cal, int flag) {
    if (pos &lt; 0) return cal &gt; 1000;
    if (dp[pos][cal][lim1][lim2][flag] != -1) return dp[pos][cal][lim1][lim2][flag];
    int up1 = lim1 ? n[pos] - '0': 9;
    int up2 = lim2 ? n[pos] - '0': 9;
    int res = 0;
    for (int i = 0; i &lt;= up1; ++i) {
        for (int j = 0; j &lt;= up2; ++j) {
            if (!flag &amp;&amp; i &gt; j) continue;
            res += dfs(pos - 1, lim1 &amp;&amp; i == n[pos] - '0', lim2 &amp;&amp; j == n[pos] - '0', cal + i - j, flag || (i &lt; j));
            if (res &gt;= mod) res -= mod;
        }
    }
    dp[pos][cal][lim1][lim2][flag] = res;
    return res;
}

int main(int argc, char* argv[]) {
    R(n);
    int len = strlen(n);
    reverse(n, n + len);
    memset(dp, -1, sizeof dp);
    W(dfs(len - 1, 1, 1, 1000, 0));
    return 0;
}</code></pre>
</details>
<h2 id="j-josephus-transform">J. Josephus Transform<a class="headerlink" href="#j-josephus-transform" title="Permanent link">Link</a></h2>
<p><em>upsolved by: ffacs</em></p>
<p>题意：定义一个排列经过<span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>约瑟夫变换后得到的序列为 从第一个位置开始向后每 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 个元素出队一个，形成的新序列。<span class="arithmatex"><span class="MathJax_Preview">A*(k,x)</span><script type="math/tex">A*(k,x)</script></span> 变换为 排列 <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> 经过 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 次 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>约瑟夫变换得到的序列。求<span class="arithmatex"><span class="MathJax_Preview">A*(k_1,x_1)*(k_2,x_2)*...(k_m,x_m)</span><script type="math/tex">A*(k_1,x_1)*(k_2,x_2)*...(k_m,x_m)</script></span> 。其中<span class="arithmatex"><span class="MathJax_Preview">1\le n,m\le 1e5,1\le n \times m \le 1e6,1\le k\le n,1\le x\le 1e9</span><script type="math/tex">1\le n,m\le 1e5,1\le n \times m \le 1e6,1\le k\le n,1\le x\le 1e9</script></span></p>
<p>约瑟夫变换本质上可以看成是一个置换，即将某一位元素移到第一位，某一位元素移到第二位....那么我们求出 <span class="arithmatex"><span class="MathJax_Preview">1...n</span><script type="math/tex">1...n</script></span> 的 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>约瑟夫序列就能知道这个置换的移动方式。知道这个置换移动方式之后就可以用快速幂或者倍增 <span class="arithmatex"><span class="MathJax_Preview">O(n\log x)</span><script type="math/tex">O(n\log x)</script></span> 求出这个置换的 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 次方的移动方式。作用到之前的序列上即可完成 <span class="arithmatex"><span class="MathJax_Preview">(k,x)</span><script type="math/tex">(k,x)</script></span>。求约瑟夫序列可以 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span>，倍增是 <span class="arithmatex"><span class="MathJax_Preview">O(n\log x)</span><script type="math/tex">O(n\log x)</script></span> ，总共 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> 次，总时间复杂度就是 <span class="arithmatex"><span class="MathJax_Preview">nm\log x</span><script type="math/tex">nm\log x</script></span>。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef long long ll;
int p[maxn];
int nex[maxn][31];
int ans[maxn],temp[maxn];
int siz[maxn];
int tree[maxn&lt;&lt;2];
inline void push_up(int p) {tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];}
void build(int l,int r,int p) {
    if(l==r) {tree[p]=1;return;}
    int mid=l+r&gt;&gt;1;
    build(l,mid,p&lt;&lt;1);build(mid+1,r,p&lt;&lt;1|1);
    push_up(p);
}
int update(int k,int nl,int nr,int p) {
    if(nl==nr) {tree[p]=0;return nl;}
    int mid=nl+nr&gt;&gt;1,ans;
    if(tree[p&lt;&lt;1]&gt;=k) ans=update(k,nl,mid,p&lt;&lt;1);
    else ans=update(k-tree[p&lt;&lt;1],mid+1,nr,p&lt;&lt;1|1);
    push_up(p);return ans;
}
inline void seq(int n,int k) {
    build(1,n,1);
    int now=1;
    for(int i=1;i&lt;=n;i++) {
        now=(now+k-2)%(n-i+1)+1;
        p[i]=update(now,1,n,1);
    }
}
int main() {

    cin.tie(0);cout.tie(0);
    ios::sync_with_stdio(false);
    int n,T;cin&gt;&gt;n&gt;&gt;T;
    for(int i=1;i&lt;=n;i++) ans[i]=i;
    while(T--) {
        int k,x;cin&gt;&gt;k&gt;&gt;x;
        seq(n,k);
        for(int i=1;i&lt;=n;i++) nex[i][0]=siz[i]=0,temp[i]=ans[i];
        for(int i=1;i&lt;=n;i++) {
            if(!nex[i][0]) {
                int sz=0;
                for(int j=i;!nex[p[j]][0];j=p[j]) nex[p[j]][0]=j,sz++;
                for(int j=i;!siz[j];j=nex[j][0]) siz[j]=sz;
            }
        }
        for(int i=1;i&lt;=17;i++) for(int j=1;j&lt;=n;j++)
            nex[j][i]=nex[nex[j][i-1]][i-1];
        for(int j=1;j&lt;=n;j++) {
            int now=j,tem=x,xx=0;
            tem%=siz[j];
            while(tem) {
                if(tem&amp;1) now=nex[now][xx];
                tem&gt;&gt;=1;xx++;
            }
            ans[now]=temp[j];
        }

    }
    for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]);
    return 0;
}</code></pre>
</details>
<h2 id="k-k-bag">K. K-Bag<a class="headerlink" href="#k-k-bag" title="Permanent link">Link</a></h2>
<p><em>solved by: badcw 02:59:42(-1)</em></p>
<p>k-bag 序列表示一个长度为 k 的倍数且 <code>(1~k),(k+1~2*k)...(n-k+1,k)</code> 这些段都是 1~k 的某种排列的序列。</p>
<p>现在输入一个长度为 n 的序列问是否是 k-bag 的子串。<span class="arithmatex"><span class="MathJax_Preview">n \le 5e5, k \le 1e9</span><script type="math/tex">n \le 5e5, k \le 1e9</script></span></p>
<p>显然，我们可以枚举 <span class="arithmatex"><span class="MathJax_Preview">1~i</span><script type="math/tex">1~i</script></span> 是否是一个不完整的排列，然后后面就可以按 k 的倍数计算是否是一个排列即可，最后一段也要判断是否为 k 的不完整排列。</p>
<p>复杂度 <span class="arithmatex"><span class="MathJax_Preview">O(min(n,k)*n/k)</span><script type="math/tex">O(min(n,k)*n/k)</script></span>。</p>
<p>那么如何 O1 判断一段是否为 k 的排列或者 k 的不完整排列呢，像莫队一样直接记录每个点是否都只有一个数即可。</p>
<p>预处理复杂度 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>。</p>
<p>再加上优美的离散化方式即可通过，因为 k 有可能很大无法用数组保存，但是 <span class="arithmatex"><span class="MathJax_Preview">k \le n</span><script type="math/tex">k \le n</script></span> 时不需要离散化。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/27 14:32
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 5e5+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n, k;
int a[maxn], f[maxn], flag[maxn], flag2[maxn];
int mp[maxn];
int cnt = 0, flagnow = 0;

inline void add(int x) {
    if (++mp[x] == 1) cnt ++;
    else if (mp[x] == 2) { flagnow ++; }
}
inline void del(int x) {
    if (--mp[x] == 0) cnt --;
    else if (mp[x] == 1) { flagnow --; }
}

inline int read() {
    int x = 0;
    char ch = getchar();
    while (ch &gt; '9' || ch &lt; '0')ch = getchar();
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x;
}

int main(int argc, char* argv[]) {
    int T = read();
    for (int kase = 1; kase &lt;= T; ++kase) {
        n = read(), k = read();
        int fls = 1;
        for (int i = 1; i &lt;= n; ++i) {
            a[i] = read();
            if (a[i] &gt; k) {
                fls = 0;
            }
        }
        if (fls == 0) {
            W("NO");
            continue;
        }
        if (k &gt;= 500000) {
            vector&lt;int&gt; xpos(a + 1, a + 1 + n);
            sort(xpos.begin(), xpos.end());
            xpos.erase(unique(xpos.begin(), xpos.end()), xpos.end());
            for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(xpos.begin(), xpos.end(), a[i]) - xpos.begin() + 1;
            k = xpos.size() + 1;
        }
        for (int i = k; i &gt;= 1; --i) mp[i] = 0;
        cnt = flagnow = 0;
        for (int i = 1; i &lt;= n; ++i) {
            add(a[i]);
            if (i &gt; k) del(a[i - k]);
            f[i] = cnt;
            flag[i] = flagnow;
        }
        for (int i = k; i &gt;= 1; --i) mp[i] = 0;
        cnt = flagnow = 0;
        for (int i = n; i &gt;= 1; --i) {
            add(a[i]);
            if (i + k &lt;= n) del(a[i + k]);
            flag2[i] = flagnow;
        }
        int res = 0;
        for (int i = 0; i &lt; n; ++i) {
            if (flag[i] &gt; 0) break;
            int j = i + k;
            int tmp = 1;
            for (; j &lt;= n; j += k) {
                if (f[j] != k) {
                    tmp = 0;
                    break;
                }
            }
            if (j - k + 1 &lt;= n &amp;&amp; flag2[j - k + 1] &gt; 0) tmp = 0;
            if (tmp == 1) {
                res = 1;
                break;
            }
        }
        puts(res ? "YES" : "NO");
    }
    return 0;
}</code></pre>
</details>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy;  <a href="https://wiki.badcw.cn" target="_blank">wiki.badcw.cn</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c99f48ec.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../../../search/main.js"></script>
      
    
  </body>
</html>