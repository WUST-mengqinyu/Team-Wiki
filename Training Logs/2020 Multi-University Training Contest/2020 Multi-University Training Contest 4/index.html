
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.badcw.cn/Training%20Logs/2020%20Multi-University%20Training%20Contest/2020%20Multi-University%20Training%20Contest%204/">
      
      <link rel="icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>2020 Multi University Training Contest 4 - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1dff34a1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CUbuntu+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Ubuntu Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#b-blow-up-the-enemy" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Team Wiki" class="md-header__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Team Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2020 Multi University Training Contest 4
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Team Wiki" class="md-nav__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          主页
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="主页" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          主页
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        赛季列表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          个人页面
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="个人页面" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          个人页面
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Verly/index.md" class="md-nav__link">
        Verly
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../badcw/" class="md-nav__link">
        badcw
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          关于
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="关于" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          关于
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../About/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#b-blow-up-the-enemy" class="md-nav__link">
    B. Blow up the Enemy
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c-contest-of-rope-pulling" class="md-nav__link">
    C. Contest of Rope Pulling
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#d-deliver-the-cake" class="md-nav__link">
    D. Deliver the Cake
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#e-equal-sentences" class="md-nav__link">
    E. Equal Sentences
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#g-go-running" class="md-nav__link">
    G. Go Running
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#k-kindergarten-physics" class="md-nav__link">
    K. Kindergarten Physics
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#l-last-problem" class="md-nav__link">
    L. Last Problem
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


  <h1>2020 Multi University Training Contest 4</h1>

<table>
<thead>
<tr>
<th>Name</th>
<th>Date</th>
<th>Solved</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
<th align="center">L</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2020+Multi-University+Training+Contest+4&amp;source=1&amp;searchmode=source">2020 Multi-University Training Contest 4</a></td>
<td>2020/7/30</td>
<td>7/12</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">.</td>
</tr>
</tbody>
</table>
<h2 id="b-blow-up-the-enemy">B. Blow up the Enemy<a class="headerlink" href="#b-blow-up-the-enemy" title="Permanent link">Link</a></h2>
<p>选择一个武器，轮流打，问一方随机选另一方选最优的获胜概率，直接模拟一下最大 0，1，0.5 取一下平均数。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/30 12:48
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 1e3+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

ll a[maxn], d[maxn];
ll t[maxn];

int main(int argc, char* argv[]) {
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        int n;
        R(n);
        ll mn = 1e18;
        for (int i = 1; i &lt;= n; ++i) {
            R(a[i], d[i]);
            ll tim = (100 / a[i] + (100 % a[i] ? 1 : 0));
            t[i] = d[i] * (tim - 1);
            mn = min(mn, t[i]);
        }
        ll tmp = 0;
        for (int i = 1; i &lt;= n; ++i) {
            if (mn == t[i]) {
                tmp ++;
            }
        }
        W(1 - tmp * 0.5 / n);
    }
    return 0;
}</code></pre>
</details>
<h2 id="c-contest-of-rope-pulling">C. Contest of Rope Pulling<a class="headerlink" href="#c-contest-of-rope-pulling" title="Permanent link">Link</a></h2>
<p>一堆里面 n 个物品，每个有大小 x 和价值 w，令一堆有 m 个也有这两个属性。</p>
<p>问在一堆中挑选出大小和二堆中完全一样的最大价值和。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">n,m \le 1000~x \le 1000~-1e9\le w \le 1e9</span><script type="math/tex">n,m \le 1000~x \le 1000~-1e9\le w \le 1e9</script></span></p>
<p>显然是一个背包性质的问题不可能存在线性或者优化的做法。将 m 个物品的大小弄成负数加到 n 堆里去，然后最后就是容量为 0 的最大值，随机物品顺序之后确定一个阈值 k，考虑到全 1000 导致值域达到 1e6 级别的概率太小。</p>
<p>阈值取到 80000 就可以通过此题。</p>
<p>复杂度 <span class="arithmatex"><span class="MathJax_Preview">O((n+m)*k)</span><script type="math/tex">O((n+m)*k)</script></span></p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/31 12:31
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 1e3+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n, m;

struct node {
    int w, v;
    int flag;
};

const int lim = 80000;
ll dp[lim * 2 + 5];
//map&lt;int, ll&gt; dp;

int main(int argc, char* argv[]) {
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        R(n, m);
        vector&lt;node&gt; a(n + m);
        for (int i = 0; i &lt; n; ++i) R(a[i].w, a[i].v), a[i].flag = 1;
        for (int i = 0; i &lt; m; ++i) R(a[i + n].w, a[i + n].v), a[i + n].flag = -1;
        n += m;
        int tt = 1;
        ll res = 0;
        while (tt--) {
            random_shuffle(a.begin(), a.end());
//            for (auto i : a) {
//                cerr &lt;&lt; i.v &lt;&lt; " " &lt;&lt; i.w &lt;&lt; " " &lt;&lt; i.flag &lt;&lt; endl;
//            }
//            cerr &lt;&lt; "*\n";
//            dp.clear();
            for (int i = -lim; i &lt;= lim; ++i) dp[i + lim] = -1e18;
            dp[lim] = 0;
            for (int i = 0; i &lt; n; ++i) {
                if (a[i].flag &gt; 0) {
                    for (int j = lim; j &gt;= -lim + a[i].w; --j) {
                        if (dp[j - a[i].w + lim] != -1e18) dp[j + lim] = max(dp[j + lim], dp[j - a[i].w + lim] + a[i].v);
                    }
                } else {
                    for (int j = -lim; j &lt;= lim - a[i].w; ++j) {
                        if (dp[j + a[i].w + lim] != -1e18) dp[j + lim] = max(dp[j + lim], dp[j + a[i].w + lim] + a[i].v);
                    }
                }
            }
            res = max(res, dp[lim]);
        }
        W(res);
    }
    return 0;
}</code></pre>
</details>
<h2 id="d-deliver-the-cake">D. Deliver the Cake<a class="headerlink" href="#d-deliver-the-cake" title="Permanent link">Link</a></h2>
<p>一张图，求 1~n 的最短路，每个点有左右手限制，如果在当前位置是左手，下一个节点是右手限制需要额外 x 的时间。有的点没有限制。</p>
<p>对限制左右手的点当作一个点看，而不限制的拆为用左手和用右手两个点相连权为 x，然后建图跑最短路即可。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/8/8 0:05
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 2e5+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, int mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n, m, x, tot;
char S[maxn];
int pos[2][maxn];

vector&lt;pair&lt;int, ll&gt; &gt; edge[maxn];
ll dist[maxn];
const ll inf = 0x3f3f3f3f3f3f3f3f;

ll dij(int s, int t) {
    priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt; &gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt; qu;
    for (int i = 0; i &lt;= tot; ++i) dist[i] = inf;
    dist[s] = 0;
    qu.push({0, s});
    while (!qu.empty()) {
        auto f = qu.top(); qu.pop();
        int u = f.second; ll d = f.first;
        if (d != dist[u]) continue;
        for (auto it : edge[u]) {
            int v = it.first, w = it.second;
            if (dist[u] + w &lt; dist[v]) {
                dist[v] = dist[u] + w;
                qu.push({dist[v], v});
            }
        }
    }
    return min(dist[pos[0][t]], dist[pos[1][t]]);
}

int main(int argc, char* argv[]) {
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        int s, t;
        R(n, m, s, t, x);
        scanf("%s", S + 1);
        tot = 0;
        for (int i = 1; i &lt;= n; ++i) {
            if (S[i] == 'L') pos[0][i] = ++tot, pos[1][i] = 0;
            else if (S[i] == 'R') pos[1][i] = ++tot, pos[0][i] = 0;
            else pos[0][i] = ++tot, pos[1][i] = ++tot;
        }
        for (int i = 1; i &lt;= tot + 1; ++i) edge[i].clear();
        for (int i = 1; i &lt;= m; ++i) {
            int u, v, w;
            R(u, v, w);
            for (int j = 0; j &lt; 2; ++j) {
                if (pos[j][u] == 0) continue;
                for (int k = 0; k &lt; 2; ++k) {
                    if (pos[k][v] == 0) continue;
                    edge[pos[j][u]].emplace_back(pos[k][v], w + x * (j != k));
                    edge[pos[k][v]].emplace_back(pos[j][u], w + x * (j != k));
//                    cerr &lt;&lt; pos[j][u] &lt;&lt; " " &lt;&lt; pos[k][v] &lt;&lt; " " &lt;&lt; w + x * (j != k) &lt;&lt; endl;
                }
            }
        }
        int Sx = ++tot;
        if (pos[0][s]) edge[Sx].emplace_back(pos[0][s], 0);
        if (pos[1][s]) edge[Sx].emplace_back(pos[1][s], 0);
        W(dij(Sx, t));
    }
    return 0;
}</code></pre>
</details>
<h2 id="e-equal-sentences">E. Equal Sentences<a class="headerlink" href="#e-equal-sentences" title="Permanent link">Link</a></h2>
<p>给一个句子，求将他中的每个单词最多移动 1 的位置的本质不同串个数。</p>
<p>显然 dp 就完事了，<span class="arithmatex"><span class="MathJax_Preview">dp_{i,0/1}</span><script type="math/tex">dp_{i,0/1}</script></span> 表示第 i 个位置是否移动的方案数。遇到相同单词只能转移 0 的方案数即可。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/30 12:58
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 1e5+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n;
string s[maxn];
ll dp[maxn][2];

int main(int argc, char* argv[]) {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int T;
    cin &gt;&gt; T;
    for (int kase = 1; kase &lt;= T; ++kase) {
        cin &gt;&gt; n;
        for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; s[i];
        dp[1][0] = 1;
        dp[1][1] = 0;
        for (int i = 2; i &lt;= n; ++i) {
            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % mod;
            dp[i][1] = dp[i - 1][0] * (s[i] != s[i - 1]);
        }
        cout &lt;&lt; (dp[n][0] + dp[n][1]) % mod &lt;&lt; '\n';
    }
    return 0;
}</code></pre>
</details>
<h2 id="g-go-running">G. Go Running<a class="headerlink" href="#g-go-running" title="Permanent link">Link</a></h2>
<p>有若干个速度为 1 在数轴上移动的点，它可能出现或者消失在任何时候，给一些出现事件对 <span class="arithmatex"><span class="MathJax_Preview">(t,x)</span><script type="math/tex">(t,x)</script></span> 表示 t 时刻在 x 点有点。求最少有多少个不同的点。</p>
<p>显然的一点是如果考虑全部是往右的点，<span class="arithmatex"><span class="MathJax_Preview">t-x</span><script type="math/tex">t-x</script></span> 相等的点是可以合并的，往左则是 <span class="arithmatex"><span class="MathJax_Preview">t+x</span><script type="math/tex">t+x</script></span> 相等可以合并。</p>
<p>那么问题转换为在二维坐标上，取多少个斜率为 1 或 -1 的直线能把全部点覆盖。</p>
<p>考虑对一个点 <span class="arithmatex"><span class="MathJax_Preview">t-x</span><script type="math/tex">t-x</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">t+x</span><script type="math/tex">t+x</script></span> 建二分图连边（注意就算某个 <span class="arithmatex"><span class="MathJax_Preview">t-x</span><script type="math/tex">t-x</script></span> 若与某个 <span class="arithmatex"><span class="MathJax_Preview">t+x</span><script type="math/tex">t+x</script></span> 相同它们也是两个不同点），问题转换为最小点覆盖即可用 Dinic 或者 Hopcroft二分图匹配算法 以 <span class="arithmatex"><span class="MathJax_Preview">O(n\sqrt(m))</span><script type="math/tex">O(n\sqrt(m))</script></span> 复杂度通过。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/8/8 0:41
*
================================================================*/
#include &lt;bits/stdc++.h&gt;
#define VI vector&lt;int&gt;
#define ll long long
using namespace std;
const int maxn = 1e5+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, int mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}
namespace IO {
    template&lt;class T&gt;
    void _R(T &amp;x) { cin &gt;&gt; x; }
    void _R(int &amp;x) { scanf("%d", &amp;x); }
    void _R(ll &amp;x) { scanf("%lld", &amp;x); }
    void _R(double &amp;x) { scanf("%lf", &amp;x); }
    void _R(char &amp;x) { x = getchar(); }
    void _R(char *x) { scanf("%s", x); }
    void R() {}
    template&lt;class T, class... U&gt;
    void R(T &amp;head, U &amp;... tail) {_R(head),R(tail...);}
    template&lt;class T&gt;
    void _W(const T &amp;x) { cout &lt;&lt; x; }
    void _W(const int &amp;x) { printf("%d", x); }
    void _W(const ll &amp;x) { printf("%lld", x); }
    void _W(const double &amp;x) { printf("%.16f", x); }
    void _W(const char &amp;x) { putchar(x); }
    void _W(const char *x) { printf("%s", x); }
    template&lt;class T, class U&gt;
    void _W(const pair&lt;T, U&gt; &amp;x) {_W(x.F),putchar(' '),_W(x.S);}
    template&lt;class T&gt;
    void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
    void W() {}
    template&lt;class T, class... U&gt;
    void W(const T &amp;head, const U &amp;... tail) {_W(head),putchar(sizeof...(tail) ? ' ' : '\n'),W(tail...);}
}
using namespace IO;
//复杂度O(n^0.5*m)
struct Hopcroft {
#define maxn 100005
#define maxm 100005
#define INF 0x3f3f3f3f
    struct Edge { int v, next; } edge[maxm];
    int nx, cnt, dis;
    int first[maxn];
    int xlink[maxn], ylink[maxn];
    int dx[maxn], dy[maxn];
    int vis[maxn];
    void init(int n) {
        cnt = 0;
        for (int i = 0; i &lt;= n; ++i) first[i] = ylink[i] = xlink[i] = -1;
        nx = n + 1;
    }
    void add_edge(int u, int v) {
        edge[cnt].v = v, edge[cnt].next = first[u], first[u] = cnt++;
    }
    int bfs() {
        queue&lt;int&gt; q;
        dis = INF;
        for (int i = 0; i &lt; nx; ++i) dx[i] = dy[i] = -1;
        for (int i = 0; i &lt; nx; i++) {
            if (xlink[i] == -1) {
                q.push(i);
                dx[i] = 0;
            }
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            if (dx[u] &gt; dis) break;
            for (int e = first[u]; e != -1; e = edge[e].next) {
                int v = edge[e].v;
                if (dy[v] == -1) {
                    dy[v] = dx[u] + 1;
                    if (ylink[v] == -1) dis = dy[v];
                    else {
                        dx[ylink[v]] = dy[v] + 1;
                        q.push(ylink[v]);
                    }
                }
            }
        }
        return dis != INF;
    }
    int find(int u) {
        for (int e = first[u]; e != -1; e = edge[e].next) {
            int v = edge[e].v;
            if (!vis[v] &amp;&amp; dy[v] == dx[u] + 1) {
                vis[v] = 1;
                if (ylink[v] != -1 &amp;&amp; dy[v] == dis) continue;
                if (ylink[v] == -1 || find(ylink[v])) {
                    xlink[u] = v, ylink[v] = u;
                    return 1;
                }
            }
        }
        return 0;
    }
    int MaxMatch() {
        int ans = 0;
        for (int i = 0; i &lt; nx; ++i) vis[i] = 0;
        while (bfs()) {
            for (int i = 0; i &lt; nx; ++i) vis[i] = 0;
            for (int i = 0; i &lt; nx; i++)
                if (xlink[i] == -1)
                    ans += find(i);
        }
        return ans;
    }
#undef maxn
#undef maxm
} solve;
int t[maxn], x[maxn], n;
vector&lt;int&gt; xpos, ypos;
int main(int argc, char *argv[]) {
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        R(n);
        xpos.clear(), ypos.clear();
        for (int i = 1; i &lt;= n; ++i) {
            R(t[i], x[i]);
            xpos.push_back(t[i] + x[i]);
            ypos.push_back(t[i] - x[i]);
        }
        sort(xpos.begin(), xpos.end());
        sort(ypos.begin(), ypos.end());
        xpos.erase(unique(xpos.begin(), xpos.end()), xpos.end());
        ypos.erase(unique(ypos.begin(), ypos.end()), ypos.end());
        solve.init(max(xpos.size(), ypos.size()));
        for (int i = 1; i &lt;= n; ++i) {
            int pos = lower_bound(xpos.begin(), xpos.end(), t[i] + x[i]) - xpos.begin();
            int pos2 = lower_bound(ypos.begin(), ypos.end(), t[i] - x[i]) - ypos.begin();
            solve.add_edge(pos, pos2);
        }
        W(solve.MaxMatch());
    }
    return 0;
}</code></pre>
</details>
<h2 id="k-kindergarten-physics">K. Kindergarten Physics<a class="headerlink" href="#k-kindergarten-physics" title="Permanent link">Link</a></h2>
<p>求天体 t 时间内运动距离，发现不会超过 spj 的最小值直接输出原答案即可。</p>
<h2 id="l-last-problem">L. Last Problem<a class="headerlink" href="#l-last-problem" title="Permanent link">Link</a></h2>
<p>二维点填数构造，如果要在一个点填 x 需要它的上下左右四个方向存在 x-4~x-1，略过 x-4~x-1 中的非正数。求构造出一个 n 的方案。</p>
<pre class="highlight"><code>020      030     050   040  060
314      425     647   536  758
050      060     080   070  090</code></pre>
<p>懂得都懂，不懂就不懂</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/31 18:00
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 105;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n;

int xc[] = {-1, 0, 0, 1};
int yc[] = {0, 1, -1, 0};
map&lt;pair&lt;int, int&gt;, int&gt; mp;

void deal(int x, int y, int dep) {
    if (mp[make_pair(x, y)] == dep) return;
    for (int i = 0; i &lt; 4; ++i) {
        if (dep - 4 + i &lt;= 0) continue;
        deal(x + xc[i], y + yc[i], dep - 4 + i);
    }
    mp[make_pair(x, y)] = dep;
    W(x, y, dep);
}

int main(int argc, char* argv[]) {
    R(n);
    deal(0, 0, n);
    return 0;
}</code></pre>
</details>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy;  <a href="https://wiki.badcw.cn" target="_blank">wiki.badcw.cn</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c99f48ec.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../../../search/main.js"></script>
      
    
  </body>
</html>