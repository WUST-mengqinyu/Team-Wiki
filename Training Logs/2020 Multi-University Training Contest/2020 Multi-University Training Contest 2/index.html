
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.badcw.cn/Training%20Logs/2020%20Multi-University%20Training%20Contest/2020%20Multi-University%20Training%20Contest%202/">
      
      <link rel="icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>2020 Multi University Training Contest 2 - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1dff34a1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CUbuntu+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Ubuntu Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#a-total-eclipse" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Team Wiki" class="md-header__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Team Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2020 Multi University Training Contest 2
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Team Wiki" class="md-nav__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          主页
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="主页" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          主页
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        赛季列表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          个人页面
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="个人页面" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          个人页面
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Personal%20Page/Verly/" class="md-nav__link">
        Verly
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Personal%20Page/badcw/" class="md-nav__link">
        badcw
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          关于
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="关于" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          关于
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../About/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#a-total-eclipse" class="md-nav__link">
    A. Total Eclipse
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#e-new-equipments" class="md-nav__link">
    E. New Equipments
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#f-the-oculus" class="md-nav__link">
    F. The Oculus
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#g-in-search-of-gold" class="md-nav__link">
    G. In Search of Gold
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#i-its-all-squares" class="md-nav__link">
    I. It's All Squares
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#j-lead-of-wisdom" class="md-nav__link">
    J. Lead of Wisdom
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#l-string-distance" class="md-nav__link">
    L. String Distance
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


  <h1>2020 Multi University Training Contest 2</h1>

<table>
<thead>
<tr>
<th>Name</th>
<th>Date</th>
<th>Solved</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
<th align="center">L</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2020+Multi-University+Training+Contest+2&amp;source=1&amp;searchmode=source">2020 Multi-University Training Contest 2</a></td>
<td>2020/7/23</td>
<td>7/12</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">Ø</td>
<td align="center">.</td>
<td align="center">Ø</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">O</td>
</tr>
</tbody>
</table>
<h2 id="a-total-eclipse">A. Total Eclipse<a class="headerlink" href="#a-total-eclipse" title="Permanent link">Link</a></h2>
<p>给一张图，有点权，每次取一个最大的生成子图将这些点的权-1，如果减到0就不能选他了，然后求最少步数，是一个假题原先并没有说要取最大的点数。</p>
<p>可以逆着做并查集，最大权的肯定是用更多的次数，为根节点，然后不断连边即可。</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">using namespace std;
typedef long long ll;

const int maxn = 1e5 + 10;

vector&lt;int&gt; edge[maxn];
int b[maxn], c[maxn];
bool vis[maxn];

bool cmp(int i, int j) { return b[i] &gt; b[j]; }
int pre[maxn];

int Find(int x) { return x == pre[x] ? x : pre[x] = Find(pre[x]); }

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --)
    {
        int n, m;
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
        for(int i = 1; i &lt;= n; i ++) edge[i].clear();
        for(int i = 1; i &lt;= n; i ++) vis[i] = false;
        for(int i = 1; i &lt;= n; i ++) pre[i] = i;
        for(int i = 1; i &lt;= m; i ++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            edge[u].push_back(v);
            edge[v].push_back(u);
        }
        int tot = 0;
        for(int i = 1; i &lt;= n; i ++) c[i] = i;
        c[n + 1] = 0;
        sort(c + 1, c + n + 1, cmp);
        ll res = 0;
        for(int i = 1; i &lt;= n; i ++)
        {
            int u = c[i];
            int root = -1;
            for(auto v : edge[u])
            {
                int fv = Find(v);
                if(vis[fv]) 
                {
                    if(root == -1) root = fv;
                    else 
                    {
                        if(root != fv)
                        {
                            pre[fv] = root;
                            tot --;
                        }
                    }
                }
            }
            vis[u] = true;
            if(root == -1) 
            {
                tot ++;
            }
            if(root != -1) pre[u] = root;

            int now = b[c[i]] - b[c[i + 1]];
            res += 1ll * now * tot;
        }
        printf(&quot;%lld\n&quot;, res);
    }
    return 0;
}
```
</code></pre>

<h2 id="e-new-equipments">E. New Equipments<a class="headerlink" href="#e-new-equipments" title="Permanent link">Link</a></h2>
<p>n 个人，每个人有a，b，c属性，有无限个装备，求其中k个人拿一种装备j，获得的最小 <span class="arithmatex">\(\sum a_i*j^2+b_i*j+c_i\)</span>。要求 k=1~n 的所有答案。</p>
<p>直接预处理每个人对称轴左右 50 个点，一共点数 50*50+50=2550，在二分图上跑最小费用流即可，对于答案增加将残余网络增广即可。</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">using namespace std;
typedef long long ll;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3fll;

struct Edge { int from, to, cap, flow; ll cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int path[maxn], a[maxn];
    ll dis[maxn];

    void init(int n) {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void add(int from, int to, int cap, ll cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, ll&amp; cost)
    {
        for(int i = 0; i &lt;= n; i++) dis[i] = INF;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == INF) return false;     //求最小费用最大流
        //if(1ll * dis[t] * a[t] &gt; 0) return false; 求可行流最小费用，因此当费用增量大于0时不继续增加流量
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    ll mincostMaxFlow(int s, int t)
    {
        int flow = 0; ll cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;


ll a[55], b[55], c[55];
int n, m, tot;
map&lt;int, int&gt; mp;

ll cal(int x, int p)
{
    return a[x] * p * p + b[x] * p + c[x];
}

void addEdge(int x)
{
    ll p = -b[x] / (2 * a[x]);
    int cnt = 0;
    if(p &lt; 0) p = 0;
    if(p &gt; m) p = m;
    int l = p, r = p + 1;
    while(cnt &lt;= 50)
    {
        if(l &lt; 1 &amp;&amp; r &gt; m) break;
        if(l &gt;= 1)
        {
            if(mp.count(l) == 0) mp[l] = tot ++;
            int v = mp[l];
            ll val = cal(x, l);
            ans.add(x, v, 1, val);
            l --;
            cnt ++;
        }
        if(r &lt;= m)
        {
            if(mp.count(r) == 0) mp[r] = tot ++;
            int v = mp[r];
            ll val = cal(x, r);
            ans.add(x, v, 1, val);
            r ++;
            cnt ++;
        }
    }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t --)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= n; i ++) scanf(&quot;%lld%lld%lld&quot;, &amp;a[i], &amp;b[i], &amp;c[i]);
        mp.clear();
        int SS = 0, T = 4001, S = T + 1;
        ans.init(S);
        tot = n + 1;
        for(int i = 1; i &lt;= n; i ++) addEdge(i);
        for(int i = 1; i &lt;= n; i ++) ans.add(SS, i, 1, 0);
        for(int i = n + 1; i &lt; tot; i ++) ans.add(i, T, 1, 0);
        ll res = 0;
        for(int k = 1; k &lt;= n; k ++)
        {
            ans.add(S, SS, 1, 0);
            res += ans.mincostMaxFlow(S, T);
            printf(&quot;%lld%c&quot;, res, &quot; \n&quot;[k == n]);
        }
    }

    return 0;
}
```
</code></pre>

<h2 id="f-the-oculus">F. The Oculus<a class="headerlink" href="#f-the-oculus" title="Permanent link">Link</a></h2>
<p>fib[1] = 1, fib[2] = 2, fib[i] = fib[i - 1] + fib[i - 2]</p>
<p>已知一个数字用 fib 和从高到低贪心和表示是唯一的。</p>
<p>给 A B 两个数字用 fib 的表示方案，给出 <span class="arithmatex">\(C=A*B\)</span> 用 fib 表示方案的错误方案（是正确方案中把一个1变为0），求改的是哪个位置。</p>
<p>直接 hash，由于乘法和加法对取模都是天然成立的。</p>
<p>考虑将 <span class="arithmatex">\(fib_i\)</span> 的 hash 值处理出来，试填每一位合法的 C 为 0 的点即可。赛中使用双 hash 通过，实际自然溢出都可以。</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *
    *   创 建 者： badcw
    *   创建日期： 2020/7/23 14:13
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 1e7+50;
const int mod = 1e9+7;
const int mod2 = 998244353;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf(&quot;%d&quot;, &amp;x); }
void _R(int64_t &amp;x) { scanf(&quot;%lld&quot;, &amp;x); }
void _R(double &amp;x) { scanf(&quot;%lf&quot;, &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf(&quot;%s&quot;, x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf(&quot;%d&quot;, x); }
void _W(const int64_t &amp;x) { printf(&quot;%lld&quot;, x); }
void _W(const double &amp;x) { printf(&quot;%.16f&quot;, x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf(&quot;%s&quot;, x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

ll f[maxn] = {1, 1, 2};
ll g[maxn] = {1, 1, 2};
int vis[maxn];

int main(int argc, char* argv[]) {
    for (int i = 3; i &lt;= 1e7+1; ++i) {
        f[i] = (f[i - 2] + f[i - 1]) % mod;
        g[i] = (g[i - 2] + g[i - 1]) % mod2;
    }
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        int n1, n2, n3;
        R(n1);
        ll m1 = 0, m2 = 0, m3 = 0;
        ll g1 = 0, g2 = 0, g3 = 0;
        for (int i = 1; i &lt;= n1; ++i) {
            int x;
            R(x);
            if (x == 1) {
                m1 = (m1 + f[i]) % mod;
                g1 = (g1 + g[i]) % mod2;
            }
        }
        R(n2);
        for (int i = 1; i &lt;= n2; ++i) {
            int x;
            R(x);
            if (x == 1) {
                m2 = (m2 + f[i]) % mod;
                g2 = (g2 + g[i]) % mod2;
            }
        }
        ll mc = m1 * m2 % mod;
        ll gc = g1 * g2 % mod2;
        R(n3);
        for (int i = 1; i &lt;= n3; ++i) {
            R(vis[i]);
            if (vis[i] == 1) {
                m3 = (m3 + f[i]) % mod;
                g3 = (g3 + g[i]) % mod2;
            }
        }
        vis[0] = 0;
        vis[n3 + 1] = 0;
        int flag = 0;
        for (int i = 1; i &lt;= n3; ++i) {
            if (!vis[i - 1] &amp;&amp; !vis[i + 1] &amp;&amp; !vis[i]) {
                m3 = (m3 + f[i]) % mod;
                g3 = (g3 + g[i]) % mod2;
                if ((mc - m3) % mod == 0 &amp;&amp; (gc - g3) % mod2 == 0) {
                    flag = i;
                    break;
                }
                m3 = (m3 - f[i]) % mod;
                g3 = (g3 - g[i]) % mod2;
            }
        }
        W(flag);
    }
    return 0;
}
```
</code></pre>

<h2 id="g-in-search-of-gold">G. In Search of Gold<a class="headerlink" href="#g-in-search-of-gold" title="Permanent link">Link</a></h2>
<p>一棵树，每条边有 ab 两种边权，求将其 k 条边做 a 边权， 另外 n-1-k 条做 b 边权，求最小直径。其中 <span class="arithmatex">\(n \le 2e4, k \le 20\)</span></p>
<p>首先考虑答案显然是满足二分性质的，考虑二分直径。</p>
<p>对于当前直径 x，做 dp 求出是否可以以 x 做直径。</p>
<p>具体来说 <span class="arithmatex">\(dp_{u,i}=min(dp_{v,i-1}+a,dp_{v,i}+b)\)</span>。比较显然的转移，用类似树上背包的形式做即可，复杂度 <span class="arithmatex">\(O(nk)\)</span>。感觉很容易写成 <span class="arithmatex">\(O(nk^2)\)</span>，需要注意子树大小的剪枝。</p>
<p>加上二分复杂度就是 <span class="arithmatex">\(O(nklog(1e9))\)</span>。</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *
    *   创 建 者： badcw
    *   创建日期： 2020/7/27 21:15
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 2e4 + 50;
const int mod = 1e9 + 7;

ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt;
void _R(T &amp;x) { cin &gt;&gt; x; }

void _R(int &amp;x) { scanf(&quot;%d&quot;, &amp;x); }

void _R(ll &amp;x) { scanf(&quot;%lld&quot;, &amp;x); }

void _R(double &amp;x) { scanf(&quot;%lf&quot;, &amp;x); }

void _R(char &amp;x) { x = getchar(); }

void _R(char *x) { scanf(&quot;%s&quot;, x); }

void R() {}

template&lt;class T, class... U&gt;
void R(T &amp;head, U &amp;... tail) {
    _R(head);
    R(tail...);
}

template&lt;class T&gt;
void _W(const T &amp;x) { cout &lt;&lt; x; }

void _W(const int &amp;x) { printf(&quot;%d&quot;, x); }

void _W(const ll &amp;x) { printf(&quot;%lld&quot;, x); }

void _W(const double &amp;x) { printf(&quot;%.16f&quot;, x); }

void _W(const char &amp;x) { putchar(x); }

void _W(const char *x) { printf(&quot;%s&quot;, x); }

template&lt;class T, class U&gt;
void _W(const pair&lt;T, U&gt; &amp;x) {
    _W(x.F);
    putchar(' ');
    _W(x.S);
}

template&lt;class T&gt;
void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }

void W() {}

template&lt;class T, class... U&gt;
void W(const T &amp;head, const U &amp;... tail) {
    _W(head);
    putchar(sizeof...(tail) ? ' ' : '\n');
    W(tail...);
}

struct E {
    int v, a, b;
};
vector&lt;E&gt; edge[maxn];

ll f[maxn][50], h[maxn], mid, l, r, ans;
int sz[maxn];
int n, m;

inline void up(ll &amp;a, ll b) { a &gt; b ? (a = b) : 0; }

void dfs(int u, int pre) {
    sz[u] = 0;
    for (int i = 0; i &lt;= m; ++i) f[u][i] = 0;
    for (auto x : edge[u]) {
        int v = x.v;
        if (v == pre) continue;
        dfs(v, u);
        int a = x.a, b = x.b;
        for (int i = 0; i &lt;= m; ++i) h[i] = mid + 1;
        for (int i = 0; i &lt;= min(sz[u], m); ++i) {
            for (int j = 0; j &lt;= sz[v] &amp;&amp; i + j &lt;= m; ++j) {
                if (f[u][i] + f[v][j] + a &lt;= mid) up(h[i + j + 1], max(f[u][i], f[v][j] + a));
                if (f[u][i] + f[v][j] + b &lt;= mid) up(h[i + j], max(f[u][i], f[v][j] + b));
            }
        }
        sz[u] += sz[v] + 1;
        for (int i = 0; i &lt;= min(sz[u], m); ++i) f[u][i] = h[i];
    }
}

int main(int argc, char *argv[]) {
//    freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);
//    freopen(&quot;my.out&quot;, &quot;w&quot;, stdout);
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        R(n, m);
        for (int i = 0; i &lt;= n; ++i) edge[i].clear();
        l = 0, r = 0;
        for (int i = 1; i &lt; n; ++i) {
            int u, v, a, b;
            R(u, v, a, b);
            edge[u].push_back({v, a, b});
            edge[v].push_back({u, a, b});
            r += max(a, b);
        }
        while (l &lt;= r) {
            mid = l + r &gt;&gt; 1;
            dfs(1, 0);
            if (f[1][m] &lt;= mid) r = (ans = mid) - 1;
            else l = mid + 1;
        }
        W(ans);
    }
    return 0;
}
```
</code></pre>

<h2 id="i-its-all-squares">I. It&rsquo;s All Squares<a class="headerlink" href="#i-its-all-squares" title="Permanent link">Link</a></h2>
<p>给二维权值矩阵，给 k 次闭合路径，求路径内块的权值和。</p>
<p>直接做出所有边界，差分所有左右移动的路径，对每一列求和即可。</p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *
    *   创 建 者： badcw
    *   创建日期： 2020/7/28 10:55
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 405;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf(&quot;%d&quot;, &amp;x); }
void _R(ll &amp;x) { scanf(&quot;%lld&quot;, &amp;x); }
void _R(double &amp;x) { scanf(&quot;%lf&quot;, &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf(&quot;%s&quot;, x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf(&quot;%d&quot;, x); }
void _W(const ll &amp;x) { printf(&quot;%lld&quot;, x); }
void _W(const double &amp;x) { printf(&quot;%.16f&quot;, x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf(&quot;%s&quot;, x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

int n, m, q;
int flag[maxn][maxn];
int w[maxn][maxn];
int vis[maxn * maxn];
char s[(int)4e6+50];

char t[] = &quot;UDLR&quot;;
int xc[] = {0, 0, -1, 1};
int yc[] = {1, -1, 0, 0};

int main(int argc, char* argv[]) {
//     freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);
//    freopen(&quot;my.out&quot;, &quot;w&quot;, stdout);
//    clock_t ST = clock();
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        R(n, m, q);
        for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) R(w[i][j]);
        for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) flag[i][j] = -1;
        for (int i = 1; i &lt;= n * m; ++i) vis[i] = -1;
        while (q--) {
            int x, y;
            R(x, y);
            R(s);
            int L = x, R = x, U = y, D = y;
            for (int i = 0; s[i]; ++i) {
                for (int j = 0; j &lt; 4; ++j) {
                    if (s[i] == t[j]) {
                        x += xc[j];
                        y += yc[j];
                        break;
                    }
                }
                L = min(L, x);
                R = max(R, x);
                U = max(U, y);
                D = min(D, y);
                if (s[i] == 'L' || s[i] == 'R') {
                    flag[x + (s[i] == 'L')][y + 1] = q;
                }
            }
//            W(L, R, U, D);
            ll res = 0;
            for (int i = L; i &lt;= R; ++i) {
                for (int j = D, now = 0; j &lt;= U; ++j) {
                    now ^= (flag[i][j] == q);
                    if (now &amp;&amp; vis[w[i][j]] != q) {
                        vis[w[i][j]] = q;
                        res ++;
                    }
                }
            }
            W(res);
        }
    }
//    cerr &lt;&lt; &quot;time: &quot; &lt;&lt; ((clock() - ST) * 1000.0 / CLOCKS_PER_SEC) &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
    return 0;
}
```
</code></pre>

<h2 id="j-lead-of-wisdom">J. Lead of Wisdom<a class="headerlink" href="#j-lead-of-wisdom" title="Permanent link">Link</a></h2>
<p>给 50 个物品每个有 abcd 四个权，每个物品有种类，每种只能挑一个。</p>
<p>求最大化 DMG=(100+∑i∈Sai)(100+∑i∈Sbi)(100+∑i∈Sci)(100+∑i∈Sdi)</p>
<p>直接爆搜，把一个物品都没有的种类跳过还有将完全逆序对去掉即可剪枝通过。</p>
<p>需要分析复杂度，最大的情况应该是每种物品 3 个，最后一组 2 个，需要 <span class="arithmatex">\(3^{16}*2\)</span> 的搜索树。</p>
<p>???note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *
    *   创 建 者： badcw
    *   创建日期： 2020/7/23 12:24
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 51;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf(&quot;%d&quot;, &amp;x); }
void _R(int64_t &amp;x) { scanf(&quot;%lld&quot;, &amp;x); }
void _R(double &amp;x) { scanf(&quot;%lf&quot;, &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf(&quot;%s&quot;, x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf(&quot;%d&quot;, x); }
void _W(const int64_t &amp;x) { printf(&quot;%lld&quot;, x); }
void _W(const double &amp;x) { printf(&quot;%.16f&quot;, x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf(&quot;%s&quot;, x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

struct node {
    int a, b, c, d;
    void set(int x, int y, int z, int k) {
        a = x, b = y, c = z, d = k;
    }
};

node s[maxn][maxn];
node pre[maxn];
node now;
int sz[maxn];
int nxt[maxn];
int n, k;
ll res = 0;

inline void cal() { res = max(res, 1ll * (100 + now.a) * (100 + now.b) * (100 + now.c) * (100 + now.d)); }

inline void dfs(int dep) {
    if (dep == k) {
        cal();
        return;
    }
    if (sz[dep] == 0) {
        dfs(dep + 1);
    } else {
        for (int i = 0; i &lt; sz[dep]; ++i) {
            now.a += s[dep][i].a;
            now.b += s[dep][i].b;
            now.c += s[dep][i].c;
            now.d += s[dep][i].d;
            if (s[dep][i].a &lt;= 0 &amp;&amp; s[dep][i].b &lt;= 0 &amp;&amp; s[dep][i].c &lt;= 0 &amp;&amp; s[dep][i].d &lt;= 0) continue;
            dfs(nxt[dep]);
        }
        now.a -= pre[dep].a;
        now.b -= pre[dep].b;
        now.c -= pre[dep].c;
        now.d -= pre[dep].d;
    }
}

int main(int argc, char* argv[]) {
//     freopen(&quot;data.in&quot;,&quot;r&quot;,stdin);
//    freopen(&quot;data.out&quot;, &quot;w&quot;, stdout);
//    clock_t ST = clock();
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        R(n, k);
        for (int i = 0; i &lt; k; ++i) sz[i] = 0, pre[i].set(0, 0, 0, 0);
        int t, a, b, c, d;
        for (int i = 0; i &lt; n; ++i) {
            R(t, a, b, c, d);
            s[t - 1][sz[t - 1] ++] = {a - pre[t - 1].a, b - pre[t - 1].b, c - pre[t - 1].c, d - pre[t - 1].d};
            pre[t - 1].set(a, b, c, d);
        }
        for (int i = 0; i &lt; k; i = nxt[i]) {
            int j = i + 1;
            for (; j &lt; k; ++j) {
                if (sz[j]) break;
            }
            nxt[i] = j;
        }
        res = 0;
        now.set(0, 0, 0, 0);
        dfs(0);
        W(res);
    }
//    cerr &lt;&lt; &quot;time: &quot; &lt;&lt; ((clock() - ST) * 1000.0 / CLOCKS_PER_SEC) &lt;&lt; &quot;ms&quot; &lt;&lt; endl;
    return 0;
}
```
</code></pre>

<h2 id="l-string-distance">L. String Distance<a class="headerlink" href="#l-string-distance" title="Permanent link">Link</a></h2>
<p>给一个 1e5 长度的 s 串，一个 20 长度的 t 串，q（ 1e5 ） 次询问 <span class="arithmatex">\([l,r]\)</span>，问 <code>s[l...r]</code> 最少需要改动多少次（在任意位置删除或添加字符）把他变成 t 串。</p>
<p>考虑离线询问，对于询问为 r 的一次性处理完。</p>
<p>考虑答案其实是 <span class="arithmatex">\(r - l + 1 + t - 2 * lcs(s[l...r], t)\)</span></p>
<p>做 dp， <span class="arithmatex">\(dp_{i,j,k}\)</span> 表示 s 到了第 i 位，与 t 的前 j 位的 lcs 为 k 离 i 的最近点是哪一位。</p>
<p>转移比较轻松，只要预处理了 <span class="arithmatex">\(a\to z\)</span> 在 t 中第一次出现的位置 x，比如我现在枚举到 <span class="arithmatex">\(s[i]\)</span>，那么 <span class="arithmatex">\(dp[i][x\to m][1]\)</span> 都为 i，然后做转移，可以用滚动数组优化。</p>
<p>到了一个 r 的时候，可以从大到小枚举 k，如果有一个 <span class="arithmatex">\(dp[i][j][k]\)</span> 的值不小于 l 则说明 lcs 为 k。</p>
<p>时间复杂度 <span class="arithmatex">\(O(n*m*m+q*logq+q*m*m)\)</span>，用滚动数组优化空间复杂度为 <span class="arithmatex">\(O(m*m+m*26)\)</span></p>
<p>??? note &ldquo;Code&rdquo;
    ```cpp
    /<em>================================================================
    *
    *   创 建 者： badcw
    *   创建日期： 2020/7/23 14:58
    *
    ================================================================</em>/
    #include <bits/stdc++.h></p>
<pre class="codehilite"><code class="linenums">#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 1e5+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf(&quot;%d&quot;, &amp;x); }
void _R(int64_t &amp;x) { scanf(&quot;%lld&quot;, &amp;x); }
void _R(double &amp;x) { scanf(&quot;%lf&quot;, &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf(&quot;%s&quot;, x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf(&quot;%d&quot;, x); }
void _W(const int64_t &amp;x) { printf(&quot;%lld&quot;, x); }
void _W(const double &amp;x) { printf(&quot;%.16f&quot;, x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf(&quot;%s&quot;, x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

char s[maxn];
char t[25];
int n, m;

struct op {
    int idx;
    int l, r;
    bool operator &lt; (const op&amp; oth) const {
        return r &lt; oth.r;
    }
}p[maxn];

int dp[25][25], pd[25][25];
int ans[maxn], fi[26];

int main(int argc, char* argv[]) {
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        scanf(&quot;%s%s&quot;, s + 1, t + 1);
        n = strlen(s + 1);
        m = strlen(t + 1);
        for (int i = 0; i &lt; 26; ++i) fi[i] = -1;
        for (int i = 1; i &lt;= m; ++i) if (fi[t[i] - 'a'] == -1) fi[t[i] - 'a'] = i;
        int q;
        R(q);
        int l, r;
        for (int i = 0; i &lt; q; ++i) {
            R(l, r);
            p[i] = {i, l, r};
        }
        sort(p, p + q);
        int now = 0;
        memset(dp, 0, sizeof dp);
        memset(pd, 0, sizeof pd);
        for (int i = 1; i &lt;= n; ++i) {
            if (fi[s[i] - 'a'] != -1) dp[fi[s[i] - 'a']][1] = i;
            for (int j = 2; j &lt;= m; ++j) {
                for (int k = 2; k &lt;= m; ++k) {
                    dp[j][k] = pd[j][k];
                }
                if (s[i] == t[j]) {
                    for (int k = 1; k &lt; m; ++k) {
                        dp[j][k + 1] = pd[j - 1][k];
                    }
                }
            }
//            cerr &lt;&lt; i &lt;&lt; &quot; ** : \n&quot;;
            for (int j = 1; j &lt;= m; ++j) {
                for (int k = 1; k &lt;= m; ++k) {
                    if (dp[j][k] &lt; dp[j - 1][k]) dp[j][k] = dp[j - 1][k];
                    pd[j][k] = dp[j][k];
//                    cerr &lt;&lt; pd[j][k] &lt;&lt; &quot; &quot;;
                }
//                cerr &lt;&lt; endl;
            }
            while (now &lt; q &amp;&amp; p[now].r == i) {
                ans[p[now].idx] = p[now].r - p[now].l + 1 + m;
                for (int j = m; j &gt;= 1; --j) {
                    if (pd[m][j] &gt;= p[now].l) {
                        ans[p[now].idx] = p[now].r - p[now].l + 1 + m - j * 2;
                        break;
                    }
                }
                now ++;
            }
        }
        for (int i = 0; i &lt; q; ++i) W(ans[i]);
    }
    return 0;
}
```
</code></pre>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy;  <a href="https://wiki.badcw.cn" target="_blank">wiki.badcw.cn</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c99f48ec.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../../../search/main.js"></script>
      
    
  </body>
</html>