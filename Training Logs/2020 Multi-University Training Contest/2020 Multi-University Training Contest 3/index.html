
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://wiki.badcw.cn/Training%20Logs/2020%20Multi-University%20Training%20Contest/2020%20Multi-University%20Training%20Contest%203/">
      
      <link rel="icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>2020 Multi University Training Contest 3 - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1dff34a1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#ffffff">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CUbuntu+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Ubuntu";--md-code-font:"Ubuntu Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="white" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#a-tokitsukaze-csl-and-palindrome-game" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Team Wiki" class="md-header__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Team Wiki
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2020 Multi University Training Contest 3
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Team Wiki" class="md-nav__button md-logo" aria-label="Team Wiki" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.35 10.03A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.03A6.004 6.004 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.97Z"/></svg>

    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          主页
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="主页" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          主页
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        赛季列表
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          个人页面
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="个人页面" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          个人页面
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Verly/index.md" class="md-nav__link">
        Verly
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../badcw/" class="md-nav__link">
        badcw
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          关于
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="关于" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          关于
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../About/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#a-tokitsukaze-csl-and-palindrome-game" class="md-nav__link">
    A. Tokitsukaze, CSL and Palindrome Game
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c-tokitsukaze-and-colorful-tree" class="md-nav__link">
    C. Tokitsukaze and Colorful Tree
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#d-tokitsukaze-and-multiple" class="md-nav__link">
    D. Tokitsukaze and Multiple
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#e-little-w-and-contest" class="md-nav__link">
    E. Little W and Contest
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#g-tokitsukaze-and-rescue" class="md-nav__link">
    G. Tokitsukaze and Rescue
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#h-triangle-collision" class="md-nav__link">
    H. Triangle Collision
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#i-parentheses-matching" class="md-nav__link">
    I. Parentheses Matching
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


  <h1>2020 Multi University Training Contest 3</h1>

<table>
<thead>
<tr>
<th>Name</th>
<th>Date</th>
<th>Solved</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">G</th>
<th align="center">H</th>
<th align="center">I</th>
<th align="center">J</th>
<th align="center">K</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://acm.hdu.edu.cn/search.php?field=problem&amp;key=2020+Multi-University+Training+Contest+3&amp;source=1&amp;searchmode=source">2020 Multi-University Training Contest 3</a></td>
<td>2020/7/28</td>
<td>7/11</td>
<td align="center">Ø</td>
<td align="center">.</td>
<td align="center">Ø</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">Ø</td>
<td align="center">O</td>
<td align="center">O</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>
</tbody>
</table>
<h2 id="a-tokitsukaze-csl-and-palindrome-game">A. Tokitsukaze, CSL and Palindrome Game<a class="headerlink" href="#a-tokitsukaze-csl-and-palindrome-game" title="Permanent link">Link</a></h2>
<p>题意：给一个回文串S，Tokitsukaze和CSL每次会选择回文子串<span class="arithmatex"><span class="MathJax_Preview">S_{a..b}</span><script type="math/tex">S_{a..b}</script></span>和<span class="arithmatex"><span class="MathJax_Preview">S_{c..d}</span><script type="math/tex">S_{c..d}</script></span>。有一个空串P，每次会等概率的在a-z之间选择一个字符，<span class="arithmatex"><span class="MathJax_Preview">E(S)</span><script type="math/tex">E(S)</script></span>表示S成为P子串的操作次数期望。比较<span class="arithmatex"><span class="MathJax_Preview">E(S_{a...b})</span><script type="math/tex">E(S_{a...b})</script></span>和<span class="arithmatex"><span class="MathJax_Preview">E(S_{c...d})</span><script type="math/tex">E(S_{c...d})</script></span>的期望大小。</p>
<p>推荐阅读<a href="https://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%871999-2019/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2018%E8%AE%BA%E6%96%87%E9%9B%86.pdf">《浅谈生成函数在掷骰子问题上的应用》</a>, 并再次推荐阅读<a href="https://www.docin.com/p-1936795644.html">金策-字符串算法选讲</a>来获取本题相关前置知识</p>
<p>前置知识1：对于串S，如果<span class="arithmatex"><span class="MathJax_Preview">S[1,i]=S[n-i+1,n]</span><script type="math/tex">S[1,i]=S[n-i+1,n]</script></span>(长度为i的前缀等于后缀），则称<span class="arithmatex"><span class="MathJax_Preview">S[1,i]</span><script type="math/tex">S[1,i]</script></span>是S的一个border。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">E(S)=\sum_i^{|S|}a_i*m^i</span><script type="math/tex">E(S)=\sum_i^{|S|}a_i*m^i</script></span>，其中<span class="arithmatex"><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span>代表前缀<span class="arithmatex"><span class="MathJax_Preview">S[1,i]</span><script type="math/tex">S[1,i]</script></span>是否是<span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>的border</p>
<p>因为后面带了个i的幂次，显然越靠后的前缀贡献越大，所以对于<span class="arithmatex"><span class="MathJax_Preview">E(S_{a...b})</span><script type="math/tex">E(S_{a...b})</script></span>和<span class="arithmatex"><span class="MathJax_Preview">E(S_{c...d})</span><script type="math/tex">E(S_{c...d})</script></span>，比较一下他们的字典序就好。</p>
<p>前置知识2：回文串的border由是logn级别个等差数列拼接成的，所以对于一个回文串，一直沿着fail树往上跳就可以得到它的所有border。然后根据等差性质，预处理一下border的若干个等差数列，每次对两组等差数列从后往前做比较即可。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;
typedef long long ll;

const int maxn = 1e5 + 10;
const int N = 26;

struct node { int s, d, r; }; 

struct PAM 
{
    int n, p, last;
    int nex[maxn][N], fail[maxn], cnt[maxn], num[maxn], len[maxn], S[maxn], pos[maxn];
    int diff[maxn], pre[maxn];

    int newnode(int l) 
    {
        for(int i = 0; i &lt; N; i ++) nex[p][i] = 0;
        cnt[p] = num[p] = 0;
        len[p] = l;
        return p ++;
    }

    void init()
    {
        n = last = p = 0; 
        newnode(0); newnode(-1);
        S[n] = -1;
        fail[0] = 1;
    }

    int get_fail(int x)
    {
        while(S[n - len[x] - 1] != S[n]) x = fail[x];
        return x;
    }

    void add(int c)
    {
        S[++ n] = c;
        int cur = get_fail(last);
        if(!nex[cur][c])
        {
            int now = newnode(len[cur] + 2);
            fail[now] = nex[get_fail(fail[cur])][c];
            nex[cur][c] = now;
            num[now] = num[fail[now]] + 1;
        }
        last = nex[cur][c];
        diff[last] = len[last] - len[fail[last]];
        if(diff[last] != diff[fail[last]] || len[fail[last]] == 0 || len[fail[last]] == -1) pre[last] = last; 
        else pre[last] = pre[fail[last]];
        num[last] ++;
        pos[n] = last;
    }

    vector&lt;node&gt; getBorder(int x, int lim)
    {
        x = pos[x];
        vector&lt;node&gt; ve;
        while(len[x] &gt; 0)
        {
            int y = pre[x];
            if(len[y] &lt;= lim)
            {
                if(len[x] &lt;= lim) ve.push_back({ len[x], diff[x], (len[x] - len[y]) / diff[x] });
                else ve.push_back({ lim, diff[x], (lim - len[y]) / diff[x] });
            }
            x = fail[y];
        }
        ve.push_back({0, 0, 0});
        return ve;
    }

    int comp(int a, int b, int c, int d)
    {
        auto A = getBorder(b, b - a + 1); auto B = getBorder(d, d - c + 1);
        int i = 0, j = 0, lenA = A.size(), lenB = B.size();
        while(i &lt; lenA - 1 &amp;&amp; j &lt; lenB - 1)
        {
            if(A[i].s != B[j].s) return A[i].s &lt; B[j].s ? -1 : 1;
            if(A[i].d == B[j].d)
            {
                if(A[i].r == B[j].r) i ++, j ++;
                else if(A[i].r &gt; B[j].r) 
                {
                    A[i].s -= (B[j].r + 1) * A[i].d;
                    A[i].r -= B[j].r + 1;
                    j ++;
                    if(A[i].r == 0) i ++;
                }
                else 
                {
                    B[j].s -= (A[i].r + 1) * B[j].d;
                    B[j].r -= A[i].r + 1;
                    i ++;
                    if(B[j].r == 0) j ++;
                }
            }
            else
            {
                if(A[i].r == 0 &amp;&amp; B[j].r == 0) i ++, j ++; 
                else if(A[i].r == 0) return A[i + 1].s &lt; B[j].s - B[j].d ? -1 : 1;  
                else if(B[j].r == 0) return A[i].s - A[i].d &lt; B[j + 1].s ? -1 : 1;
                else return A[i].d &gt; B[j].d ? -1 : 1;
            }
        }
        if(i == lenA - 1 &amp;&amp; j == lenB - 1) return 0;
        return i &lt; lenA - 1 ? -1 : 1;
    }
}pam;

char s[maxn];

int main()
{
    int t;
    scanf("%d", &amp;t);
    while(t --)
    {
        int n, q, a, b, c, d;
        pam.init();
        scanf("%d%s", &amp;n, s);
        for(int i = 0; i &lt; n; i ++) pam.add(s[i] - 'a');
        scanf("%d", &amp;q);
        while(q --)
        {
            scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d);
            int res = pam.comp(a, b, c, d);
            if(res == 0) puts("draw");
            else if(res == 1) puts("cslnb");
            else puts("sjfnb");
        }
    }
    return 0;
}</code></pre>
</details>
<h2 id="c-tokitsukaze-and-colorful-tree">C. Tokitsukaze and Colorful Tree<a class="headerlink" href="#c-tokitsukaze-and-colorful-tree" title="Permanent link">Link</a></h2>
<h2 id="d-tokitsukaze-and-multiple">D. Tokitsukaze and Multiple<a class="headerlink" href="#d-tokitsukaze-and-multiple" title="Permanent link">Link</a></h2>
<p>给一个序列，每次可以合并任意两个连续的点，权值改为他们的和，问若干次以后最多有多少个点是 p 的倍数。 n 1e5</p>
<p>贪心即可，取尽量少的数量和为 p 的倍数就一定会取。</p>
<p>做前缀 map，前缀和对 p 取模即可，每次找到一个前缀和相同的就清空 map 并把答案加一。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">/*================================================================
*
*   创 建 者： badcw
*   创建日期： 2020/7/28 12:09
*
================================================================*/
#include &lt;bits/stdc++.h&gt;

#define VI vector&lt;int&gt;
#define ll long long
using namespace std;

const int maxn = 1e5+50;
const int mod = 1e9+7;
ll qp(ll a, ll n, ll mod = ::mod) {
    ll res = 1;
    while (n &gt; 0) {
        if (n &amp; 1) res = res * a % mod;
        a = a * a % mod;
        n &gt;&gt;= 1;
    }
    return res;
}

template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf("%d", &amp;x); }
void _R(ll &amp;x) { scanf("%lld", &amp;x); }
void _R(double &amp;x) { scanf("%lf", &amp;x); }
void _R(char &amp;x) { x = getchar(); }
void _R(char *x) { scanf("%s", x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf("%d", x); }
void _W(const ll &amp;x) { printf("%lld", x); }
void _W(const double &amp;x) { printf("%.16f", x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf("%s", x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(' '); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\n'); W(tail...); }

map&lt;int, int&gt; mp;

int main(int argc, char* argv[]) {
    int T;
    scanf("%d", &amp;T);
    for (int kase = 1; kase &lt;= T; ++kase) {
        int n, p;
        R(n, p);
        int now = 0;
        int res = 0;
        mp.clear();
        mp[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            int x;
            R(x);
            now += x;
            now %= p;
            if (mp[now]) {
                mp.clear();
                res ++;
            }
            mp[now] = i;
        }
        W(res);
    }
    return 0;
}</code></pre>
</details>
<h2 id="e-little-w-and-contest">E. Little W and Contest<a class="headerlink" href="#e-little-w-and-contest" title="Permanent link">Link</a></h2>
<p>有两种人，一种写代码一种看题，求组成三人队伍起码有两个写代码的数量。有合并操作表示他们合并之后不能在同一个队伍。</p>
<p>考虑合并造成的影响即可，其实每次合并都在减小答案。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;ll,ll&gt; pll;
const int maxn=1e6+5;
const int mod=1e9+7;
vector&lt;ll&gt; V;
ll siz[maxn][3];
int fa[maxn];
int getfa(int n) {
    return fa[n]==n?n:fa[n]=getfa(fa[n]);
}
int main() {
    int T;cin&gt;&gt;T;while(T--) {
        int n;cin&gt;&gt;n;ll cnt[3]={0,0,0};
        for(int i=1;i&lt;=n;i++) siz[i][1]=siz[i][2]=0,fa[i]=i;
        for(int i=1;i&lt;=n;i++) {
            int x;scanf("%d",&amp;x);
            siz[i][x]=1;cnt[x]++;
        }
        ll ans=cnt[1]*cnt[2]*(cnt[2]-1)/2;
        if(cnt[2]&gt;=3) ans+=cnt[2]*(cnt[2]-1)*(cnt[2]-2)/6;
        printf("%lld\n",ans%mod);
        for(int i=1;i&lt;n;i++) {
            int u,v;scanf("%d%d",&amp;u,&amp;v);
            u=getfa(u);v=getfa(v);
            ans=ans-siz[u][1]*siz[v][2]*(cnt[2]-siz[u][2]-siz[v][2])
                   -siz[u][2]*siz[v][2]*(cnt[2]-siz[u][2]-siz[v][2])
                   -siz[u][2]*siz[v][2]*(cnt[1]-siz[u][1]-siz[v][1])
                   -siz[u][2]*siz[v][1]*(cnt[2]-siz[u][2]-siz[v][2]);
            printf("%lld\n",ans%mod);
            fa[u]=v;siz[v][1]+=siz[u][1];siz[v][2]+=siz[u][2];
        }
    }
    return 0;
}</code></pre>
</details>
<h2 id="g-tokitsukaze-and-rescue">G. Tokitsukaze and Rescue<a class="headerlink" href="#g-tokitsukaze-and-rescue" title="Permanent link">Link</a></h2>
<p>题意：一张完全图，边权随机，删k(k&lt;=5，删完保证图联通)条边，问删完之后S到T的最短路最大值是多少。</p>
<p>每次暴力枚举最短路上的边删边，复杂度<span class="arithmatex"><span class="MathJax_Preview">O(n^2c^k)</span><script type="math/tex">O(n^2c^k)</script></span>，c为最短路上的边数，因为边权随机，c一定很小，暴力求解即可。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 50 + 10;

int head[maxn], dis[maxn], cnt;
struct Edge{ int nex, to, w; bool vis; } edge[maxn * maxn];

void add(int u, int v, int w)
{
    edge[++ cnt].nex = head[u];
    edge[cnt].w = w;
    edge[cnt].to = v;
    edge[cnt].vis = false;
    head[u] = cnt;
}

pair&lt;int, int&gt; pre[maxn];

void dij(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            if(edge[i].vis) continue;
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                pre[v] = {u, i};    
                que.push({dis[v], v});
            }
        }
    }
}

int n, k, res;
void dfs(int dep)
{
    if(dep == k) 
    {
        dij(1);
        res = max(res, dis[n]);
        return;
    }
    dij(1);
    int now = n;
    vector&lt;int&gt; path;
    while(now != 1)
    {
        path.push_back(pre[now].second);
        now = pre[now].first;
    }
    for(auto x : path) 
    {
        edge[x].vis = edge[x ^ 1].vis = 1;
        dfs(dep + 1);
        edge[x].vis = edge[x ^ 1].vis = 0;
    }
}

int main()
{
    int t;
    scanf("%d", &amp;t);
    while(t --)
    {
        scanf("%d%d", &amp;n, &amp;k);
        cnt = -1;
        res = 0;
        memset(head, 0xff, sizeof head);
        for(int i = 1; i &lt;= (n - 1) * n / 2; i ++)
        {
            int u, v, w;
            scanf("%d%d%d", &amp;u, &amp;v, &amp;w);
            add(u, v, w);
            add(v, u, w);
        }
        dfs(0);
        printf("%d\n", res);
    }

    return 0;
}</code></pre>
</details>
<h2 id="h-triangle-collision">H. Triangle Collision<a class="headerlink" href="#h-triangle-collision" title="Permanent link">Link</a></h2>
<p>一个球在三角形里面跳，无能量损失，求 t 次碰撞经过的路程。</p>
<p>将三角形展开有循环节，二分求时间即可。理论上也可以直接计算。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;ll,ll&gt; pll;
const int maxn=1e6+5;
vector&lt;ll&gt; V;
int pre[maxn];
double L,x,y,vx,vy,h;int k;
const double SQ3=sqrt(3);
bool check(double t) {
    ll cnt=0;
    double nx=x+vx*t;
    double ny=y+vy*t;
    if(ny&lt;=0) cnt++,ny=-ny;cnt+=(ll)(ny/h);
    double x1=nx-1.0/SQ3*ny,
    x2=nx+1.0/SQ3*ny;
    if(x1&gt;L/2) {
        cnt+=1+(ll)(x1-L/2)/L;
    }if(x2&gt;L/2) {
        cnt+=1+(ll)(x2-L/2)/L;
    }
    if(x1&lt;-L/2) {
        cnt+=1-(ll)(x1+L/2)/L;
    }if(x2&lt;=-L/2) {
        cnt+=1-(ll)(x2+L/2)/L;
    }
    return cnt&gt;=k;
}
int main() {
    int T;cin&gt;&gt;T;while(T--) {
        scanf("%lf%lf%lf%lf%lf%d",&amp;L,&amp;x,&amp;y,&amp;vx,&amp;vy,&amp;k);
        h=SQ3*L/2;
        double l=0,r=1e13;
        while(r-l&gt;0.00001){
            double mid=(l+r)/2;
            if(check(mid)) r=mid;
            else l=mid;
        }
        printf("%.8f\n",l);
    }
    return 0;
}</code></pre>
</details>
<h2 id="i-parentheses-matching">I. Parentheses Matching<a class="headerlink" href="#i-parentheses-matching" title="Permanent link">Link</a></h2>
<p>有一些位置没有确定的括号序列，要使括号序列合法的最小字典序解。</p>
<p>找到未匹配左括号的可以放的最右点，和未匹配右括号可以放的最左边。</p>
<details class="note">
<summary>Code</summary>
<pre class="highlight"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;
typedef long long ll;

const int maxn = 1e5 + 10;
char s[maxn];

int main()
{
    int q;
    scanf("%d", &amp;q);
    while(q --)
    {
        scanf("%s", s + 1);
        int n = strlen(s + 1);
        stack&lt;int&gt; l;
        queue&lt;int&gt; que;
        for(int i = 1; i &lt;= n; i ++)
        {
            if(s[i] == '(') l.push(i);
            else if(s[i] == ')')
            {
                if(l.empty()) que.push(i);
                else l.pop();
            }
        }
        bool flag = false;
        for(int i = 1; i &lt;= n; i ++)
        {
            if(que.empty()) break;
            if(s[i] =='*') {
                if(que.front() &lt; i) {flag = true; break; } 
                s[i] = '(';
                que.pop();
            } 
        }
        if(flag || !que.empty())
        {
            puts("No solution!");
            continue;
        }
        while(!l.empty()) {que.push(l.top()); l.pop();}
        for(int i = n; i &gt;= 1; i --) 
        {
            if(que.empty()) break;
            if(s[i] == '*') 
            {
                if(que.front() &gt; i) {flag = true; break; }
                s[i] = ')';
                que.pop();
            }
        }
        if(flag || !que.empty())
        {
            puts("No solution!");
            continue;
        }
        for(int i = 1; i &lt;= n; i ++) if(s[i] != '*') printf("%c", s[i]);
        puts("");


    }

    return 0;
}</code></pre>
</details>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy;  <a href="https://wiki.badcw.cn" target="_blank">wiki.badcw.cn</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c99f48ec.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../../../search/main.js"></script>
      
    
  </body>
</html>