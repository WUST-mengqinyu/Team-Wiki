# 状态压缩dp的相关问题

状态压缩dp常用来处理量级很小的np问题

由此还可以衍生出轮廓线dp及在此之上的插头dp

状态的二进制表示法中有一些小操作想分享一下：

## 1、枚举二进制状态子集

```c++
//for(int i = 0; i != s; i = (i-s)&s)
void print(int x) {
    if (x < 2) printf("%d", x);
    else {
        print(x >> 1);
        print(x % 2);
    }
}

int main() {
    int s = 0B1111;
    for (int i = 0; i != s; i = (i - s) & s) {
        print(i);
        printf("\n");
    }
}
/*输出为：
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
*/
```

很方便而且是升序

## 2、状态的各种基本操作

```c++
// 所有位为1
(1<<n)-1 //注意位运算比一次运算优先级低所以要加括号
// 判断第i位
stat & (1<<i)
// lowbit，状态中最靠近末尾的1
i & -i
// 求状态中含有的选中数量，相当于求二进制位中1的个数
int c = 0;
for (int i = 0; i < n; ++i) if (stat & (1<<i)) c++;
// 或者直接预处理，这里用到了lowbit
for (int i = 0; i < (1<<n); ++i) c[i] = c[i ^ (i & -i)] + 1;
// 枚举递推下一个状态，其实随便写就是了
for (int i = 0; i < n; ++i) {
    if ((stat & (1<<i)) == 0) {
        int newstat = stat | (1<<i);
    }
}
```



## 3、轮廓线dp入门

说到轮廓线dp就是那个方格填充问题，求用1*2的方格填满n×m的方案数。 【poj 2411】

- 这里是基础部分，会的可以跳过

- 设计\( dp[i][j][k] \)是第i行第j列，上方状态为k的方案数

- 最后求解的是\( dp[n][m][(1<<m)-1] \)

- 0000xxx

  xxxx000

  这样一张图，表示枚举到了第2行第4列，那么它所需要的状态为标x的位置是否填充，往下递推将第2行第5列填充一个竖着的方格的话就是：

  ```cpp
  int newstat = stat >> 1 | (1 << m - 1) | 1
  ```

  其中 stat>>1 就是把状态变成了

  00000xx

  xxxxx00

  去掉了头位，增加了一位，这就是轮廓线dp，类似一个取窗口shift的过程。标x的位置也就是轮廓线。

  方格填充问题的具体解答是：

  1、每次枚举只有三种情况，一是此位置不填，二是此位置填竖着的1×2也就是上一行同列和此位置，三是填横着的也就是上一列同行和此位置

  2、如果轮廓线中上一行同列的位置为空必须要填上不然之后就没有方法可以将那个位置补上所以是

  ```cpp
  if ((stat & 2) == 0) {
      int newstat = stat >> 1 | (1 << m - 1) | 1;
      dp[i][j][newstat] += dp[i][j - 1][stat];//i,j-1看情况改动，是它上一个状态的位置
      continue;
  }
  ```

  注意此时要不是第一行，根据你从1还是0开始记录行数可能有负下标的风险所以判断一下i是否大于开始行下标

  3、如果不是以上情况就可以不填

  ```cpp
  int newstat = stat >> 1;
  dp[i][j][newstat] += dp[i][j - 1][stat];
  ```

  4、如果左边为空可以填

  ```cpp
  if ((stat & (1<<m - 1)) == 0) {
      int newstat = stat >> 1 | 3;
      dp[i][j][newstat] += dp[i][j - 1][stat];
  }
  ```

  当然以上只是解释性的写法，真要做题的话显然可以加个滚动数组，它每个点都只与上一个状态相关，而且写起来反而更简单。

我习惯来讲是把最远位看做0位，因为可以右溢

0000xxx

xxxx000

简单来讲比如这个枚举到了第2行第4列

那么它状态就要去表示标“x”的位置，如果把它正上方（也就是1，5）那个点看做是状态的最后一位也就是0位，在往下递推的过程中就能够

```cpp
int newstat = stat >> 1 | (1<<m-1)
```

直接得出下一组状态，不需要考虑溢出位

如果反着设计状压也可以使用取模来减去溢出位

一道题：codeforces 903F

大意：给一个4×m的矩阵，有些位置为x，需要用1×1， 2×2，3×3， 4×4的格子将其填充使得所有x位置都要被覆盖。每种格子有一个代价，求最小代价。

显然此题轮廓线大小为4*4也就是前16个格子，考虑从左往右、从下往上递推即可。

唯一不好处理的是这个代价问题。

强烈推荐读一下dotorya的代码，简直神作，读到就是赚到

```cpp
// https://codeforces.com/contest/903/submission/33174261
int A[5];
int val[5];
char in[4][1050];
 
int nxt[65536][120];
int cost[120];
 
int dp[1050][4096];
int main() {
	int N, i, j, k, l, m;
	scanf("%d", &N);
	for (i = 1; i <= 4; i++) scanf("%d", &A[i]);
	for (i = 0; i < 4; i++) scanf("%s", in[i]);
	for (i = 1; i <= 4; i++) {
		for (j = 0; j < i; j++) for (k = 0; k < i; k++) val[i] |= 1 << (4 * j + k);
	}
 
	int p = 0;
	for (i = 0; i <= 1; i++) {
		for (j = 0; j <= 2; j++) {
			for (k = 0; k <= 3; k++) {
				for (l = 0; l <= 4; l++) {
					int totc = A[i] + A[j] + A[k] + A[l];
					cost[p] = totc;
					int v = (val[i] << 3) | (val[j] << 2) | (val[k] << 1) | val[l];
					for (m = 0; m < 65536; m++) nxt[m][p] = m & ~v;
					p++;
				}
			}
		}
	}
 
	memset(dp, 0x3f, sizeof(dp));
	int st = 0;
	for (i = 0; i < 1; i++) {
		for (j = 0; j < 4; j++) {
			st = st * 2;
			if (in[j][i] == '*') st++;
		}
	}
	for (i = 0; i < 120; i++) dp[0][nxt[st][i]] = min(dp[0][nxt[st][i]], cost[i]);
	for (i = 1; i < N; i++) {
		int v = 0;
		for (j = 0; j < 4; j++) v = v * 2 + (int)(in[j][i] == '*');
		for (j = 0; j < 4096; j++) {
			if (dp[i-1][j] > 1000000) continue;
 
			l = j * 16 + v;
			for (k = 0; k < 120; k++) {
				int x = nxt[l][k];
				if (x < 4096) dp[i][x] = min(dp[i][x], dp[i - 1][j] + cost[k]);
			}
		}
	}
 
	return !printf("%d\n", dp[N - 1][0]);
}
```

首先\( val[1～4] \)表示了1×1到4×4的方格填充的轮廓线形状

然后预处理中的一个 nxt 数组是真的精髓，\( net[m][p] \)表示的是把m状态经过p这个转移方式可以转移到的状态，p这个转移方式的代价为$cost[p]$，由于状压dp这种东西真的是不能表示很多状态，题目的数据范围也会很小，这样的预处理不仅可以很好的提高代码运行效率还可以减低我们的编写难度。

注意他这里转移方式的总数的问题，其实我们说16个格子用1~4的方格填满最多甚至需要16个1*1，但是4个1× 1必然是只与前一列相关联，所以最多4个就可以解决所有问题p的状态数就是$1×2×3×4=24$种，虽然不明白他为何要写成120种但是这个nxt数组的优越性就体现出来了，就算后面的p不做处理，它仍然是正确的，因为nxt数组默认指向0，再怎么瞎弄它最终0既不是答案，也不能改变中间状态，同时代价也是0。

然后可以说后面随便设计轮廓线都是可以写的了，不过多赘述。



## 4、插头dp

等哪天会手撕了再写

大概步骤是：设计轮廓线->设计插头编码->考虑hashmap的存储->设计状态转移->开始上手

这个算法让我觉得在做程序设计而不是算法设计。



## 5、状压dp其他细节

- 顺序问题：

- 例题：https://www.cometoj.com/contest/52/problem/C

- 很精髓的一题，求解所有合法排列的逆序对\( ∣i−j∣ × ∣pos_j−pos_i∣ \)的权值和

- 本来状压解决这种问题相当困难，因为相当于是一个带顺序的选择问题，一般来讲暴力是阶乘级别的算法，但是这种问题就和状压dp解决旅行商问题一样，将阶乘复杂度降低到指数级。

- 其实可以对已选择的位置进行状压，然后添加序列就是从小到大，这样就可以不必考虑顺序。

- 用一个\( dp[1<<maxn] \)表示某种选择下的权值贡献

- 这样降低复杂度的原因是其实它状态中1的个数就是当前取的数的大小-1。

- 考虑转移方乘：

- \( dp[s] = \sum (dp[s'] + \sum_{x=s \bigoplus s'+1}^n(pre - t)*(x - s\bigoplus s')) \)

- 其中s'表示s的子集，t表示s'中1的个数（即当前取的数-1），pre表示比t小的某个数

- 看似不可解，其实由于确定了从小到大放数的顺序，它真正每种情况的顺序反而变得不那么重要了。

- 记录\( g[1<<maxn] \)表示某种状态的可能排列个数

- \( t[1<<maxn][maxn] \)表示某种状态下某位置上所有排列可能性的值的和。

- 由于下一种状态的数比已添加的数都大，所以只要是包含在值内且在当前位置后面的数都是逆序对。

- 转移就变简单了

- 设s的二进制表示中1的个数为y，枚举到的位置（\( s\bigoplus s' \)）为x

- 则有

- $$
  \begin{cases} 
  dp[s] = \sum_{s'} (dp[s'] + \sum_{z>x，z\in s'} (z - x)*(g[s]*y - t[s][z]))
  \\
  t[s][i] = \sum_{s'}(t[s][i]) & \text{i != x}
  \\
  t[s][x] = \sum_{s'}(g[s]*y + t[s][x])
  \\
  g[s] = \sum_{s'}g[s']
  \end{cases}
  $$

- 看的有点云里雾里，实际上就是把所有子集的情况都累加到一起，t数组就是用来储存每位上子集所有情况的数字和。然后每次把它后面的和加到dp数组即可

- 维护g数组是为了更新t数组，所以整个一来可以看出一个套路：

- 对一个带顺序和权值的状压dp，往往需要维护三个权值：状态的可能性个数、状态上每一位的权值和、状态本身代表的填充方式。

- 一道新题：codeforces 1152F1

- 大意：有n个物品，你可以选k个，每次选择的是之前没有选过而且设上一个的位置为x，当前物品只能在\(1~x+m\)之间选择，求选k个的方案数

- 又是指定了顺序，如果确定（坐标）从小往大取，那么当前要取的点只与前m个位置的取数情况有关，这个点要么直接是最后一个取，要么之前m位有取过的情况下可以是它们转移过来。

- 直接设计轮廓线为前m个位置的取数情况

- \( dp[i][j][k] \)表示前i个物品，取了j个，i-k到i的取数情况为k的方案数。

- \( dp[i + 1][j][stat>>1] += dp[i][j][stat] \)表示不取直接把轮廓线移位

- \( dp[i + 1][j + 1][stat>>1|(1<<m-1)] += dp[i][j][stat] * (bitcount(stat) + 1) \) 表示取最后一个，方案与前m个位置情况相关


## 6、分辨状压dp和费用流

众所周知费用流和状压dp都是用来解决小范围数据的np问题的。那么当拿到一个题看的数据范围20甚至10以内怎样分辨也是一个问题。

状压dp有个很重要的特点就是：取还是不取，能不能取。

费用流有个很重要的特点：一般不用来解决线性问题。

那么首先应该看是否是线性或顺序无关的问题，如果是定是状压dp，否则看是否符合取不取的01规则，如果是定是状压dp，否则状压基本无法解决，考虑费用流和爆搜。