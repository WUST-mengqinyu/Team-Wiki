



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://wiki.verly-badcw.top/Personal Page/Verly/网络流/网络流24题/">
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../../..">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.5.1">
    
    
      
        <title>网络流24题 - Team Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/application.82a18eb7.css">
      
        <link rel="stylesheet" href="../../../../assets/stylesheets/application-palette.3e3d1dff.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono&display=fallback">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../../../../stylesheets/extra.css">
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-139418303-1", "wiki.verly-badcw.top")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#1" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://wiki.verly-badcw.top" title="Team Wiki" class="md-header-nav__button md-logo">
          
            <i class="md-icon">cloud</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Team Wiki
            </span>
            <span class="md-header-nav__topic">
              
                网络流24题
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../../../.." class="md-tabs__link">
        Team Wiki
      </a>
    
  </li>

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../../../About/About/" class="md-tabs__link">
          About
        </a>
      
    </li>
  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../" class="md-tabs__link md-tabs__link--active">
          Personal Page
        </a>
      
    </li>
  

  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../../../Topic Training/Segment Tree/SegmentTree2/" class="md-tabs__link">
          Topic Training
        </a>
      
    </li>
  

  

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 1/" class="md-tabs__link">
          Training Logs
        </a>
      
    </li>
  

  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://wiki.verly-badcw.top" title="Team Wiki" class="md-nav__button md-logo">
      
        <i class="md-icon">cloud</i>
      
    </a>
    Team Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../../.." title="Team Wiki" class="md-nav__link">
      Team Wiki
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      About
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        About
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../About/About/" title="About" class="md-nav__link">
      About
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Personal Page
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Personal Page
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-1" type="checkbox" id="nav-3-1" checked>
    
    <label class="md-nav__link" for="nav-3-1">
      Verly
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-3-1">
        Verly
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-1-2" type="checkbox" id="nav-3-1-2" checked>
    
    <label class="md-nav__link" for="nav-3-1-2">
      网络流
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-3-1-2">
        网络流
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../cf网络流版切/" title="Cf网络流版切" class="md-nav__link">
      Cf网络流版切
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        网络流24题
      </label>
    
    <a href="./" title="网络流24题" class="md-nav__link md-nav__link--active">
      网络流24题
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1.飞行员配对方案问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2.太空飞行计划问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3.  最小路径覆盖问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4.魔术球问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5.  圆桌问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6.  最长递增子序列问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7.试题库问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9" class="md-nav__link">
    9.方格取数问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10.餐巾计划问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    11.航空路线问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    12.软件补丁问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    13.星际转移问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    14. 孤岛营救问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    15.汽车加油行驶问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    16.数字梯形问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17" class="md-nav__link">
    17.运输问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    18.分配问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    19.负载平衡问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20" class="md-nav__link">
    20.深海机器人问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21k" class="md-nav__link">
    21.最长k可重区间集问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22k" class="md-nav__link">
    22.最长k可重线段集问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    23.火星探险问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    24.骑士共存问题
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-2" type="checkbox" id="nav-3-2">
    
    <label class="md-nav__link" for="nav-3-2">
      Badcw
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-3-2">
        Badcw
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-2-1" type="checkbox" id="nav-3-2-1">
    
    <label class="md-nav__link" for="nav-3-2-1">
      Codeforces
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-3-2-1">
        Codeforces
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../badcw/Codeforces/Codeforces Round 586 (Div. 1 + Div. 2)/" title="Codeforces Round 586 (Div. 1 + Div. 2)" class="md-nav__link">
      Codeforces Round 586 (Div. 1 + Div. 2)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../badcw/Codeforces/Codeforces Round 588 (Div. 2)/" title="Codeforces Round 588 (Div. 2)" class="md-nav__link">
      Codeforces Round 588 (Div. 2)
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-2-2" type="checkbox" id="nav-3-2-2">
    
    <label class="md-nav__link" for="nav-3-2-2">
      动态规划
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-3-2-2">
        动态规划
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../badcw/动态规划/状态压缩dp的相关问题/" title="状态压缩dp的相关问题" class="md-nav__link">
      状态压缩dp的相关问题
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../badcw/动态规划/矩阵快速幂dp/" title="矩阵快速幂" class="md-nav__link">
      矩阵快速幂
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-2-3" type="checkbox" id="nav-3-2-3">
    
    <label class="md-nav__link" for="nav-3-2-3">
      字符串
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-3-2-3">
        字符串
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../badcw/字符串/kmp/" title="Kmp" class="md-nav__link">
      Kmp
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../badcw/字符串/回文树/" title="回文树" class="md-nav__link">
      回文树
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Topic Training
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Topic Training
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4-1" type="checkbox" id="nav-4-1">
    
    <label class="md-nav__link" for="nav-4-1">
      Segment Tree
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-4-1">
        Segment Tree
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Topic Training/Segment Tree/SegmentTree2/" title="SegmentTree2" class="md-nav__link">
      SegmentTree2
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Training Logs
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Training Logs
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-1" type="checkbox" id="nav-5-1">
    
    <label class="md-nav__link" for="nav-5-1">
      2019 Multi University Training Contest
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-1">
        2019 Multi University Training Contest
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 1/" title="2019 Multi University Training Contest 1" class="md-nav__link">
      2019 Multi University Training Contest 1
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 2/" title="2019 Multi-University Training Contest 2" class="md-nav__link">
      2019 Multi-University Training Contest 2
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 3/" title="2019 Multi University Training Contest 3" class="md-nav__link">
      2019 Multi University Training Contest 3
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-2" type="checkbox" id="nav-5-2">
    
    <label class="md-nav__link" for="nav-5-2">
      2019CCPC分站赛
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-2">
        2019CCPC分站赛
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019CCPC分站赛/2019 China Collegiate Programming Contest Qinhuangdao Onsite/" title="2019 China Collegiate Programming Contest Qinhuangdao Onsite" class="md-nav__link">
      2019 China Collegiate Programming Contest Qinhuangdao Onsite
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019CCPC分站赛/第五届中国大学生程序设计竞赛总决赛/" title="第五届中国大学生程序设计竞赛总决赛" class="md-nav__link">
      第五届中国大学生程序设计竞赛总决赛
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-3" type="checkbox" id="nav-5-3">
    
    <label class="md-nav__link" for="nav-5-3">
      2019ICPC区域赛
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-3">
        2019ICPC区域赛
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019ICPC区域赛/2019 ICPC Asia Nanjing Regional Contest/" title="2019 ICPC Asia Nanjing Regional Contest" class="md-nav__link">
      2019 ICPC Asia Nanjing Regional Contest
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-4" type="checkbox" id="nav-5-4">
    
    <label class="md-nav__link" for="nav-5-4">
      2019牛客暑期多校训练营
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-4">
        2019牛客暑期多校训练营
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第一场）/" title="2019牛客暑期多校训练营（第一场）" class="md-nav__link">
      2019牛客暑期多校训练营（第一场）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第七场）/" title="2019牛客暑期多校训练营（第七场）" class="md-nav__link">
      2019牛客暑期多校训练营（第七场）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第三场）/" title="2019牛客暑期多校训练营（第三场）" class="md-nav__link">
      2019牛客暑期多校训练营（第三场）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第二场）/" title="2019牛客暑期多校训练营（第二场）" class="md-nav__link">
      2019牛客暑期多校训练营（第二场）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第五场）/" title="2019牛客暑期多校训练营（第五场）" class="md-nav__link">
      2019牛客暑期多校训练营（第五场）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第四场）/" title="2019牛客暑期多校训练营（第四场）" class="md-nav__link">
      2019牛客暑期多校训练营（第四场）
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-5" type="checkbox" id="nav-5-5">
    
    <label class="md-nav__link" for="nav-5-5">
      2019网络预选赛
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-5">
        2019网络预选赛
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019网络预选赛/The Preliminary Contest for ICPC Asia Shanghai 2019/" title="The Preliminary Contest for ICPC Asia Shanghai 2019" class="md-nav__link">
      The Preliminary Contest for ICPC Asia Shanghai 2019
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019网络预选赛/The Preliminary Contest for ICPC Asia Shenyang 2019/" title="The Preliminary Contest for ICPC Asia Shenyang 2019" class="md-nav__link">
      The Preliminary Contest for ICPC Asia Shenyang 2019
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-6" type="checkbox" id="nav-5-6">
    
    <label class="md-nav__link" for="nav-5-6">
      2019训练赛
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-6">
        2019训练赛
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2017-2018 ACM-ICPC, NEERC, Northern Subregional Contest/" title="2017 2018 ACM ICPC, NEERC, Northern Subregional Contest" class="md-nav__link">
      2017 2018 ACM ICPC, NEERC, Northern Subregional Contest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2018 ACM 国际大学生程序设计竞赛上海大都会赛/" title="2018 ACM 国际大学生程序设计竞赛上海大都会赛" class="md-nav__link">
      2018 ACM 国际大学生程序设计竞赛上海大都会赛
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2018 China Collegiate Programming Contest Final (CCPC-Final 2018)/" title="2018 China Collegiate Programming Contest Final (CCPC Final 2018)" class="md-nav__link">
      2018 China Collegiate Programming Contest Final (CCPC Final 2018)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2018-2019 ACM-ICPC, Asia East Continent Finals/" title="2018 2019 ACM ICPC, Asia East Continent Finals" class="md-nav__link">
      2018 2019 ACM ICPC, Asia East Continent Finals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2019 ICPC Asia Nanchang Regional/" title="2019 ICPC Asia Nanchang Regional" class="md-nav__link">
      2019 ICPC Asia Nanchang Regional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2019 ICPC Asia Xuzhou Regional/" title="2019 ICPC Asia Xuzhou Regional" class="md-nav__link">
      2019 ICPC Asia Xuzhou Regional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2019-2020 ICPC, Asia Jakarta Regional Contest/" title="2019 2020 ICPC, Asia Jakarta Regional Contest" class="md-nav__link">
      2019 2020 ICPC, Asia Jakarta Regional Contest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2019-2020 ICPC, NERC, Northern Eurasia Finals/" title="2019 2020 ICPC, NERC, Northern Eurasia Finals" class="md-nav__link">
      2019 2020 ICPC, NERC, Northern Eurasia Finals
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/2019-2020 ICPC, NERC, Southern and Volga Russian Regional Contest/" title="2019 2020 ICPC, NERC, Southern and Volga Russian Regional Contest" class="md-nav__link">
      2019 2020 ICPC, NERC, Southern and Volga Russian Regional Contest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/The 13th Chinese Northeast Collegiate Programming Contest/" title="The 13th Chinese Northeast Collegiate Programming Contest" class="md-nav__link">
      The 13th Chinese Northeast Collegiate Programming Contest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/The 2018 ACM-ICPC Asia Beijing Regional Contest/" title="The 2018 ACM ICPC Asia Beijing Regional Contest" class="md-nav__link">
      The 2018 ACM ICPC Asia Beijing Regional Contest
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../../Training Logs/2019训练赛/The 2019 China Collegiate Programming Contest Harbin Site/" title="The 2019 China Collegiate Programming Contest Harbin Site" class="md-nav__link">
      The 2019 China Collegiate Programming Contest Harbin Site
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1.飞行员配对方案问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    2.太空飞行计划问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3.  最小路径覆盖问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    4.魔术球问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    5.  圆桌问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6" class="md-nav__link">
    6.  最长递增子序列问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7" class="md-nav__link">
    7.试题库问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9" class="md-nav__link">
    9.方格取数问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10" class="md-nav__link">
    10.餐巾计划问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    11.航空路线问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    12.软件补丁问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13" class="md-nav__link">
    13.星际转移问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    14. 孤岛营救问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15" class="md-nav__link">
    15.汽车加油行驶问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16" class="md-nav__link">
    16.数字梯形问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17" class="md-nav__link">
    17.运输问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    18.分配问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    19.负载平衡问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20" class="md-nav__link">
    20.深海机器人问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21k" class="md-nav__link">
    21.最长k可重区间集问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22k" class="md-nav__link">
    22.最长k可重线段集问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#23" class="md-nav__link">
    23.火星探险问题
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#24" class="md-nav__link">
    24.骑士共存问题
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>网络流24题</h1>
                
                <table>
<thead>
<tr>
<th>No</th>
<th>Problem</th>
<th>model</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>飞行员配对方案问题</td>
<td>二分图最大匹配</td>
</tr>
<tr>
<td>2</td>
<td>太空飞行计划问题</td>
<td>最大权闭合子图</td>
</tr>
<tr>
<td>3</td>
<td>最小路径覆盖问题</td>
<td>最小路径覆盖</td>
</tr>
<tr>
<td>4</td>
<td>魔术球问题</td>
<td>最小路径覆盖</td>
</tr>
<tr>
<td>5</td>
<td>圆桌问题</td>
<td>二分图多重匹配</td>
</tr>
<tr>
<td>6</td>
<td>最长递增子序列问题</td>
<td>最多不相交路径</td>
</tr>
<tr>
<td>7</td>
<td>试题库问题</td>
<td>二分图多重匹配</td>
</tr>
<tr>
<td>8</td>
<td>机器人路径规划问题</td>
<td>//////</td>
</tr>
<tr>
<td>9</td>
<td>方格取数问题</td>
<td>最大点权独立集</td>
</tr>
<tr>
<td>10</td>
<td>餐巾计划问题</td>
<td>费用流</td>
</tr>
<tr>
<td>11</td>
<td>航空路线问题</td>
<td>费用流</td>
</tr>
<tr>
<td>12</td>
<td>软件补丁问题</td>
<td>最短路径</td>
</tr>
<tr>
<td>13</td>
<td>星际转移问题</td>
<td>残量网络最大流</td>
</tr>
<tr>
<td>14</td>
<td>孤岛营救问题</td>
<td>分层图最短路</td>
</tr>
<tr>
<td>15</td>
<td>汽车加油行驶问题</td>
<td>分层图最短路</td>
</tr>
<tr>
<td>16</td>
<td>数字梯形问题</td>
<td>费用流</td>
</tr>
<tr>
<td>17</td>
<td>运输问题</td>
<td>二分图最大权多重匹配</td>
</tr>
<tr>
<td>18</td>
<td>分配问题</td>
<td>二分图最大权匹配</td>
</tr>
<tr>
<td>19</td>
<td>负载平衡问题</td>
<td>费用流</td>
</tr>
<tr>
<td>20</td>
<td>深海机器人问题</td>
<td>费用流</td>
</tr>
<tr>
<td>21</td>
<td>最长k可重区间集问题</td>
<td>最大权不相交路径</td>
</tr>
<tr>
<td>22</td>
<td>最长k可重线段集问题</td>
<td>费用流</td>
</tr>
<tr>
<td>23</td>
<td>火星探险问题</td>
<td>费用流</td>
</tr>
<tr>
<td>24</td>
<td>骑士共存问题</td>
<td>最大独立集</td>
</tr>
</tbody>
</table>
<h2 id="1">1.飞行员配对方案问题<a class="headerlink" href="#1" title="Permanent link">Link</a></h2>
<p>二分图最大匹配，直接建图跑最大流。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=200+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
}

int main()
{
    int n,m,u,v;
    scanf("%d%d",&amp;n,&amp;m);
    int S=0,T=n+1;
    for(int i=1;i&lt;=n;i++)
    {
        if(i&lt;=m) add(S,i,1);
        else add(i,T,1);
    }
    while(scanf("%d%d",&amp;u,&amp;v)!=EOF) add(u,v,1);
    printf("%d\n",max_flow(S,T));
    return 0;
}</code></pre>

<h2 id="2">2.太空飞行计划问题<a class="headerlink" href="#2" title="Permanent link">Link</a></h2>
<p>必须选择所有左端点才能选择右端点获得收益，最大权闭合子图模型。最大权闭合子图=总权值和-最小割</p>
<p>输出方案时选择与S/T相连满流的割边。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=2500+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

int n,m;

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) break;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
    int cnt=0;
    for(int i=1;i&lt;=m;i++)
    {
        if(level[i]&gt;0)
        {
            if(cnt++) printf(" ");
            printf("%d",i);
        }
    }
    printf("\n");
    cnt=0;
    for(int i=1+m;i&lt;=n+m;i++)
    {
        if(level[i]&gt;0)
        {
            if(cnt++) printf(" ");
            printf("%d",i-m);
        }
    }
    printf("\n");
    return flow;
}

int main()
{
    int val,sum=0,a[55],b[55];
    char tools[10000];
    scanf("%d%d",&amp;m,&amp;n);
    int S=0,T=m+n+1;
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%d",&amp;val);
        b[i]=val;
        sum+=val;
        add(S,i,val);
        memset(tools,0,sizeof tools);
        cin.getline(tools,10000);
        int ulen=0,tool;
        while(sscanf(tools+ulen,"%d",&amp;tool)==1)
        {
            add(i,tool+m,INF);
            if(tool==0) ulen++;
            else
            {
                while(tool)
                {
                    tool/=10;
                    ulen++;
                }
            }
            ulen++;
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;val);
        add(i+m,T,val);
        a[i]=val;
    }
    printf("%d\n",sum-max_flow(S,T));
    return 0;
}</code></pre>

<h2 id="3">3.  最小路径覆盖问题<a class="headerlink" href="#3" title="Permanent link">Link</a></h2>
<p>拆点求最小路径覆盖，最小路径覆盖数=|G|-二分图最大匹配数（｜Ｇ｜是有向图中的总边数）</p>
<p>输出路径：并查集维护同一路径上的点，从根节点递归向下找满流的点。</p>
<pre class="codehilite"><code class="language-cpp linenums">#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=400+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
}

int n;

void print(int x)
{
    for(auto e:G[x])
    {
        if(e.cap==0&amp;&amp;e.to&gt;n)
        {
            printf(" %d",e.to-n);
            print(e.to-n);
        }
    }
}

int pre[400+10];

int Find(int x) {return x==pre[x]?x:pre[x]=Find(pre[x]); }

int main()
{
    int m,u,v;
    scanf("%d%d",&amp;n,&amp;m);
    int S=0,T=2*n+1;
    for(int i=1;i&lt;=n;i++)
    {
        add(S,i,1);
        add(i+n,T,1);
    }
    for(int i=0;i&lt;m;i++)
    {
        scanf("%d%d",&amp;u,&amp;v);
        add(u,v+n,1);
    }
    int ans=n-max_flow(S,T);
    for(int i=S;i&lt;=T;i++) pre[i]=i;
    for(int i=1;i&lt;=n;i++)
        for(auto e:G[i])
            if(e.to&gt;n&amp;&amp;e.to&lt;T&amp;&amp;e.cap==0) pre[e.to-n]=Find(i);
    for(int i=1;i&lt;=n;i++)
    {
        if(i==Find(i))
        {
            printf("%d",i);
            print(i);
            printf("\n");
        }
    }
    printf("%d\n",ans);
    return 0;
}</code></pre>

<h2 id="4">4.魔术球问题<a class="headerlink" href="#4" title="Permanent link">Link</a></h2>
<p>拆点建二分图，枚举答案A，在原图上直接加点并在残量网络中直接增广，所求答案为最小路径覆盖，当最小路径覆盖≤n时均为可行解。向前取满流边输出路径</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int nex[MAX_V];
bool vis[MAX_V];

int main()
{
    int n;
    scanf("%d", &amp;n);
    int m = 0, ans = 0, s = 0, t = 10000;
    for(;;)
    {
        m ++;
        for(int i = 1; i &lt; m; i ++)
            if(sqrt(i + m) == (int)sqrt(i + m)) add(i, m + 5000, 1);
        add(s, m, 1), add(m + 5000, t, 1);
        ans += max_flow(s, t);
        if(m - ans &gt; n) break;
    }
    printf("%d\n", m - 1);
    for(int i = 1; i &lt; m; i ++) for(auto x : G[i]) if(x.cap == 0) {nex[i] = x.to - 5000; break; }
    for(int i = 1; i &lt; m; i ++)
    {
        if(vis[i]) continue;
        printf("%d", i);
        int p = nex[i];
        while(p != -5000)
        {
            vis[p] = 1;
            printf(" %d", p);
            p = nex[p];
        }
        printf("\n");
    }
    return 0;
}</code></pre>

<h2 id="5">5.  圆桌问题<a class="headerlink" href="#5" title="Permanent link">Link</a></h2>
<p>二分图多重匹配，建图跑最大流。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int main()
{
    int n, m, x, sum = 0;
    scanf("%d%d", &amp;n, &amp;m);
    int s = 0, t = n + m + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf("%d", &amp;x);
        add(s, i, x);
        sum += x;
    }
    for(int i = 1 + n; i &lt;= m + n; i ++)
    {
        scanf("%d", &amp;x);
        add(i, t, x);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1 + n; j &lt;= m + n; j ++) add(i, j, 1);
    if(sum &gt; max_flow(s, t)) return puts("0"), 0;
    puts("1");
    for(int i = 1; i &lt;= n; i ++)
    {
        bool flag = false;
        for(auto x : G[i]) if(x.cap == 0)
        {
            if(flag) printf(" ");
            flag = true;
            if(x.to != 0) printf("%d", x.to - n);
        }
        printf("\n");
    }
    return 0;
}</code></pre>

<h2 id="6">6.  最长递增子序列问题<a class="headerlink" href="#6" title="Permanent link">Link</a></h2>
<p>第一问跑n方的dp，第二问对于<code class="codehilite">f[j]=f[i]+1</code>且<code class="codehilite">a[i]&lt;a[j]</code>的点连流量为1的边跑最大流，第三问将点1和n的边改为INF跑最大流。</p>
<p>最长长度为1时后两问直接输出个数。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, k;
int a[MAX_V], f[MAX_V];

int solve1()
{
    int S = 0, T = 2 * n + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        if(f[i] == 1) add(S, i, 1);
        if(f[i] == k) add(i + n, T, 1);
        add(i, i + n, 1);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = i + 1; j &lt;= n; j ++)
            if(a[i] &lt;= a[j] &amp;&amp; f[j] == f[i] + 1) add(i + n, j, 1);
    int ans = max_flow(S, T);
    printf("%d\n", ans);
    return ans;
}

void solve2()
{
    int S = 0, T = 2 * n + 1, v;
    for(int i = S; i &lt;= T; i ++) G[i].clear();
    for(int i = 1; i &lt;= n; i ++)
    {
        v = (i == 1 || i == n) ? INF : 1;
        if(f[i] == 1) add(S, i, v);
        if(f[i] == k) add(i + n, T, v);
        add(i, i + n, v);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = i + 1; j &lt;= n; j ++)
            if(a[i] &lt;= a[j] &amp;&amp; f[j] == f[i] + 1) add(i + n, j, 1);
    printf("%d\n", max_flow(S, T));
}

int main()
{
    scanf("%d", &amp;n);
    for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]);
    for(int i = 1; i &lt;= n; i ++)
    {
        f[i] = 1;
        for(int j = 1; j &lt; i; j ++)
            if(a[i] &gt;= a[j]) f[i] = max(f[i], f[j] + 1);
        k = max(k, f[i]);
    }
    printf("%d\n", k);
    int ans = solve1();
    if(k &gt; 1) solve2();
    else printf("%d\n", ans);
    return 0;
}</code></pre>

<h2 id="7">7.试题库问题<a class="headerlink" href="#7" title="Permanent link">Link</a></h2>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1200 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int main()
{
    int n, k, t, x, sum = 0;
    scanf("%d%d", &amp;n, &amp;k);
    int S = 0, T = n + k + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf("%d", &amp;x);
        add(i + k, T, x);
        sum += x;
    }
    for(int i = 1; i &lt;= k; i ++)
    {
        scanf("%d", &amp;t);
        add(S, i, 1);
        while(t --)
        {
            scanf("%d", &amp;x);
            add(i, k + x, 1);
        }
    }
    if(max_flow(S, T) &lt; sum) return 0 * puts("No Solution!");
    for(int i = k + 1; i &lt;= k + n; i ++)
    {
        printf("%d:", i - k);
        for(auto v : G[i]) if(v.cap) printf(" %d", v.to);
        printf("\n");
    }
    return 0;
}</code></pre>

<h2 id="9">9.方格取数问题<a class="headerlink" href="#9" title="Permanent link">Link</a></h2>
<p>对方格上的点根据行列奇偶黑白染色，建二分图，黑点向四周白点连边，要求的答案是没有边相连的权值和最大的点集。</p>
<p>二分图最大点权独立集=点权和-二分图最小点权覆盖集</p>
<p>跑最大流减一下</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, m;
inline int pt(int x, int y) { return x * m + y; }

int main()
{
    int x, sum = 0;
    scanf("%d%d", &amp;n, &amp;m);
    int S = 0, T = 1001;
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m; j ++)
        {
            scanf("%d", &amp;x);
            if((i + j) % 2)
            {
                add(S, pt(i, j), x);
                if(j + 1 &lt;= m) add(pt(i, j), pt(i, j + 1), INF);
                if(j - 1 &gt; 0) add(pt(i, j), pt(i, j - 1), INF);
                if(i + 1 &lt;= n) add(pt(i, j), pt(i + 1, j), INF);
                if(i - 1 &gt; 0) add(pt(i, j), pt(i - 1, j), INF);
            }
            else add(pt(i, j), T, x);
            sum += x;
        }
    }
    printf("%d\n", sum - max_flow(S, T));
    return 0;
}</code></pre>

<h2 id="10">10.餐巾计划问题<a class="headerlink" href="#10" title="Permanent link">Link</a></h2>
<p>拆点建图，<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>表示当天可以提供的餐巾数，<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>表示当天获得的餐巾数。</p>
<p><span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>向<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>连边，流量为当天所需的总数x，费用为0，表示当天最多可以提供x个餐巾。</p>
<p><span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>向<span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>连边，流量为当天所需的总数x，费用为0，表示当天最少需要获得x个餐巾。</p>
<p><span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>向<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>连边，流量为INF，费用为<span><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span>，表示在当天购买新餐巾的花费。</p>
<p><span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>向<span><span class="MathJax_Preview">B_{i+M}</span><script type="math/tex">B_{i+M}</script></span>连边，流量为INF，费用为<span><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span>，表示在第i天经过M天的快洗可以获得餐巾。</p>
<p><span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>向<span><span class="MathJax_Preview">B_{i+N}</span><script type="math/tex">B_{i+N}</script></span>连边，流量为INF，费用为<span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>，表示在第i天经过N天的慢洗可以获得餐巾。</p>
<p>跑费用流即可。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int main()
{
    int n, P, M, F, N, S, x;
    scanf("%d%d%d%d%d%d", &amp;n, &amp;P, &amp;M, &amp;F, &amp;N, &amp;S);
    int s = 0, t = 2 * n + 1;
    ans.init(t);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf("%d", &amp;x);
        ans.addEdge(s, i * 2 - 1, x, 0);
        ans.addEdge(i * 2, t, x, 0);
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(s, i * 2, inf, P);
    for(int i = 1; i &lt; n; i ++) ans.addEdge(i * 2 - 1, i * 2 + 1, inf, 0);
    for(int i = 1; i + M &lt;= n; i ++) ans.addEdge(i * 2 - 1, (i + M) * 2, inf, F);
    for(int i = 1; i + N &lt;= n; i ++) ans.addEdge(i * 2 - 1, (i + N) * 2, inf, S);
    printf("%d\n", ans.mincostMaxFlow(s, t));
    return 0;
}</code></pre>

<h2 id="11">11.航空路线问题<a class="headerlink" href="#11" title="Permanent link">Link</a></h2>
<p>建图跑费用流，根据流量变化输出路径。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 200 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };
string name[15];

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }

    void printPath(int s, int t, int n)
    {
        cout &lt;&lt; name[1] &lt;&lt; endl;
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to &gt; x - n &amp;&amp; edges[i].flow &gt; 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    cout &lt;&lt; name[v] &lt;&lt; endl;
                    break;
                }
            }
        }
        vector&lt;int&gt; ans;
        ans.push_back(1);
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to &gt; x - n &amp;&amp; edges[i].flow &gt; 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    ans.push_back(v);
                    break;
                }
            }
        }
        for(int i = ans.size() - 2; i &gt;= 0; i --) cout &lt;&lt; name[ans[i]] &lt;&lt; endl;
    }
}ans;

int main()
{
    int n, m;
    string x, y;
    map&lt;string, int&gt; mp;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
    {
        cin &gt;&gt; x;
        mp[x] = i;
        name[i] = x;
    }
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    while(m --)
    {
        cin &gt;&gt; x &gt;&gt; y;
        int u = mp[x], v = mp[y];
        if(u &gt; v) swap(u, v);
        ans.addEdge(u + n, v, 2, 0);
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i, i + n, 1, -1);
    ans.addEdge(1, 1 + n, 1, 0);
    ans.addEdge(n, n + n, 1, 0);
    ans.addEdge(S, 1, 2, 0);
    ans.addEdge(2 * n, T, 2, 0);
    int res = -ans.mincostMaxFlow(S, T);
    if(res == 0) return 0 * puts("No Solution!");
    cout &lt;&lt; res &lt;&lt; endl;
    ans.printPath(S, T, n);
    return 0;
}</code></pre>

<h2 id="12">12.软件补丁问题<a class="headerlink" href="#12" title="Permanent link">Link</a></h2>
<p>我缓缓打出一个问号</p>
<p>这是个锤子的网络流，这是最短路啊</p>
<p>状压一下转移方案然后跑从(1&lt;&lt;n)-1到0的最短路</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = (1 &lt;&lt; 21);
const int inf = 0x3f3f3f3f;

struct node
{
    int b1, b2, f1, f2, w;
    bool check(int x) { return ((x &amp; b1) == b1) &amp;&amp; ((x &amp; b2) == 0); }
    int change(int x)
    {
        x ^= x &amp; f1;
        x |= f2;
        return x;
    }
}a[105];

int n, m, dis[maxn];

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = 0; i &lt; m; i ++) if(a[i].check(u))
        {
            int v = a[i].change(u);
            if(dis[v] &gt; dis[u] + a[i].w)
            {
                dis[v] = dis[u] + a[i].w;
                que.push({dis[v], v});
            }
        }
    }
}

int main()
{
    char s1[55], s2[55];
    scanf("%d%d", &amp;n, &amp;m);
    for(int i = 0; i &lt; m; i ++)
    {
        scanf("%d%s%s", &amp;a[i].w, s1, s2);
        for(int j = 0; j &lt; n; j ++)
        {
            if(s1[j] == '+') a[i].b1 |= (1 &lt;&lt; j);
            else if(s1[j] == '-') a[i].b2 |= (1 &lt;&lt; j);
            if(s2[j] == '-') a[i].f1 |= (1 &lt;&lt; j);
            else if(s2[j] == '+') a[i].f2 |= (1 &lt;&lt; j);
        }
    }
    dijkstra((1 &lt;&lt; n) - 1);
    printf("%d\n", dis[0] == inf ? 0 : dis[0]);
    return 0;
}</code></pre>

<h2 id="13">13.星际转移问题<a class="headerlink" href="#13" title="Permanent link">Link</a></h2>
<p>拆点建图，枚举天数。对于第i天上的点x，从i-1天的x点连容量为INF的边；并对当天的转移方案连边，每次直接在残量网络上跑最大流，总流量等于k时的天数即为答案。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int pos[105][105], x[105], t[105];

int main()
{
    int n, m, k;
    scanf("%d%d%d", &amp;n, &amp;m, &amp;k);
    for(int i = 0; i &lt; m; i ++)
    {
        scanf("%d%d", &amp;x[i], &amp;t[i]);
        for(int j = 0; j &lt; t[i]; j ++)
        {
            scanf("%d", &amp;pos[i][j]);
            pos[i][j] += 2;
        }
    }
    int S = 0, T, ans = 0;
    add(S, 2, k);
    n += 2;
    for(int tt = 1; tt &lt;= 100; tt ++)
    {
        T = tt * n + 1;
        for(int i = 0; i &lt; m; i ++)
        {
            int u = (tt - 1) % t[i], v = tt % t[i];
            u = pos[i][u], v = pos[i][v];
            add((tt - 1) * n + u, tt * n + v, x[i]);
        }
        for(int i = 1; i &lt;= n; i ++) add((tt - 1) * n + i, tt * n + i, INF);
        ans += max_flow(S, T);
        if(ans &gt;= k) return 0 * printf("%d\n", tt);
    }
    puts("0");
    return 0;
}</code></pre>

<h2 id="14">14. 孤岛营救问题<a class="headerlink" href="#14" title="Permanent link">Link</a></h2>
<p>状压+分层图最短路，代码能力丢人，调一下午</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 2e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[20*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int n, m, sum;

int pt(int x, int y, int dep)
{
    int id = (x - 1) * m + y;
    return id + dep * sum;
}

int mp[105][105], key[105][105], lim;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int p, x1, y1, x2, y2, g, k;
    scanf("%d%d%d", &amp;n, &amp;m, &amp;p);
    lim = (1 &lt;&lt; p);
    sum = n * m;
    scanf("%d", &amp;k);
    memset(head, 0xff, sizeof dis);
    while(k --)
    {
        scanf("%d%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;g);
        int u = pt(x1, y1, 0), v = pt(x2, y2, 0);
        if(g == 0) mp[u][v] = mp[v][u] = -1;
        else mp[u][v] = mp[v][u] = (1 &lt;&lt; (g - 1));
    }
    scanf("%d", &amp;k);
    while(k --)
    {
        scanf("%d%d%d", &amp;x1, &amp;y1, &amp;g);
        key[x1][y1] |= (1 &lt;&lt; (g - 1));
    }
    for(int i = 0; i &lt; lim; i ++)
    {
        for(int x = 1; x &lt;= n; x ++)
        {
            for(int y = 1; y &lt;= m; y ++)
            {
                for(int k = 0; k &lt; 4; k ++)
                {
                    int xx = x + dx[k], yy = y + dy[k];
                    if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;
                    if(mp[pt(x, y, 0)][pt(xx, yy, 0)] == -1) continue;
                    int op = mp[pt(x, y, 0)][pt(xx, yy, 0)];
                    if((op &amp; i) == op) add(pt(x, y, i), pt(xx, yy, i | key[xx][yy]), 1);
                }
            }
        }
    }
    int s = pt(1, 1, 0), t = pt(n, m, lim - 1) + 1;
    for(int i = 0; i &lt; lim; i ++) add(pt(n, m, i), t, 0);
    dijkstra(s);
    printf("%d\n", dis[t] == inf ? -1 : dis[t]);
    return 0;
}</code></pre>

<h2 id="15">15.汽车加油行驶问题<a class="headerlink" href="#15" title="Permanent link">Link</a></h2>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 5e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[2*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int p[105][105], n;

int pt(int x, int y, int dep)
{
    return (x - 1) * n + y + dep * n * n;
}

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int k, a, b, c;
    scanf("%d%d%d%d%d", &amp;n, &amp;k, &amp;a, &amp;b, &amp;c);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            scanf("%d", &amp;p[i][j]);
    int s = 0, t = pt(n, n, k) + 1;
    memset(head, 0xff, sizeof head);
    add(s, pt(1, 1, k), 0);
    for(int x = 1; x &lt;= n; x ++)
    {
        for(int y = 1; y &lt;= n; y ++)
        {
            for(int i = 0; i &lt;= k; i ++) add(pt(x, y, i), pt(x, y, k), a + c);
            for(int i = 0; i &lt; 4; i ++)
            {
                int fx = dx[i] + x, fy = dy[i] + y;
                if(fx &lt; 1 || fx &gt; n || fy &lt; 1 || fy &gt; n) continue;
                for(int j = 1; j &lt;= k; j ++)
                {
                    if(p[fx][fy])
                    {
                        if(fx &lt; x || fy &lt; y)add(pt(x, y, j), pt(fx, fy, k), a + b);
                        else add(pt(x, y, j), pt(fx, fy, k), a);
                    }
                    else
                    {
                        if(fx &lt; x || fy &lt; y) add(pt(x, y, j), pt(fx, fy, j - 1), b);
                        else add(pt(x, y, j), pt(fx, fy, j - 1), 0);
                    }
                }
            }
        }
    }
    for(int i = 0; i &lt;= k; i ++) add(pt(n, n, i), t, 0);
    dijkstra(s);
    printf("%d\n",dis[t]);
    return 0;
}</code></pre>

<h2 id="16">16.数字梯形问题<a class="headerlink" href="#16" title="Permanent link">Link</a></h2>
<p>第一问求不相交路径，拆点使i到i+n的流量为1</p>
<p>第二问点可以多次使用，把上面拆点的流量改成INF</p>
<p>第三问边也可以多次使用，把加的边的流量也改成INF，注意最下层到T的边也要改</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, p, a[55][55];

void solve1()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, 1, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, 1, 0);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

void solve3()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, inf, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, inf, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf("%d%d", &amp;n, &amp;m);
    p = (n + (n + m - 1)) * m / 2;
    for(int i = 0; i &lt; m; i ++)
        for(int j = 1; j &lt;= n + i; j ++)
            scanf("%d", &amp;a[i][j]);
    solve1();
    solve2();
    solve3();
    return 0;
}</code></pre>

<h2 id="17">17.运输问题<a class="headerlink" href="#17" title="Permanent link">Link</a></h2>
<p>二分图最大权多重匹配，无脑费用流</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, a[105], b[105], cost[105][105];

void solve1()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i &lt;= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            ans.addEdge(i, j + n, inf, -cost[i][j]);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i &lt;= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            ans.addEdge(i, j + n, inf, cost[i][j]);
    printf("%d\n", ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf("%d%d", &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;a[i]);
    for(int i = 1; i &lt;= m; i ++) scanf("%d", &amp;b[i]);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            scanf("%d", &amp;cost[i][j]);
    solve2();
    solve1();
    return 0;
}</code></pre>

<h2 id="18">18.分配问题<a class="headerlink" href="#18" title="Permanent link">Link</a></h2>
<p>二分图最大权匹配，无脑费用流*2</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, cost[105][105];

void solve1()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            ans.addEdge(i, j + n, 1, cost[i][j]);
    printf("%d\n", ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            ans.addEdge(i, j + n, 1, -cost[i][j]);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf("%d", &amp;n);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            scanf("%d", &amp;cost[i][j]);
    solve1();
    solve2();
    return 0;
}</code></pre>

<h2 id="19">19.负载平衡问题<a class="headerlink" href="#19" title="Permanent link">Link</a></h2>
<p>拆点跑费用流，<span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>向<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>连边，流量为当前点原来的大小，费用为0；<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>向<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>连边，费用为0，向<span><span class="MathJax_Preview">B_{i-1}</span><script type="math/tex">B_{i-1}</script></span>和<span><span class="MathJax_Preview">B_{i+1}</span><script type="math/tex">B_{i+1}</script></span>连边，费用为1，容量为INF;<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>向<span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>连边，流量为目标值大小，费用为0.</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 1000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;


int main()
{
    int n, sum = 0, x;
    scanf("%d", &amp;n);
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf("%d", &amp;x);
        sum += x;
        ans.addEdge(S, i, x, 0);
    }
    sum /= n;
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, inf, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i, i + n, sum, 0);
    for(int i = 1; i &lt;= n; i ++)
    {
        int x = i - 1, y = i + 1;
        if(x &lt; 1) x += n;
        if(y &gt; n) y -= n;
        ans.addEdge(i, x, inf, 1);
        ans.addEdge(i, y, inf, 1);
    }
    printf("%d\n", ans.mincostMaxFlow(S, T));
    return 0;
}</code></pre>

<h2 id="20">20.深海机器人问题<a class="headerlink" href="#20" title="Permanent link">Link</a></h2>
<p>费用流，输入格式令人D区</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int id[25][25];

int main()
{
    int a, b, p, q, k, x, y;
    scanf("%d%d%d%d", &amp;a, &amp;b, &amp;p, &amp;q);
    int tot = 0;
    p ++; q ++;
    for(int i = 1; i &lt;= p; i ++)
        for(int j = 1; j &lt;= q; j ++) id[i][j] = ++tot;
    int S = 0, T= tot + 1;
    ans.init(T);
    for(int i = 1; i &lt;= p; i ++)
    {
        for(int j = 1; j &lt; q; j ++)
        {
            scanf("%d", &amp;x);
            ans.addEdge(id[i][j], id[i][j + 1], 1, -x);
            ans.addEdge(id[i][j], id[i][j + 1], inf, 0);
        }
    }
    for(int j = 1; j &lt;= q; j ++)
    {
        for(int i = 1; i &lt; p; i ++)
        {
            scanf("%d", &amp;x);
            ans.addEdge(id[i][j], id[i + 1][j], 1, -x);
            ans.addEdge(id[i][j], id[i + 1][j], inf, 0);
        }
    }
    while(a --)
    {
        scanf("%d%d%d", &amp;k, &amp;x, &amp;y);
        ans.addEdge(S, id[x + 1][y + 1], k, 0);
    }
    while(b --)
    {
        scanf("%d%d%d", &amp;k, &amp;x, &amp;y);
        ans.addEdge(id[x + 1][y + 1], T, k, 0);
    }
    printf("%d\n", -ans.mincostMaxFlow(S, T));
    return 0;
}</code></pre>

<h2 id="21k">21.最长k可重区间集问题<a class="headerlink" href="#21k" title="Permanent link">Link</a></h2>
<p>拆点建图，超级源点<span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>向<span><span class="MathJax_Preview">S1</span><script type="math/tex">S1</script></span>连边，流量为<span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>，费用为0，表示最多取<span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>个开头的区间；<span><span class="MathJax_Preview">S1</span><script type="math/tex">S1</script></span>向<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>连边，流量为1，费用为0；<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>向<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>连边，费用为该区间权值，表示取这个区间；<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>向所有在其右侧且与它不相交的<span><span class="MathJax_Preview">A_i</span><script type="math/tex">A_i</script></span>连边，流量为1，费用为0；<span><span class="MathJax_Preview">B_i</span><script type="math/tex">B_i</script></span>向<span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>连边，流量为1，费用为0，跑<span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>到<span><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>的费用流。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int l[505], r[505], c[505];

int main()
{
    int n, k;
    scanf("%d%d", &amp;n, &amp;k);
    int S = 0, T = 2 * n + 1, S1 = T + 1;
    ans.init(S1);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf("%d%d", &amp;l[i], &amp;r[i]);
        if(l[i] &gt; r[i]) swap(l[i], r[i]);
        ans.addEdge(i, i + n, 1, -(r[i] - l[i]));
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            if(r[i] &lt;= l[j]) ans.addEdge(i + n, j, 1, 0);
    ans.addEdge(S, S1, k, 0);
    for(int i = 1; i &lt;= n; i ++)
    {
        ans.addEdge(S1, i, 1, 0);
        ans.addEdge(i + n, T, 1, 0);
    }
    printf("%d\n", -ans.mincostMaxFlow(S, T));
    return 0;
}</code></pre>

<h2 id="22k">22.最长k可重线段集问题<a class="headerlink" href="#22k" title="Permanent link">Link</a></h2>
<p>跟上一题模型其实是一样的，换了个方法。</p>
<p>把线段投影到X轴上，就转化成了区间集问题，但是因为存在<code class="codehilite">x=r</code>这样的线段，如果直接建图会产生负环，需要拆点。</p>
<p>离散化区间端点，相邻的点连边，流量为INF，费用为0；区间端点<code class="codehilite">L[i]</code>向<code class="codehilite">R[i]</code>连流量为1的边，边权为<code class="codehilite">-val[i]</code>，S和T分别向最左和最右端点连流量为k，费用为0的边。跑费用流即为答案。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

inline int dis(int x1, int y1, int x2, int y2) {
    return sqrt(1ll * (x2 - x1) * (x2 - x1) + 1ll *(y2 - y1) * (y2 - y1));
}

int n, L[505], R[505], val[505];
map&lt;int, int&gt; M;

int discretization()
{
    vector&lt;int&gt; v;
    for(int i = 1; i &lt;= n; i ++) v.push_back(L[i]), v.push_back(R[i]);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for(int i = 0; i &lt; v.size(); i ++) M[v[i]] = i + 1;
    for(int i = 1; i &lt;= n; i ++) L[i] = M[L[i]], R[i] = M[R[i]];
    return v.size();
}

int main()
{
    int k, a, b, c, d;
    scanf("%d%d", &amp;n, &amp;k);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d);
        val[i] = dis(a, b, c, d);
        L[i] = a * 2, R[i] = c * 2;
        if(L[i] &gt; R[i]) swap(L[i], R[i]);
        if(L[i] == R[i]) R[i] ++;
        else L[i] ++;
    }
    int m = discretization();
    int S = 0, T = m + 1;
    ans.init(T);
    ans.addEdge(S, 1, k, 0), ans.addEdge(m, T, k, 0);
    for(int i = 1; i &lt; m; i ++) ans.addEdge(i, i + 1, inf, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(L[i], R[i], 1, -val[i]);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
    return 0;
}</code></pre>

<h2 id="23">23.火星探险问题<a class="headerlink" href="#23" title="Permanent link">Link</a></h2>
<p>拆点跑费用流，输出路径</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

int a[50][50], id[50][50];

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }

    void printPath(int cnt, int n, int m)
    {
        int p = id[1][1];
        while(p != id[n][m])
        {
            int x = (p - 1) / m, y = (p - 1) % m;
            for(auto i : G[p + n * m])
            {
                int tmp = edges[i].to;
                int xx = (tmp - 1) / m, yy = (tmp - 1) % m;
                if(xx &lt;= x &amp;&amp; yy &lt;= y) continue;
                if(edges[i].flow &gt; 0)
                {
                    edges[i].flow --;
                    //printf("%d %d %d %d\n", edges[i].from, edges[i].to, edges[i].cap, edges[i].flow);
                    //printf("%d %d\n", xx + 1, yy + 1);
                    if(xx &gt; x) printf("%d 0\n", cnt);
                    else printf("%d 1\n", cnt);
                    p = tmp;
                    break;
                }
            }
        }
    }
}ans;

int main()
{
    int x, n, m;
    scanf("%d%d%d", &amp;x, &amp;m, &amp;n);
    int S = 0, T = 2 * n * m + 1, tot = 0;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            scanf("%d", &amp;a[i][j]), id[i][j] = ++tot;
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m; j ++)
        {
            if(i + 1 &lt;= n) ans.addEdge(id[i][j] + n * m, id[i + 1][j], inf, 0);
            if(j + 1 &lt;= m) ans.addEdge(id[i][j] + n * m, id[i][j + 1], inf, 0);
            if(a[i][j] == 0 || a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, inf, 0);
            if(a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, 1, -1);
        }
    }
    ans.addEdge(S, id[1][1], x, 0);
    ans.addEdge(id[n][m] + n * m, T, x, 0);
    ans.mincostMaxFlow(S, T);
    for(int i = 1; i &lt;= x; i ++) ans.printPath(i, n, m);
    return 0;
}</code></pre>

<h2 id="24">24.骑士共存问题<a class="headerlink" href="#24" title="Permanent link">Link</a></h2>
<p>显然所给模型是二分图，最大独立集-不可选的边即为答案。</p>
<pre class="codehilite"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 50000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, vis[205][205];

int dx[8] = {-2, -1, -2, -1, 2, 1, 2, 1};
int dy[8] = {-1, -2, 1, 2, -1, -2, 1, 2};

int id(int x, int y) { return (x - 1) * n + y; }

bool check(int x, int y) { return x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= n &amp;&amp; !vis[x][y]; }

int main()
{
    int m, u, v;
    scanf("%d%d", &amp;n, &amp;m);
    int S = 0, T = n * n + 1;
    for(int i = 0; i &lt; m; i ++)
    {
        scanf("%d%d", &amp;u, &amp;v);
        vis[u][v] = 1;
    }
    for(int x = 1; x &lt;= n; x ++)
    {
        for(int y = 1; y &lt;= n; y ++)
        {
            if(!check(x, y)) continue;
            if((x + y) % 2) add(S, id(x, y), 1);
            else add(id(x, y), T, 1);
            if((x + y) % 2 == 0) continue;
            for(int i = 0; i &lt; 8; i ++)
            {
                int fx = x + dx[i], fy = y + dy[i];
                if(check(fx, fy)) add(id(x, y), id(fx, fy), 1);
            }
        }
    }
    printf("%d\n", n * n - max_flow(S, T) - m);
    return 0;
}</code></pre>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../cf网络流版切/" title="Cf网络流版切" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Cf网络流版切
              </span>
            </div>
          </a>
        
        
          <a href="../../../badcw/Codeforces/Codeforces Round 586 (Div. 1 + Div. 2)/" title="Codeforces Round 586 (Div. 1 + Div. 2)" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Codeforces Round 586 (Div. 1 + Div. 2)
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy;  <a href="https://wiki.verly-badcw.top" target="_blank">wiki.verly-badcw.top</a>
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../../assets/javascripts/application.d151b584.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../../../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
        <script src="../../../../search/main.js"></script>
      
    
  </body>
</html>