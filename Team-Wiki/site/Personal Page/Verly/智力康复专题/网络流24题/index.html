<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://wiki.verly-badcw.top/Personal Page/Verly/智力康复专题/网络流24题/">
        <link rel="shortcut icon" href="../../../../img/favicon.ico">
        <title>网络流24题 - Team Wiki</title>
        <link href="../../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/color-brewer.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../../..">Team Wiki</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../../..">Team Wiki</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Personal Page <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">Verly</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../">Index</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#">智力康复专题</a>
    <ul class="dropdown-menu">
            
<li class="active">
    <a href="./">网络流24题</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Badcw</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#">Codeforces</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../badcw/Codeforces/Codeforces Round 586 (Div. 1 + Div. 2)/">Codeforces Round 586 (Div. 1 + Div. 2)</a>
</li>
            
<li >
    <a href="../../../badcw/Codeforces/Codeforces Round 588 (Div. 2)/">Codeforces Round 588 (Div. 2)</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">动态规划</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../badcw/动态规划/状态压缩dp的相关问题/">状态压缩dp的相关问题</a>
</li>
            
<li >
    <a href="../../../badcw/动态规划/矩阵快速幂dp/">矩阵快速幂</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#">字符串</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../badcw/字符串/kmp/">Kmp</a>
</li>
            
<li >
    <a href="../../../badcw/字符串/回文树/">回文树</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Training Logs <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">2019 Multi University Training Contest</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 1/">2019 Multi University Training Contest 1</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 2/">2019 Multi-University Training Contest 2</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019 Multi-University Training Contest/2019 Multi-University Training Contest 3/">2019 Multi University Training Contest 3</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">2019CCPC区域赛</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../Training Logs/2019CCPC区域赛/2019CCPC秦皇岛赛区（重现赛）/">2019CCPC秦皇岛赛区（重现赛）</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">2019牛客暑期多校训练营</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第一场）/">2019牛客暑期多校训练营（第一场）</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第三场）/">2019牛客暑期多校训练营（第三场）</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第二场）/">2019牛客暑期多校训练营（第二场）</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第五场）/">2019牛客暑期多校训练营（第五场）</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019牛客暑期多校训练营/2019牛客暑期多校训练营（第四场）/">2019牛客暑期多校训练营（第四场）</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">2019网络预选赛</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../Training Logs/2019网络预选赛/The Preliminary Contest for ICPC Asia Shanghai 2019/">The Preliminary Contest for ICPC Asia Shanghai 2019</a>
</li>
            
<li >
    <a href="../../../../Training Logs/2019网络预选赛/The Preliminary Contest for ICPC Asia Shenyang 2019/">The Preliminary Contest for ICPC Asia Shenyang 2019</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">2019训练赛</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../../Training Logs/2019训练赛/2017-2018 ACM-ICPC, NEERC, Northern Subregional Contest/">2017 2018 ACM ICPC, NEERC, Northern Subregional Contest</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../../">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../../../badcw/Codeforces/Codeforces Round 586 (Div. 1 + Div. 2)/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#1">1.飞行员配对方案问题</a></li>
        <li class="main "><a href="#2">2.太空飞行计划问题</a></li>
        <li class="main "><a href="#3">3.  最小路径覆盖问题</a></li>
        <li class="main "><a href="#4">4.魔术球问题</a></li>
        <li class="main "><a href="#5">5.  圆桌问题</a></li>
        <li class="main "><a href="#6">6.  最长递增子序列问题</a></li>
        <li class="main "><a href="#7">7.试题库问题</a></li>
        <li class="main "><a href="#9">9.方格取数问题</a></li>
        <li class="main "><a href="#10">10.餐巾计划问题</a></li>
        <li class="main "><a href="#11">11.航空路线问题</a></li>
        <li class="main "><a href="#12">12.软件补丁问题</a></li>
        <li class="main "><a href="#13">13.星际转移问题</a></li>
        <li class="main "><a href="#14">14. 孤岛营救问题</a></li>
        <li class="main "><a href="#15">15.汽车加油行驶问题</a></li>
        <li class="main "><a href="#16">16.数字梯形问题</a></li>
        <li class="main "><a href="#17">17.运输问题</a></li>
        <li class="main "><a href="#18">18.分配问题</a></li>
        <li class="main "><a href="#19">19.负载平衡问题</a></li>
        <li class="main "><a href="#20">20.深海机器人问题</a></li>
        <li class="main "><a href="#21k">21.最长k可重区间集问题</a></li>
        <li class="main "><a href="#22k">22.最长k可重线段集问题</a></li>
        <li class="main "><a href="#23">23.火星探险问题</a></li>
        <li class="main "><a href="#24">24.骑士共存问题</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<table>
<thead>
<tr>
<th>No</th>
<th>Problem</th>
<th>model</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>飞行员配对方案问题</td>
<td>二分图最大匹配</td>
</tr>
<tr>
<td>2</td>
<td>太空飞行计划问题</td>
<td>最大权闭合子图</td>
</tr>
<tr>
<td>3</td>
<td>最小路径覆盖问题</td>
<td>最小路径覆盖</td>
</tr>
<tr>
<td>4</td>
<td>魔术球问题</td>
<td>最小路径覆盖</td>
</tr>
<tr>
<td>5</td>
<td>圆桌问题</td>
<td>二分图多重匹配</td>
</tr>
<tr>
<td>6</td>
<td>最长递增子序列问题</td>
<td>最多不相交路径</td>
</tr>
<tr>
<td>7</td>
<td>试题库问题</td>
<td>二分图多重匹配</td>
</tr>
<tr>
<td>8</td>
<td>机器人路径规划问题</td>
<td>//////</td>
</tr>
<tr>
<td>9</td>
<td>方格取数问题</td>
<td>最大点权独立集</td>
</tr>
<tr>
<td>10</td>
<td>餐巾计划问题</td>
<td>费用流</td>
</tr>
<tr>
<td>11</td>
<td>航空路线问题</td>
<td>费用流</td>
</tr>
<tr>
<td>12</td>
<td>软件补丁问题</td>
<td>最短路径</td>
</tr>
<tr>
<td>13</td>
<td>星际转移问题</td>
<td>残量网络最大流</td>
</tr>
<tr>
<td>14</td>
<td>孤岛营救问题</td>
<td>分层图最短路</td>
</tr>
<tr>
<td>15</td>
<td>汽车加油行驶问题</td>
<td>分层图最短路</td>
</tr>
<tr>
<td>16</td>
<td>数字梯形问题</td>
<td>费用流</td>
</tr>
<tr>
<td>17</td>
<td>运输问题</td>
<td>二分图最大权多重匹配</td>
</tr>
<tr>
<td>18</td>
<td>分配问题</td>
<td>二分图最大权匹配</td>
</tr>
<tr>
<td>19</td>
<td>负载平衡问题</td>
<td>费用流</td>
</tr>
<tr>
<td>20</td>
<td>深海机器人问题</td>
<td>费用流</td>
</tr>
<tr>
<td>21</td>
<td>最长k可重区间集问题</td>
<td>最大权不相交路径</td>
</tr>
<tr>
<td>22</td>
<td>最长k可重线段集问题</td>
<td>费用流</td>
</tr>
<tr>
<td>23</td>
<td>火星探险问题</td>
<td>费用流</td>
</tr>
<tr>
<td>24</td>
<td>骑士共存问题</td>
<td>最大独立集</td>
</tr>
</tbody>
</table>
<h2 id="1">1.飞行员配对方案问题</h2>
<p>二分图最大匹配，直接建图跑最大流。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=200+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
}

int main()
{
    int n,m,u,v;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int S=0,T=n+1;
    for(int i=1;i&lt;=n;i++)
    {
        if(i&lt;=m) add(S,i,1);
        else add(i,T,1);
    }
    while(scanf(&quot;%d%d&quot;,&amp;u,&amp;v)!=EOF) add(u,v,1);
    printf(&quot;%d\n&quot;,max_flow(S,T));
    return 0;
}
</code></pre>

<h2 id="2">2.太空飞行计划问题</h2>
<p>必须选择所有左端点才能选择右端点获得收益，最大权闭合子图模型。最大权闭合子图=总权值和-最小割</p>
<p>输出方案时选择与S/T相连满流的割边。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=2500+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

int n,m;

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) break;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
    int cnt=0;
    for(int i=1;i&lt;=m;i++)
    {
        if(level[i]&gt;0)
        {
            if(cnt++) printf(&quot; &quot;);
            printf(&quot;%d&quot;,i);
        }
    }
    printf(&quot;\n&quot;);
    cnt=0;
    for(int i=1+m;i&lt;=n+m;i++)
    {
        if(level[i]&gt;0)
        {
            if(cnt++) printf(&quot; &quot;);
            printf(&quot;%d&quot;,i-m);
        }
    }
    printf(&quot;\n&quot;);
    return flow;
}

int main()
{
    int val,sum=0,a[55],b[55];
    char tools[10000];
    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
    int S=0,T=m+n+1;
    for(int i=1;i&lt;=m;i++)
    {
        scanf(&quot;%d&quot;,&amp;val);
        b[i]=val;
        sum+=val;
        add(S,i,val);
        memset(tools,0,sizeof tools);
        cin.getline(tools,10000);
        int ulen=0,tool;
        while(sscanf(tools+ulen,&quot;%d&quot;,&amp;tool)==1)
        {
            add(i,tool+m,INF);
            if(tool==0) ulen++;
            else
            {
                while(tool)
                {
                    tool/=10;
                    ulen++;
                }
            }
            ulen++;
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;val);
        add(i+m,T,val);
        a[i]=val;
    }
    printf(&quot;%d\n&quot;,sum-max_flow(S,T));
    return 0;
}
</code></pre>

<h2 id="3">3.  最小路径覆盖问题</h2>
<p>拆点求最小路径覆盖，最小路径覆盖数=|G|-二分图最大匹配数（｜Ｇ｜是有向图中的总边数）</p>
<p>输出路径：并查集维护同一路径上的点，从根节点递归向下找满流的点。</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V=400+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from,int to,int cap)
{
    G[from].push_back((edge){to,cap,G[to].size()});
    G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level,-1,sizeof(level));
    queue&lt;int&gt; que;
    level[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int v=que.front();que.pop();
        for(int i=0;i&lt;G[v].size();i++)
        {
            edge &amp;e=G[v][i];
            if(e.cap&gt;0&amp;&amp;level[e.to]&lt;0)
            {
                level[e.to]=level[v]+1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &amp;i=iter[v];i&lt;G[v].size();i++)
    {
        edge &amp;e=G[v][i];
        if(e.cap&gt;0 &amp;&amp; level[v]&lt;level[e.to])
        {
            int d=dfs(e.to,t,min(f,e.cap));
            if(d&gt;0)
            {
                e.cap-=d;
                G[e.to][e.rev].cap+=d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        bfs(s);
        if(level[t]&lt;0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(s,t,INF))&gt;0) flow+=f;
    }
}

int n;

void print(int x)
{
    for(auto e:G[x])
    {
        if(e.cap==0&amp;&amp;e.to&gt;n)
        {
            printf(&quot; %d&quot;,e.to-n);
            print(e.to-n);
        }
    }
}

int pre[400+10];

int Find(int x) {return x==pre[x]?x:pre[x]=Find(pre[x]); }

int main()
{
    int m,u,v;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    int S=0,T=2*n+1;
    for(int i=1;i&lt;=n;i++)
    {
        add(S,i,1);
        add(i+n,T,1);
    }
    for(int i=0;i&lt;m;i++)
    {
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        add(u,v+n,1);
    }
    int ans=n-max_flow(S,T);
    for(int i=S;i&lt;=T;i++) pre[i]=i;
    for(int i=1;i&lt;=n;i++)
        for(auto e:G[i])
            if(e.to&gt;n&amp;&amp;e.to&lt;T&amp;&amp;e.cap==0) pre[e.to-n]=Find(i);
    for(int i=1;i&lt;=n;i++)
    {
        if(i==Find(i))
        {
            printf(&quot;%d&quot;,i);
            print(i);
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>

<h2 id="4">4.魔术球问题</h2>
<p>拆点建二分图，枚举答案A，在原图上直接加点并在残量网络中直接增广，所求答案为最小路径覆盖，当最小路径覆盖≤n时均为可行解。向前取满流边输出路径</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int nex[MAX_V];
bool vis[MAX_V];

int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    int m = 0, ans = 0, s = 0, t = 10000;
    for(;;)
    {
        m ++;
        for(int i = 1; i &lt; m; i ++)
            if(sqrt(i + m) == (int)sqrt(i + m)) add(i, m + 5000, 1);
        add(s, m, 1), add(m + 5000, t, 1);
        ans += max_flow(s, t);
        if(m - ans &gt; n) break;
    }
    printf(&quot;%d\n&quot;, m - 1);
    for(int i = 1; i &lt; m; i ++) for(auto x : G[i]) if(x.cap == 0) {nex[i] = x.to - 5000; break; }
    for(int i = 1; i &lt; m; i ++)
    {
        if(vis[i]) continue;
        printf(&quot;%d&quot;, i);
        int p = nex[i];
        while(p != -5000)
        {
            vis[p] = 1;
            printf(&quot; %d&quot;, p);
            p = nex[p];
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

<h2 id="5">5.  圆桌问题</h2>
<p>二分图多重匹配，建图跑最大流。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int main()
{
    int n, m, x, sum = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int s = 0, t = n + m + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(s, i, x);
        sum += x;
    }
    for(int i = 1 + n; i &lt;= m + n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(i, t, x);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1 + n; j &lt;= m + n; j ++) add(i, j, 1);
    if(sum &gt; max_flow(s, t)) return puts(&quot;0&quot;), 0;
    puts(&quot;1&quot;);
    for(int i = 1; i &lt;= n; i ++)
    {
        bool flag = false;
        for(auto x : G[i]) if(x.cap == 0)
        {
            if(flag) printf(&quot; &quot;);
            flag = true;
            if(x.to != 0) printf(&quot;%d&quot;, x.to - n);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

<h2 id="6">6.  最长递增子序列问题</h2>
<p>第一问跑n方的dp，第二问对于<code>f[j]=f[i]+1</code>且<code>a[i]&lt;a[j]</code>的点连流量为1的边跑最大流，第三问将点1和n的边改为INF跑最大流。</p>
<p>最长长度为1时后两问直接输出个数。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, k;
int a[MAX_V], f[MAX_V];

int solve1()
{
    int S = 0, T = 2 * n + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        if(f[i] == 1) add(S, i, 1);
        if(f[i] == k) add(i + n, T, 1);
        add(i, i + n, 1);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = i + 1; j &lt;= n; j ++)
            if(a[i] &lt;= a[j] &amp;&amp; f[j] == f[i] + 1) add(i + n, j, 1);
    int ans = max_flow(S, T);
    printf(&quot;%d\n&quot;, ans);
    return ans;
}

void solve2()
{
    int S = 0, T = 2 * n + 1, v;
    for(int i = S; i &lt;= T; i ++) G[i].clear();
    for(int i = 1; i &lt;= n; i ++)
    {
        v = (i == 1 || i == n) ? INF : 1;
        if(f[i] == 1) add(S, i, v);
        if(f[i] == k) add(i + n, T, v);
        add(i, i + n, v);
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = i + 1; j &lt;= n; j ++)
            if(a[i] &lt;= a[j] &amp;&amp; f[j] == f[i] + 1) add(i + n, j, 1);
    printf(&quot;%d\n&quot;, max_flow(S, T));
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= n; i ++)
    {
        f[i] = 1;
        for(int j = 1; j &lt; i; j ++)
            if(a[i] &gt;= a[j]) f[i] = max(f[i], f[j] + 1);
        k = max(k, f[i]);
    }
    printf(&quot;%d\n&quot;, k);
    int ans = solve1();
    if(k &gt; 1) solve2();
    else printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>

<h2 id="7">7.试题库问题</h2>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1200 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int main()
{
    int n, k, t, x, sum = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    int S = 0, T = n + k + 1;
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(i + k, T, x);
        sum += x;
    }
    for(int i = 1; i &lt;= k; i ++)
    {
        scanf(&quot;%d&quot;, &amp;t);
        add(S, i, 1);
        while(t --)
        {
            scanf(&quot;%d&quot;, &amp;x);
            add(i, k + x, 1);
        }
    }
    if(max_flow(S, T) &lt; sum) return 0 * puts(&quot;No Solution!&quot;);
    for(int i = k + 1; i &lt;= k + n; i ++)
    {
        printf(&quot;%d:&quot;, i - k);
        for(auto v : G[i]) if(v.cap) printf(&quot; %d&quot;, v.to);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>

<h2 id="9">9.方格取数问题</h2>
<p>对方格上的点根据行列奇偶黑白染色，建二分图，黑点向四周白点连边，要求的答案是没有边相连的权值和最大的点集。</p>
<p>二分图最大点权独立集=点权和-二分图最小点权覆盖集</p>
<p>跑最大流减一下</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, m;
inline int pt(int x, int y) { return x * m + y; }

int main()
{
    int x, sum = 0;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int S = 0, T = 1001;
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m; j ++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            if((i + j) % 2)
            {
                add(S, pt(i, j), x);
                if(j + 1 &lt;= m) add(pt(i, j), pt(i, j + 1), INF);
                if(j - 1 &gt; 0) add(pt(i, j), pt(i, j - 1), INF);
                if(i + 1 &lt;= n) add(pt(i, j), pt(i + 1, j), INF);
                if(i - 1 &gt; 0) add(pt(i, j), pt(i - 1, j), INF);
            }
            else add(pt(i, j), T, x);
            sum += x;
        }
    }
    printf(&quot;%d\n&quot;, sum - max_flow(S, T));
    return 0;
}
</code></pre>

<h2 id="10">10.餐巾计划问题</h2>
<p>拆点建图，$A_i$表示当天可以提供的餐巾数，$B_i$表示当天获得的餐巾数。</p>
<p>$S$向$A_i$连边，流量为当天所需的总数x，费用为0，表示当天最多可以提供x个餐巾。</p>
<p>$B_i$向$T$连边，流量为当天所需的总数x，费用为0，表示当天最少需要获得x个餐巾。</p>
<p>$S$向$B_i$连边，流量为INF，费用为$P$，表示在当天购买新餐巾的花费。</p>
<p>$A_i$向$B_{i+M}$连边，流量为INF，费用为$F$，表示在第i天经过M天的快洗可以获得餐巾。</p>
<p>$A_i$向$B_{i+N}$连边，流量为INF，费用为$S$，表示在第i天经过N天的慢洗可以获得餐巾。</p>
<p>跑费用流即可。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int main()
{
    int n, P, M, F, N, S, x;
    scanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;P, &amp;M, &amp;F, &amp;N, &amp;S);
    int s = 0, t = 2 * n + 1;
    ans.init(t);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        ans.addEdge(s, i * 2 - 1, x, 0);
        ans.addEdge(i * 2, t, x, 0);
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(s, i * 2, inf, P);
    for(int i = 1; i &lt; n; i ++) ans.addEdge(i * 2 - 1, i * 2 + 1, inf, 0);
    for(int i = 1; i + M &lt;= n; i ++) ans.addEdge(i * 2 - 1, (i + M) * 2, inf, F);
    for(int i = 1; i + N &lt;= n; i ++) ans.addEdge(i * 2 - 1, (i + N) * 2, inf, S);
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(s, t));
    return 0;
}
</code></pre>

<h2 id="11">11.航空路线问题</h2>
<p>建图跑费用流，根据流量变化输出路径。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 200 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };
string name[15];

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }

    void printPath(int s, int t, int n)
    {
        cout &lt;&lt; name[1] &lt;&lt; endl;
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to &gt; x - n &amp;&amp; edges[i].flow &gt; 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    cout &lt;&lt; name[v] &lt;&lt; endl;
                    break;
                }
            }
        }
        vector&lt;int&gt; ans;
        ans.push_back(1);
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to &gt; x - n &amp;&amp; edges[i].flow &gt; 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    ans.push_back(v);
                    break;
                }
            }
        }
        for(int i = ans.size() - 2; i &gt;= 0; i --) cout &lt;&lt; name[ans[i]] &lt;&lt; endl;
    }
}ans;

int main()
{
    int n, m;
    string x, y;
    map&lt;string, int&gt; mp;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
    {
        cin &gt;&gt; x;
        mp[x] = i;
        name[i] = x;
    }
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    while(m --)
    {
        cin &gt;&gt; x &gt;&gt; y;
        int u = mp[x], v = mp[y];
        if(u &gt; v) swap(u, v);
        ans.addEdge(u + n, v, 2, 0);
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i, i + n, 1, -1);
    ans.addEdge(1, 1 + n, 1, 0);
    ans.addEdge(n, n + n, 1, 0);
    ans.addEdge(S, 1, 2, 0);
    ans.addEdge(2 * n, T, 2, 0);
    int res = -ans.mincostMaxFlow(S, T);
    if(res == 0) return 0 * puts(&quot;No Solution!&quot;);
    cout &lt;&lt; res &lt;&lt; endl;
    ans.printPath(S, T, n);
    return 0;
}
</code></pre>

<h2 id="12">12.软件补丁问题</h2>
<p>我缓缓打出一个问号</p>
<p>这是个锤子的网络流，这是最短路啊</p>
<p>状压一下转移方案然后跑从(1&lt;&lt;n)-1到0的最短路</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = (1 &lt;&lt; 21);
const int inf = 0x3f3f3f3f;

struct node
{
    int b1, b2, f1, f2, w;
    bool check(int x) { return ((x &amp; b1) == b1) &amp;&amp; ((x &amp; b2) == 0); }
    int change(int x)
    {
        x ^= x &amp; f1;
        x |= f2;
        return x;
    }
}a[105];

int n, m, dis[maxn];

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = 0; i &lt; m; i ++) if(a[i].check(u))
        {
            int v = a[i].change(u);
            if(dis[v] &gt; dis[u] + a[i].w)
            {
                dis[v] = dis[u] + a[i].w;
                que.push({dis[v], v});
            }
        }
    }
}

int main()
{
    char s1[55], s2[55];
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 0; i &lt; m; i ++)
    {
        scanf(&quot;%d%s%s&quot;, &amp;a[i].w, s1, s2);
        for(int j = 0; j &lt; n; j ++)
        {
            if(s1[j] == '+') a[i].b1 |= (1 &lt;&lt; j);
            else if(s1[j] == '-') a[i].b2 |= (1 &lt;&lt; j);
            if(s2[j] == '-') a[i].f1 |= (1 &lt;&lt; j);
            else if(s2[j] == '+') a[i].f2 |= (1 &lt;&lt; j);
        }
    }
    dijkstra((1 &lt;&lt; n) - 1);
    printf(&quot;%d\n&quot;, dis[0] == inf ? 0 : dis[0]);
    return 0;
}
</code></pre>

<h2 id="13">13.星际转移问题</h2>
<p>拆点建图，枚举天数。对于第i天上的点x，从i-1天的x点连容量为INF的边；并对当天的转移方案连边，每次直接在残量网络上跑最大流，总流量等于k时的天数即为答案。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int pos[105][105], x[105], t[105];

int main()
{
    int n, m, k;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
    for(int i = 0; i &lt; m; i ++)
    {
        scanf(&quot;%d%d&quot;, &amp;x[i], &amp;t[i]);
        for(int j = 0; j &lt; t[i]; j ++)
        {
            scanf(&quot;%d&quot;, &amp;pos[i][j]);
            pos[i][j] += 2;
        }
    }
    int S = 0, T, ans = 0;
    add(S, 2, k);
    n += 2;
    for(int tt = 1; tt &lt;= 100; tt ++)
    {
        T = tt * n + 1;
        for(int i = 0; i &lt; m; i ++)
        {
            int u = (tt - 1) % t[i], v = tt % t[i];
            u = pos[i][u], v = pos[i][v];
            add((tt - 1) * n + u, tt * n + v, x[i]);
        }
        for(int i = 1; i &lt;= n; i ++) add((tt - 1) * n + i, tt * n + i, INF);
        ans += max_flow(S, T);
        if(ans &gt;= k) return 0 * printf(&quot;%d\n&quot;, tt);
    }
    puts(&quot;0&quot;);
    return 0;
}
</code></pre>

<h2 id="14">14. 孤岛营救问题</h2>
<p>状压+分层图最短路，代码能力丢人，调一下午</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 2e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[20*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int n, m, sum;

int pt(int x, int y, int dep)
{
    int id = (x - 1) * m + y;
    return id + dep * sum;
}

int mp[105][105], key[105][105], lim;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int p, x1, y1, x2, y2, g, k;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p);
    lim = (1 &lt;&lt; p);
    sum = n * m;
    scanf(&quot;%d&quot;, &amp;k);
    memset(head, 0xff, sizeof dis);
    while(k --)
    {
        scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;g);
        int u = pt(x1, y1, 0), v = pt(x2, y2, 0);
        if(g == 0) mp[u][v] = mp[v][u] = -1;
        else mp[u][v] = mp[v][u] = (1 &lt;&lt; (g - 1));
    }
    scanf(&quot;%d&quot;, &amp;k);
    while(k --)
    {
        scanf(&quot;%d%d%d&quot;, &amp;x1, &amp;y1, &amp;g);
        key[x1][y1] |= (1 &lt;&lt; (g - 1));
    }
    for(int i = 0; i &lt; lim; i ++)
    {
        for(int x = 1; x &lt;= n; x ++)
        {
            for(int y = 1; y &lt;= m; y ++)
            {
                for(int k = 0; k &lt; 4; k ++)
                {
                    int xx = x + dx[k], yy = y + dy[k];
                    if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;
                    if(mp[pt(x, y, 0)][pt(xx, yy, 0)] == -1) continue;
                    int op = mp[pt(x, y, 0)][pt(xx, yy, 0)];
                    if((op &amp; i) == op) add(pt(x, y, i), pt(xx, yy, i | key[xx][yy]), 1);
                }
            }
        }
    }
    int s = pt(1, 1, 0), t = pt(n, m, lim - 1) + 1;
    for(int i = 0; i &lt; lim; i ++) add(pt(n, m, i), t, 0);
    dijkstra(s);
    printf(&quot;%d\n&quot;, dis[t] == inf ? -1 : dis[t]);
    return 0;
}
</code></pre>

<h2 id="15">15.汽车加油行驶问题</h2>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 5e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[2*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w &lt; dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int p[105][105], n;

int pt(int x, int y, int dep)
{
    return (x - 1) * n + y + dep * n * n;
}

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int k, a, b, c;
    scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;k, &amp;a, &amp;b, &amp;c);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            scanf(&quot;%d&quot;, &amp;p[i][j]);
    int s = 0, t = pt(n, n, k) + 1;
    memset(head, 0xff, sizeof head);
    add(s, pt(1, 1, k), 0);
    for(int x = 1; x &lt;= n; x ++)
    {
        for(int y = 1; y &lt;= n; y ++)
        {
            for(int i = 0; i &lt;= k; i ++) add(pt(x, y, i), pt(x, y, k), a + c);
            for(int i = 0; i &lt; 4; i ++)
            {
                int fx = dx[i] + x, fy = dy[i] + y;
                if(fx &lt; 1 || fx &gt; n || fy &lt; 1 || fy &gt; n) continue;
                for(int j = 1; j &lt;= k; j ++)
                {
                    if(p[fx][fy])
                    {
                        if(fx &lt; x || fy &lt; y)add(pt(x, y, j), pt(fx, fy, k), a + b);
                        else add(pt(x, y, j), pt(fx, fy, k), a);
                    }
                    else
                    {
                        if(fx &lt; x || fy &lt; y) add(pt(x, y, j), pt(fx, fy, j - 1), b);
                        else add(pt(x, y, j), pt(fx, fy, j - 1), 0);
                    }
                }
            }
        }
    }
    for(int i = 0; i &lt;= k; i ++) add(pt(n, n, i), t, 0);
    dijkstra(s);
    printf(&quot;%d\n&quot;,dis[t]);
    return 0;
}
</code></pre>

<h2 id="16">16.数字梯形问题</h2>
<p>第一问求不相交路径，拆点使i到i+n的流量为1</p>
<p>第二问点可以多次使用，把上面拆点的流量改成INF</p>
<p>第三问边也可以多次使用，把加的边的流量也改成INF，注意最下层到T的边也要改</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, p, a[55][55];

void solve1()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, 1, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, 1, 0);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

void solve3()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i &lt; m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j &lt;= i + n; j ++)
        {
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j, inf, -a[i + 1][j]);
            if(i + 1 &lt; m) ans.addEdge(tp + p + j, tp1 + j + 1, inf, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i &lt;= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    p = (n + (n + m - 1)) * m / 2;
    for(int i = 0; i &lt; m; i ++)
        for(int j = 1; j &lt;= n + i; j ++)
            scanf(&quot;%d&quot;, &amp;a[i][j]);
    solve1();
    solve2();
    solve3();
    return 0;
}
</code></pre>

<h2 id="17">17.运输问题</h2>
<p>二分图最大权多重匹配，无脑费用流</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, a[105], b[105], cost[105][105];

void solve1()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i &lt;= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            ans.addEdge(i, j + n, inf, -cost[i][j]);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i &lt;= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            ans.addEdge(i, j + n, inf, cost[i][j]);
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= m; i ++) scanf(&quot;%d&quot;, &amp;b[i]);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            scanf(&quot;%d&quot;, &amp;cost[i][j]);
    solve2();
    solve1();
    return 0;
}
</code></pre>

<h2 id="18">18.分配问题</h2>
<p>二分图最大权匹配，无脑费用流*2</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, cost[105][105];

void solve1()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            ans.addEdge(i, j + n, 1, cost[i][j]);
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            ans.addEdge(i, j + n, 1, -cost[i][j]);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            scanf(&quot;%d&quot;, &amp;cost[i][j]);
    solve1();
    solve2();
    return 0;
}
</code></pre>

<h2 id="19">19.负载平衡问题</h2>
<p>拆点跑费用流，$S$向$A_i$连边，流量为当前点原来的大小，费用为0；$A_i$向$B_i$连边，费用为0，向$B_{i-1}$和$B_{i+1}$连边，费用为1，容量为INF;$B_i$向$T$连边，流量为目标值大小，费用为0.</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 1000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;


int main()
{
    int n, sum = 0, x;
    scanf(&quot;%d&quot;, &amp;n);
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        sum += x;
        ans.addEdge(S, i, x, 0);
    }
    sum /= n;
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i + n, T, inf, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(i, i + n, sum, 0);
    for(int i = 1; i &lt;= n; i ++)
    {
        int x = i - 1, y = i + 1;
        if(x &lt; 1) x += n;
        if(y &gt; n) y -= n;
        ans.addEdge(i, x, inf, 1);
        ans.addEdge(i, y, inf, 1);
    }
    printf(&quot;%d\n&quot;, ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="20">20.深海机器人问题</h2>
<p>费用流，输入格式令人D区</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int id[25][25];

int main()
{
    int a, b, p, q, k, x, y;
    scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;p, &amp;q);
    int tot = 0;
    p ++; q ++;
    for(int i = 1; i &lt;= p; i ++)
        for(int j = 1; j &lt;= q; j ++) id[i][j] = ++tot;
    int S = 0, T= tot + 1;
    ans.init(T);
    for(int i = 1; i &lt;= p; i ++)
    {
        for(int j = 1; j &lt; q; j ++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            ans.addEdge(id[i][j], id[i][j + 1], 1, -x);
            ans.addEdge(id[i][j], id[i][j + 1], inf, 0);
        }
    }
    for(int j = 1; j &lt;= q; j ++)
    {
        for(int i = 1; i &lt; p; i ++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            ans.addEdge(id[i][j], id[i + 1][j], 1, -x);
            ans.addEdge(id[i][j], id[i + 1][j], inf, 0);
        }
    }
    while(a --)
    {
        scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y);
        ans.addEdge(S, id[x + 1][y + 1], k, 0);
    }
    while(b --)
    {
        scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y);
        ans.addEdge(id[x + 1][y + 1], T, k, 0);
    }
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="21k">21.最长k可重区间集问题</h2>
<p>拆点建图，超级源点$S$向$S1$连边，流量为$k$，费用为0，表示最多取$k$个开头的区间；$S1$向$A_i$连边，流量为1，费用为0；$A_i$向$B_i$连边，费用为该区间权值，表示取这个区间；$B_i$向所有在其右侧且与它不相交的$A_i$连边，流量为1，费用为0；$B_i$向$T$连边，流量为1，费用为0，跑$S$到$T$的费用流。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int l[505], r[505], c[505];

int main()
{
    int n, k;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    int S = 0, T = 2 * n + 1, S1 = T + 1;
    ans.init(S1);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]);
        if(l[i] &gt; r[i]) swap(l[i], r[i]);
        ans.addEdge(i, i + n, 1, -(r[i] - l[i]));
    }
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= n; j ++)
            if(r[i] &lt;= l[j]) ans.addEdge(i + n, j, 1, 0);
    ans.addEdge(S, S1, k, 0);
    for(int i = 1; i &lt;= n; i ++)
    {
        ans.addEdge(S1, i, 1, 0);
        ans.addEdge(i + n, T, 1, 0);
    }
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="22k">22.最长k可重线段集问题</h2>
<p>跟上一题模型其实是一样的，换了个方法。</p>
<p>把线段投影到X轴上，就转化成了区间集问题，但是因为存在<code>x=r</code>这样的线段，如果直接建图会产生负环，需要拆点。</p>
<p>离散化区间端点，相邻的点连边，流量为INF，费用为0；区间端点<code>L[i]</code>向<code>R[i]</code>连流量为1的边，边权为<code>-val[i]</code>，S和T分别向最左和最右端点连流量为k，费用为0的边。跑费用流即为答案。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

inline int dis(int x1, int y1, int x2, int y2) {
    return sqrt(1ll * (x2 - x1) * (x2 - x1) + 1ll *(y2 - y1) * (y2 - y1));
}

int n, L[505], R[505], val[505];
map&lt;int, int&gt; M;

int discretization()
{
    vector&lt;int&gt; v;
    for(int i = 1; i &lt;= n; i ++) v.push_back(L[i]), v.push_back(R[i]);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for(int i = 0; i &lt; v.size(); i ++) M[v[i]] = i + 1;
    for(int i = 1; i &lt;= n; i ++) L[i] = M[L[i]], R[i] = M[R[i]];
    return v.size();
}

int main()
{
    int k, a, b, c, d;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
    for(int i = 1; i &lt;= n; i ++)
    {
        scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
        val[i] = dis(a, b, c, d);
        L[i] = a * 2, R[i] = c * 2;
        if(L[i] &gt; R[i]) swap(L[i], R[i]);
        if(L[i] == R[i]) R[i] ++;
        else L[i] ++;
    }
    int m = discretization();
    int S = 0, T = m + 1;
    ans.init(T);
    ans.addEdge(S, 1, k, 0), ans.addEdge(m, T, k, 0);
    for(int i = 1; i &lt; m; i ++) ans.addEdge(i, i + 1, inf, 0);
    for(int i = 1; i &lt;= n; i ++) ans.addEdge(L[i], R[i], 1, -val[i]);
    printf(&quot;%d\n&quot;, -ans.mincostMaxFlow(S, T));
    return 0;
}
</code></pre>

<h2 id="23">23.火星探险问题</h2>
<p>拆点跑费用流，输出路径</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

int a[50][50], id[50][50];

struct MCMF
{
    int n, m;
    vector&lt;Edge&gt; edges;
    vector&lt;int&gt; G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this-&gt;n = n;
        for(int i = 0;i &lt;= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int&amp; flow, int&amp; cost)
    {
        for(int i = 0; i&lt;= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue&lt;int&gt; Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i &lt; G[u].size(); i++)
            {
                Edge&amp; e = edges[G[u][i]];
                if(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }

    void printPath(int cnt, int n, int m)
    {
        int p = id[1][1];
        while(p != id[n][m])
        {
            int x = (p - 1) / m, y = (p - 1) % m;
            for(auto i : G[p + n * m])
            {
                int tmp = edges[i].to;
                int xx = (tmp - 1) / m, yy = (tmp - 1) % m;
                if(xx &lt;= x &amp;&amp; yy &lt;= y) continue;
                if(edges[i].flow &gt; 0)
                {
                    edges[i].flow --;
                    //printf(&quot;%d %d %d %d\n&quot;, edges[i].from, edges[i].to, edges[i].cap, edges[i].flow);
                    //printf(&quot;%d %d\n&quot;, xx + 1, yy + 1);
                    if(xx &gt; x) printf(&quot;%d 0\n&quot;, cnt);
                    else printf(&quot;%d 1\n&quot;, cnt);
                    p = tmp;
                    break;
                }
            }
        }
    }
}ans;

int main()
{
    int x, n, m;
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;m, &amp;n);
    int S = 0, T = 2 * n * m + 1, tot = 0;
    ans.init(T);
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++)
            scanf(&quot;%d&quot;, &amp;a[i][j]), id[i][j] = ++tot;
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m; j ++)
        {
            if(i + 1 &lt;= n) ans.addEdge(id[i][j] + n * m, id[i + 1][j], inf, 0);
            if(j + 1 &lt;= m) ans.addEdge(id[i][j] + n * m, id[i][j + 1], inf, 0);
            if(a[i][j] == 0 || a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, inf, 0);
            if(a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, 1, -1);
        }
    }
    ans.addEdge(S, id[1][1], x, 0);
    ans.addEdge(id[n][m] + n * m, T, x, 0);
    ans.mincostMaxFlow(S, T);
    for(int i = 1; i &lt;= x; i ++) ans.printPath(i, n, m);
    return 0;
}
</code></pre>

<h2 id="24">24.骑士共存问题</h2>
<p>显然所给模型是二分图，最大独立集-不可选的边即为答案。</p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

const int MAX_V = 50000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector&lt;edge&gt; G[MAX_V];  //图的邻接表表示
int level[MAX_V];   //顶点到源点的距离标号
int iter[MAX_V];    //当前弧

void add(int from, int to, int cap)
{
    G[from].push_back((edge){to, cap, G[to].size()});
    G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
    memset(level, -1, sizeof(level));
    queue&lt;int&gt; que;
    level[s] = 0;
    que.push(s);
    while(!que.empty())
    {
        int v = que.front(); que.pop();
        for(int i = 0; i &lt; G[v].size(); i++)
        {
            edge &amp;e = G[v][i];
            if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0)
            {
                level[e.to] = level[v] + 1;
                que.push(e.to);
            }
        }
    }
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
    if(v == t) return f;
    for(int &amp;i = iter[v]; i&lt;G[v].size(); i++)
    {
        edge &amp;e = G[v][i];
        if(e.cap &gt; 0 &amp;&amp; level[v] &lt; level[e.to])
        {
            int d = dfs(e.to, t, min(f, e.cap));
            if(d &gt; 0)
            {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
    int flow = 0;
    for(;;)
    {
        bfs(s);
        if(level[t] &lt; 0) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while((f = dfs(s,t,INF)) &gt; 0) flow += f;
    }
}

int n, vis[205][205];

int dx[8] = {-2, -1, -2, -1, 2, 1, 2, 1};
int dy[8] = {-1, -2, 1, 2, -1, -2, 1, 2};

int id(int x, int y) { return (x - 1) * n + y; }

bool check(int x, int y) { return x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= n &amp;&amp; !vis[x][y]; }

int main()
{
    int m, u, v;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    int S = 0, T = n * n + 1;
    for(int i = 0; i &lt; m; i ++)
    {
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        vis[u][v] = 1;
    }
    for(int x = 1; x &lt;= n; x ++)
    {
        for(int y = 1; y &lt;= n; y ++)
        {
            if(!check(x, y)) continue;
            if((x + y) % 2) add(S, id(x, y), 1);
            else add(id(x, y), T, 1);
            if((x + y) % 2 == 0) continue;
            for(int i = 0; i &lt; 8; i ++)
            {
                int fx = x + dx[i], fy = y + dy[i];
                if(check(fx, fy)) add(id(x, y), id(fx, fy), 1);
            }
        }
    }
    printf(&quot;%d\n&quot;, n * n - max_flow(S, T) - m);
    return 0;
}
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
        <script src="../../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
