| No   | Problem             | model                |
| ---- | ------------------- | -------------------- |
| 1    | 飞行员配对方案问题  | 二分图最大匹配       |
| 2    | 太空飞行计划问题    | 最大权闭合子图       |
| 3    | 最小路径覆盖问题    | 最小路径覆盖         |
| 4    | 魔术球问题          | 最小路径覆盖         |
| 5    | 圆桌问题            | 二分图多重匹配       |
| 6    | 最长递增子序列问题  | 最多不相交路径       |
| 7    | 试题库问题          | 二分图多重匹配       |
| 8    | 机器人路径规划问题  | //////               |
| 9    | 方格取数问题        | 最大点权独立集       |
| 10   | 餐巾计划问题        | 费用流               |
| 11   | 航空路线问题        | 费用流               |
| 12   | 软件补丁问题        | 最短路径             |
| 13   | 星际转移问题        | 残量网络最大流       |
| 14   | 孤岛营救问题        | 分层图最短路         |
| 15   | 汽车加油行驶问题    | 分层图最短路         |
| 16   | 数字梯形问题        | 费用流               |
| 17   | 运输问题            | 二分图最大权多重匹配 |
| 18   | 分配问题            | 二分图最大权匹配     |
| 19   | 负载平衡问题        | 费用流               |
| 20   | 深海机器人问题      | 费用流               |
| 21   | 最长k可重区间集问题 | 最大权不相交路径     |
| 22   | 最长k可重线段集问题 | 费用流               |
| 23   | 火星探险问题        | 费用流               |
| 24   | 骑士共存问题        | 最大独立集           |

## 1.飞行员配对方案问题

二分图最大匹配，直接建图跑最大流。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAX_V=200+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from,int to,int cap)
{
	G[from].push_back((edge){to,cap,G[to].size()});
	G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level,-1,sizeof(level));
	queue<int> que;
	level[s]=0;
	que.push(s);
	while(!que.empty())
	{
		int v=que.front();que.pop();
		for(int i=0;i<G[v].size();i++)
		{
			edge &e=G[v][i];
			if(e.cap>0&&level[e.to]<0)
			{
				level[e.to]=level[v]+1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
	if(v==t) return f;
	for(int &i=iter[v];i<G[v].size();i++)
	{
		edge &e=G[v][i];
		if(e.cap>0 && level[v]<level[e.to])
		{
			int d=dfs(e.to,t,min(f,e.cap));
			if(d>0)
			{
				e.cap-=d;
				G[e.to][e.rev].cap+=d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s,int t)
{
	int flow=0;
	for(;;)
	{
		bfs(s);
		if(level[t]<0) return flow;
		memset(iter,0,sizeof(iter));
		int f;
		while((f=dfs(s,t,INF))>0) flow+=f;
	}
}

int main()
{
    int n,m,u,v;
    scanf("%d%d",&n,&m);
    int S=0,T=n+1;
    for(int i=1;i<=n;i++)
    {
        if(i<=m) add(S,i,1);
        else add(i,T,1);
    }
    while(scanf("%d%d",&u,&v)!=EOF) add(u,v,1);
    printf("%d\n",max_flow(S,T));
    return 0;
}
```

## 2.太空飞行计划问题

必须选择所有左端点才能选择右端点获得收益，最大权闭合子图模型。最大权闭合子图=总权值和-最小割

输出方案时选择与S/T相连满流的割边。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAX_V=2500+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from,int to,int cap)
{
	G[from].push_back((edge){to,cap,G[to].size()});
	G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level,-1,sizeof(level));
	queue<int> que;
	level[s]=0;
	que.push(s);
	while(!que.empty())
	{
		int v=que.front();que.pop();
		for(int i=0;i<G[v].size();i++)
		{
			edge &e=G[v][i];
			if(e.cap>0&&level[e.to]<0)
			{
				level[e.to]=level[v]+1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
	if(v==t) return f;
	for(int &i=iter[v];i<G[v].size();i++)
	{
		edge &e=G[v][i];
		if(e.cap>0 && level[v]<level[e.to])
		{
			int d=dfs(e.to,t,min(f,e.cap));
			if(d>0)
			{
				e.cap-=d;
				G[e.to][e.rev].cap+=d;
				return d;
			}
		}
	}
	return 0;
}

int n,m;

//求解从s到t的最大流
int max_flow(int s,int t)
{
	int flow=0;
	for(;;)
	{
		bfs(s);
		if(level[t]<0) break;
		memset(iter,0,sizeof(iter));
		int f;
		while((f=dfs(s,t,INF))>0) flow+=f;
	}
	int cnt=0;
	for(int i=1;i<=m;i++)
    {
        if(level[i]>0)
        {
            if(cnt++) printf(" ");
            printf("%d",i);
        }
    }
    printf("\n");
    cnt=0;
    for(int i=1+m;i<=n+m;i++)
    {
        if(level[i]>0)
        {
            if(cnt++) printf(" ");
            printf("%d",i-m);
        }
    }
    printf("\n");
    return flow;
}

int main()
{
    int val,sum=0,a[55],b[55];
    char tools[10000];
    scanf("%d%d",&m,&n);
    int S=0,T=m+n+1;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&val);
        b[i]=val;
        sum+=val;
        add(S,i,val);
        memset(tools,0,sizeof tools);
        cin.getline(tools,10000);
        int ulen=0,tool;
        while(sscanf(tools+ulen,"%d",&tool)==1)
        {
            add(i,tool+m,INF);
            if(tool==0) ulen++;
            else
            {
                while(tool)
                {
                    tool/=10;
                    ulen++;
                }
            }
            ulen++;
        }
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&val);
        add(i+m,T,val);
        a[i]=val;
    }
    printf("%d\n",sum-max_flow(S,T));
    return 0;
}
```

## 3.  最小路径覆盖问题

拆点求最小路径覆盖，最小路径覆盖数=|G|-二分图最大匹配数（｜Ｇ｜是有向图中的总边数）

输出路径：并查集维护同一路径上的点，从根节点递归向下找满流的点。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAX_V=400+10;
const int INF=0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to,cap,rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from,int to,int cap)
{
	G[from].push_back((edge){to,cap,G[to].size()});
	G[to].push_back((edge){from,0,G[from].size()-1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level,-1,sizeof(level));
	queue<int> que;
	level[s]=0;
	que.push(s);
	while(!que.empty())
	{
		int v=que.front();que.pop();
		for(int i=0;i<G[v].size();i++)
		{
			edge &e=G[v][i];
			if(e.cap>0&&level[e.to]<0)
			{
				level[e.to]=level[v]+1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v,int t,int f)
{
	if(v==t) return f;
	for(int &i=iter[v];i<G[v].size();i++)
	{
		edge &e=G[v][i];
		if(e.cap>0 && level[v]<level[e.to])
		{
			int d=dfs(e.to,t,min(f,e.cap));
			if(d>0)
			{
				e.cap-=d;
				G[e.to][e.rev].cap+=d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s,int t)
{
	int flow=0;
	for(;;)
	{
		bfs(s);
		if(level[t]<0) return flow;
		memset(iter,0,sizeof(iter));
		int f;
		while((f=dfs(s,t,INF))>0) flow+=f;
	}
}

int n;

void print(int x)
{
    for(auto e:G[x])
    {
        if(e.cap==0&&e.to>n)
        {
            printf(" %d",e.to-n);
            print(e.to-n);
        }
    }
}

int pre[400+10];

int Find(int x) {return x==pre[x]?x:pre[x]=Find(pre[x]); }

int main()
{
    int m,u,v;
    scanf("%d%d",&n,&m);
    int S=0,T=2*n+1;
    for(int i=1;i<=n;i++)
    {
        add(S,i,1);
        add(i+n,T,1);
    }
    for(int i=0;i<m;i++)
    {
        scanf("%d%d",&u,&v);
        add(u,v+n,1);
    }
    int ans=n-max_flow(S,T);
    for(int i=S;i<=T;i++) pre[i]=i;
    for(int i=1;i<=n;i++)
        for(auto e:G[i])
            if(e.to>n&&e.to<T&&e.cap==0) pre[e.to-n]=Find(i);
    for(int i=1;i<=n;i++)
    {
        if(i==Find(i))
        {
            printf("%d",i);
            print(i);
            printf("\n");
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

## 4.魔术球问题

拆点建二分图，枚举答案A，在原图上直接加点并在残量网络中直接增广，所求答案为最小路径覆盖，当最小路径覆盖≤n时均为可行解。向前取满流边输出路径

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int nex[MAX_V];
bool vis[MAX_V];

int main()
{
    int n;
    scanf("%d", &n);
    int m = 0, ans = 0, s = 0, t = 10000;
    for(;;)
    {
        m ++;
        for(int i = 1; i < m; i ++)
            if(sqrt(i + m) == (int)sqrt(i + m)) add(i, m + 5000, 1);
        add(s, m, 1), add(m + 5000, t, 1);
        ans += max_flow(s, t);
        if(m - ans > n) break;
    }
    printf("%d\n", m - 1);
    for(int i = 1; i < m; i ++) for(auto x : G[i]) if(x.cap == 0) {nex[i] = x.to - 5000; break; }
    for(int i = 1; i < m; i ++)
    {
        if(vis[i]) continue;
        printf("%d", i);
        int p = nex[i];
        while(p != -5000)
        {
            vis[p] = 1;
            printf(" %d", p);
            p = nex[p];
        }
        printf("\n");
    }
    return 0;
}
```

## 5.  圆桌问题

二分图多重匹配，建图跑最大流。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int main()
{
    int n, m, x, sum = 0;
    scanf("%d%d", &n, &m);
    int s = 0, t = n + m + 1;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &x);
        add(s, i, x);
        sum += x;
    }
    for(int i = 1 + n; i <= m + n; i ++)
    {
        scanf("%d", &x);
        add(i, t, x);
    }
    for(int i = 1; i <= n; i ++)
        for(int j = 1 + n; j <= m + n; j ++) add(i, j, 1);
    if(sum > max_flow(s, t)) return puts("0"), 0;
    puts("1");
    for(int i = 1; i <= n; i ++)
    {
        bool flag = false;
        for(auto x : G[i]) if(x.cap == 0)
        {
            if(flag) printf(" ");
            flag = true;
            if(x.to != 0) printf("%d", x.to - n);
        }
        printf("\n");
    }
    return 0;
}
```

## 6.  最长递增子序列问题

第一问跑n方的dp，第二问对于`f[j]=f[i]+1`且`a[i]<a[j]`的点连流量为1的边跑最大流，第三问将点1和n的边改为INF跑最大流。

最长长度为1时后两问直接输出个数。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int n, k;
int a[MAX_V], f[MAX_V];

int solve1()
{
    int S = 0, T = 2 * n + 1;
    for(int i = 1; i <= n; i ++)
    {
        if(f[i] == 1) add(S, i, 1);
        if(f[i] == k) add(i + n, T, 1);
        add(i, i + n, 1);
    }
    for(int i = 1; i <= n; i ++)
        for(int j = i + 1; j <= n; j ++)
            if(a[i] <= a[j] && f[j] == f[i] + 1) add(i + n, j, 1);
    int ans = max_flow(S, T);
    printf("%d\n", ans);
    return ans;
}

void solve2()
{
    int S = 0, T = 2 * n + 1, v;
    for(int i = S; i <= T; i ++) G[i].clear();
    for(int i = 1; i <= n; i ++)
    {
        v = (i == 1 || i == n) ? INF : 1;
        if(f[i] == 1) add(S, i, v);
        if(f[i] == k) add(i + n, T, v);
        add(i, i + n, v);
    }
    for(int i = 1; i <= n; i ++)
        for(int j = i + 1; j <= n; j ++)
            if(a[i] <= a[j] && f[j] == f[i] + 1) add(i + n, j, 1);
    printf("%d\n", max_flow(S, T));
}

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
    for(int i = 1; i <= n; i ++)
    {
        f[i] = 1;
        for(int j = 1; j < i; j ++)
            if(a[i] >= a[j]) f[i] = max(f[i], f[j] + 1);
        k = max(k, f[i]);
    }
    printf("%d\n", k);
    int ans = solve1();
    if(k > 1) solve2();
    else printf("%d\n", ans);
    return 0;
}
```

## 7.试题库问题

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 1200 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int main()
{
    int n, k, t, x, sum = 0;
    scanf("%d%d", &n, &k);
    int S = 0, T = n + k + 1;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &x);
        add(i + k, T, x);
        sum += x;
    }
    for(int i = 1; i <= k; i ++)
    {
        scanf("%d", &t);
        add(S, i, 1);
        while(t --)
        {
            scanf("%d", &x);
            add(i, k + x, 1);
        }
    }
    if(max_flow(S, T) < sum) return 0 * puts("No Solution!");
    for(int i = k + 1; i <= k + n; i ++)
    {
        printf("%d:", i - k);
        for(auto v : G[i]) if(v.cap) printf(" %d", v.to);
        printf("\n");
    }
    return 0;
}
```



## 9.方格取数问题

对方格上的点根据行列奇偶黑白染色，建二分图，黑点向四周白点连边，要求的答案是没有边相连的权值和最大的点集。

二分图最大点权独立集=点权和-二分图最小点权覆盖集

跑最大流减一下

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 1000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int n, m;
inline int pt(int x, int y) { return x * m + y; }

int main()
{
    int x, sum = 0;
    scanf("%d%d", &n, &m);
    int S = 0, T = 1001;
    for(int i = 1; i <= n; i ++)
    {
        for(int j = 1; j <= m; j ++)
        {
            scanf("%d", &x);
            if((i + j) % 2)
            {
                add(S, pt(i, j), x);
                if(j + 1 <= m) add(pt(i, j), pt(i, j + 1), INF);
                if(j - 1 > 0) add(pt(i, j), pt(i, j - 1), INF);
                if(i + 1 <= n) add(pt(i, j), pt(i + 1, j), INF);
                if(i - 1 > 0) add(pt(i, j), pt(i - 1, j), INF);
            }
            else add(pt(i, j), T, x);
            sum += x;
        }
    }
    printf("%d\n", sum - max_flow(S, T));
    return 0;
}
```

## 10.餐巾计划问题

拆点建图，$A_i$表示当天可以提供的餐巾数，$B_i$表示当天获得的餐巾数。

$S$向$A_i$连边，流量为当天所需的总数x，费用为0，表示当天最多可以提供x个餐巾。

$B_i$向$T$连边，流量为当天所需的总数x，费用为0，表示当天最少需要获得x个餐巾。

$S$向$B_i$连边，流量为INF，费用为$P$，表示在当天购买新餐巾的花费。

$A_i$向$B_{i+M}$连边，流量为INF，费用为$F$，表示在第i天经过M天的快洗可以获得餐巾。

$A_i$向$B_{i+N}$连边，流量为INF，费用为$S$，表示在第i天经过N天的慢洗可以获得餐巾。

跑费用流即可。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;

int main()
{
    int n, P, M, F, N, S, x;
    scanf("%d%d%d%d%d%d", &n, &P, &M, &F, &N, &S);
    int s = 0, t = 2 * n + 1;
    ans.init(t);
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &x);
        ans.addEdge(s, i * 2 - 1, x, 0);
        ans.addEdge(i * 2, t, x, 0);
    }
    for(int i = 1; i <= n; i ++) ans.addEdge(s, i * 2, inf, P);
    for(int i = 1; i < n; i ++) ans.addEdge(i * 2 - 1, i * 2 + 1, inf, 0);
    for(int i = 1; i + M <= n; i ++) ans.addEdge(i * 2 - 1, (i + M) * 2, inf, F);
    for(int i = 1; i + N <= n; i ++) ans.addEdge(i * 2 - 1, (i + N) * 2, inf, S);
    printf("%d\n", ans.mincostMaxFlow(s, t));
    return 0;
}
```

## 11.航空路线问题

建图跑费用流，根据流量变化输出路径。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 200 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };
string name[15];

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}

	void printPath(int s, int t, int n)
	{
	    cout << name[1] << endl;
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to > x - n && edges[i].flow > 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    cout << name[v] << endl;
                    break;
                }
            }
        }
        vector<int> ans;
        ans.push_back(1);
        for(int x = 1; x != t;)
        {
            x += n;
            for(int i : G[x])
            {
                if(edges[i].to > x - n && edges[i].flow > 0)
                {
                    int u = x - n, v = edges[i].to;
                    x = v;
                    if(x == t) break;
                    edges[i].flow --;
                    ans.push_back(v);
                    break;
                }
            }
        }
        for(int i = ans.size() - 2; i >= 0; i --) cout << name[ans[i]] << endl;
	}
}ans;

int main()
{
    int n, m;
    string x, y;
    map<string, int> mp;
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
    {
        cin >> x;
        mp[x] = i;
        name[i] = x;
    }
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    while(m --)
    {
        cin >> x >> y;
        int u = mp[x], v = mp[y];
        if(u > v) swap(u, v);
        ans.addEdge(u + n, v, 2, 0);
    }
    for(int i = 1; i <= n; i ++) ans.addEdge(i, i + n, 1, -1);
    ans.addEdge(1, 1 + n, 1, 0);
    ans.addEdge(n, n + n, 1, 0);
    ans.addEdge(S, 1, 2, 0);
    ans.addEdge(2 * n, T, 2, 0);
    int res = -ans.mincostMaxFlow(S, T);
    if(res == 0) return 0 * puts("No Solution!");
    cout << res << endl;
    ans.printPath(S, T, n);
    return 0;
}
```



## 12.软件补丁问题

 我缓缓打出一个问号

这是个锤子的网络流，这是最短路啊

状压一下转移方案然后跑从(1<<n)-1到0的最短路

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = (1 << 21);
const int inf = 0x3f3f3f3f;

struct node
{
    int b1, b2, f1, f2, w;
    bool check(int x) { return ((x & b1) == b1) && ((x & b2) == 0); }
    int change(int x)
    {
        x ^= x & f1;
        x |= f2;
        return x;
    }
}a[105];

int n, m, dis[maxn];

void dijkstra(int s)
{
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = 0; i < m; i ++) if(a[i].check(u))
        {
            int v = a[i].change(u);
            if(dis[v] > dis[u] + a[i].w)
            {
                dis[v] = dis[u] + a[i].w;
                que.push({dis[v], v});
            }
        }
    }
}

int main()
{
    char s1[55], s2[55];
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i ++)
    {
        scanf("%d%s%s", &a[i].w, s1, s2);
        for(int j = 0; j < n; j ++)
        {
            if(s1[j] == '+') a[i].b1 |= (1 << j);
            else if(s1[j] == '-') a[i].b2 |= (1 << j);
            if(s2[j] == '-') a[i].f1 |= (1 << j);
            else if(s2[j] == '+') a[i].f2 |= (1 << j);
        }
    }
    dijkstra((1 << n) - 1);
    printf("%d\n", dis[0] == inf ? 0 : dis[0]);
    return 0;
}
```

## 13.星际转移问题

拆点建图，枚举天数。对于第i天上的点x，从i-1天的x点连容量为INF的边；并对当天的转移方案连边，每次直接在残量网络上跑最大流，总流量等于k时的天数即为答案。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 10000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int pos[105][105], x[105], t[105];

int main()
{
    int n, m, k;
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 0; i < m; i ++)
    {
        scanf("%d%d", &x[i], &t[i]);
        for(int j = 0; j < t[i]; j ++)
        {
            scanf("%d", &pos[i][j]);
            pos[i][j] += 2;
        }
    }
    int S = 0, T, ans = 0;
    add(S, 2, k);
    n += 2;
    for(int tt = 1; tt <= 100; tt ++)
    {
        T = tt * n + 1;
        for(int i = 0; i < m; i ++)
        {
            int u = (tt - 1) % t[i], v = tt % t[i];
            u = pos[i][u], v = pos[i][v];
            add((tt - 1) * n + u, tt * n + v, x[i]);
        }
        for(int i = 1; i <= n; i ++) add((tt - 1) * n + i, tt * n + i, INF);
        ans += max_flow(S, T);
        if(ans >= k) return 0 * printf("%d\n", tt);
    }
    puts("0");
    return 0;
}
```



## 14. 孤岛营救问题

状压+分层图最短路，代码能力丢人，调一下午

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[20*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w < dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int n, m, sum;

int pt(int x, int y, int dep)
{
    int id = (x - 1) * m + y;
    return id + dep * sum;
}

int mp[105][105], key[105][105], lim;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int p, x1, y1, x2, y2, g, k;
    scanf("%d%d%d", &n, &m, &p);
    lim = (1 << p);
    sum = n * m;
    scanf("%d", &k);
    memset(head, 0xff, sizeof dis);
    while(k --)
    {
        scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &g);
        int u = pt(x1, y1, 0), v = pt(x2, y2, 0);
        if(g == 0) mp[u][v] = mp[v][u] = -1;
        else mp[u][v] = mp[v][u] = (1 << (g - 1));
    }
    scanf("%d", &k);
    while(k --)
    {
        scanf("%d%d%d", &x1, &y1, &g);
        key[x1][y1] |= (1 << (g - 1));
    }
    for(int i = 0; i < lim; i ++)
    {
        for(int x = 1; x <= n; x ++)
        {
            for(int y = 1; y <= m; y ++)
            {
                for(int k = 0; k < 4; k ++)
                {
                    int xx = x + dx[k], yy = y + dy[k];
                    if(xx < 1 || xx > n || yy < 1 || yy > m) continue;
                    if(mp[pt(x, y, 0)][pt(xx, yy, 0)] == -1) continue;
                    int op = mp[pt(x, y, 0)][pt(xx, yy, 0)];
                    if((op & i) == op) add(pt(x, y, i), pt(xx, yy, i | key[xx][yy]), 1);
                }
            }
        }
    }
    int s = pt(1, 1, 0), t = pt(n, m, lim - 1) + 1;
    for(int i = 0; i < lim; i ++) add(pt(n, m, i), t, 0);
    dijkstra(s);
    printf("%d\n", dis[t] == inf ? -1 : dis[t]);
    return 0;
}
```



## 15.汽车加油行驶问题

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e5 + 10;
const int inf = 0x3f3f3f3f;

int head[maxn], dis[maxn], cnt;

struct Edge { int nex,to,w; }edge[2*maxn];

void add(int u,int v,int w)
{
    edge[++cnt].nex=head[u];
    edge[cnt].w=w;
    edge[cnt].to=v;
    head[u]=cnt;
}

void dijkstra(int s)
{
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;
    memset(dis, 0x3f, sizeof dis);
    que.push({0, s}); dis[s] = 0;
    while(!que.empty())
    {
        auto f = que.top(); que.pop();
        int u = f.second, d = f.first;
        if(d != dis[u]) continue;
        for(int i = head[u]; ~i; i = edge[i].nex)
        {
            int v = edge[i].to, w = edge[i].w;
            if(dis[u] + w < dis[v])
            {
                dis[v] = dis[u] + w;
                que.push({dis[v], v});
            }
        }
    }
}

int p[105][105], n;

int pt(int x, int y, int dep)
{
    return (x - 1) * n + y + dep * n * n;
}

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int main()
{
    int k, a, b, c;
    scanf("%d%d%d%d%d", &n, &k, &a, &b, &c);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            scanf("%d", &p[i][j]);
    int s = 0, t = pt(n, n, k) + 1;
    memset(head, 0xff, sizeof head);
    add(s, pt(1, 1, k), 0);
    for(int x = 1; x <= n; x ++)
    {
        for(int y = 1; y <= n; y ++)
        {
            for(int i = 0; i <= k; i ++) add(pt(x, y, i), pt(x, y, k), a + c);
            for(int i = 0; i < 4; i ++)
            {
                int fx = dx[i] + x, fy = dy[i] + y;
                if(fx < 1 || fx > n || fy < 1 || fy > n) continue;
                for(int j = 1; j <= k; j ++)
                {
                    if(p[fx][fy])
                    {
                        if(fx < x || fy < y)add(pt(x, y, j), pt(fx, fy, k), a + b);
                        else add(pt(x, y, j), pt(fx, fy, k), a);
                    }
                    else
                    {
                        if(fx < x || fy < y) add(pt(x, y, j), pt(fx, fy, j - 1), b);
                        else add(pt(x, y, j), pt(fx, fy, j - 1), 0);
                    }
                }
            }
        }
    }
    for(int i = 0; i <= k; i ++) add(pt(n, n, i), t, 0);
    dijkstra(s);
    printf("%d\n",dis[t]);
    return 0;
}
```



## 16.数字梯形问题

第一问求不相交路径，拆点使i到i+n的流量为1

第二问点可以多次使用，把上面拆点的流量改成INF

第三问边也可以多次使用，把加的边的流量也改成INF，注意最下层到T的边也要改

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
    int n, m;
    vector<Edge> edges;
    vector<int> G[maxn];
    bool inq[maxn];
    int dis[maxn], path[maxn], a[maxn];

    void init(int n)
    {
        this->n = n;
        for(int i = 0;i <= n;i ++)
            G[i].clear();
        edges.clear();
    }

    void addEdge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool Bellman_Ford(int s, int t, int& flow, int& cost)
    {
        for(int i = 0; i<= n; i++) dis[i] = inf;
        memset(inq, 0, sizeof inq);
        dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
        queue<int> Q;
        Q.push(s);
        while(!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = false;
            for(int i = 0; i < G[u].size(); i++)
            {
                Edge& e = edges[G[u][i]];
                if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
                {
                    dis[e.to] = dis[u] + e.cost;
                    path[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if(!inq[e.to])
                    {
                        Q.push(e.to);
                        inq[e.to] = true;
                    }
                }
            }
        }
        if(dis[t] == inf) return false;
        flow += a[t];
        cost += dis[t] * a[t];
        for(int u = t; u != s; u = edges[path[u]].from)
        {
            edges[path[u]].flow += a[t];
            edges[path[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int mincostMaxFlow(int s, int t)
    {
        int flow = 0, cost = 0;
        while(Bellman_Ford(s, t, flow, cost));
        return cost;
    }
}ans;

int n, m, p, a[55][55];

void solve1()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i < m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j <= i + n; j ++)
        {
            if(i + 1 < m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 < m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, 1, 0);
        }
    }
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i <= n + m; i ++) ans.addEdge(tmp + p + i, T, 1, 0);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i < m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j <= i + n; j ++)
        {
            if(i + 1 < m) ans.addEdge(tp + p + j, tp1 + j, 1, -a[i + 1][j]);
            if(i + 1 < m) ans.addEdge(tp + p + j, tp1 + j + 1, 1, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i <= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

void solve3()
{
    int S = 0, T = 2 * p + 1;
    ans.init(T);
    for(int i = 0; i < m; i ++)
    {
        int tp = (n + (n + i - 1)) * i / 2, tp1 = (n + (n + i)) * (i + 1) / 2;
        for(int j = 1; j <= i + n; j ++)
        {
            if(i + 1 < m) ans.addEdge(tp + p + j, tp1 + j, inf, -a[i + 1][j]);
            if(i + 1 < m) ans.addEdge(tp + p + j, tp1 + j + 1, inf, -a[i + 1][j + 1]);
            ans.addEdge(tp + j, tp + p + j, inf, 0);
        }
    }
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, 1, -a[0][i]);
    int tmp = p - (n + m - 1);
    for(int i = 1; i <= n + m; i ++) ans.addEdge(tmp + p + i, T, inf, 0);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf("%d%d", &n, &m);
    p = (n + (n + m - 1)) * m / 2;
    for(int i = 0; i < m; i ++)
        for(int j = 1; j <= n + i; j ++)
            scanf("%d", &a[i][j]);
    solve1();
    solve2();
    solve3();
    return 0;
}
```

## 17.运输问题

二分图最大权多重匹配，无脑费用流

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;

int n, m, a[105], b[105], cost[105][105];

void solve1()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i <= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            ans.addEdge(i, j + n, inf, -cost[i][j]);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = n + m + 1;
    ans.init(T);
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, a[i], 0);
    for(int i = 1; i <= m; i ++) ans.addEdge(i + n, T, b[i], 0);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            ans.addEdge(i, j + n, inf, cost[i][j]);
    printf("%d\n", ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
    for(int i = 1; i <= m; i ++) scanf("%d", &b[i]);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            scanf("%d", &cost[i][j]);
    solve2();
    solve1();
    return 0;
}
```

## 18.分配问题

二分图最大权匹配，无脑费用流*2

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=10000+10;
const int inf=0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;

int n, cost[105][105];

void solve1()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i <= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            ans.addEdge(i, j + n, 1, cost[i][j]);
    printf("%d\n", ans.mincostMaxFlow(S, T));
}

void solve2()
{
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i <= n; i ++) ans.addEdge(S, i, 1, 0);
    for(int i = 1; i <= n; i ++) ans.addEdge(i + n, T, 1, 0);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            ans.addEdge(i, j + n, 1, -cost[i][j]);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
}

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            scanf("%d", &cost[i][j]);
    solve1();
    solve2();
    return 0;
}
```

## 19.负载平衡问题

拆点跑费用流，$S$向$A_i$连边，流量为当前点原来的大小，费用为0；$A_i$向$B_i$连边，费用为0，向$B_{i-1}$和$B_{i+1}$连边，费用为1，容量为INF;$B_i$向$T$连边，流量为目标值大小，费用为0.



```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;


int main()
{
    int n, sum = 0, x;
    scanf("%d", &n);
    int S = 0, T = 2 * n + 1;
    ans.init(T);
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &x);
        sum += x;
        ans.addEdge(S, i, x, 0);
    }
    sum /= n;
    for(int i = 1; i <= n; i ++) ans.addEdge(i + n, T, inf, 0);
    for(int i = 1; i <= n; i ++) ans.addEdge(i, i + n, sum, 0);
    for(int i = 1; i <= n; i ++)
    {
        int x = i - 1, y = i + 1;
        if(x < 1) x += n;
        if(y > n) y -= n;
        ans.addEdge(i, x, inf, 1);
        ans.addEdge(i, y, inf, 1);
    }
    printf("%d\n", ans.mincostMaxFlow(S, T));
    return 0;
}
```

## 20.深海机器人问题

费用流，输入格式令人D区

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;

int id[25][25];

int main()
{
    int a, b, p, q, k, x, y;
    scanf("%d%d%d%d", &a, &b, &p, &q);
    int tot = 0;
    p ++; q ++;
    for(int i = 1; i <= p; i ++)
        for(int j = 1; j <= q; j ++) id[i][j] = ++tot;
    int S = 0, T= tot + 1;
    ans.init(T);
    for(int i = 1; i <= p; i ++)
    {
        for(int j = 1; j < q; j ++)
        {
            scanf("%d", &x);
            ans.addEdge(id[i][j], id[i][j + 1], 1, -x);
            ans.addEdge(id[i][j], id[i][j + 1], inf, 0);
        }
    }
    for(int j = 1; j <= q; j ++)
    {
        for(int i = 1; i < p; i ++)
        {
            scanf("%d", &x);
            ans.addEdge(id[i][j], id[i + 1][j], 1, -x);
            ans.addEdge(id[i][j], id[i + 1][j], inf, 0);
        }
    }
    while(a --)
    {
        scanf("%d%d%d", &k, &x, &y);
        ans.addEdge(S, id[x + 1][y + 1], k, 0);
    }
    while(b --)
    {
        scanf("%d%d%d", &k, &x, &y);
        ans.addEdge(id[x + 1][y + 1], T, k, 0);
    }
    printf("%d\n", -ans.mincostMaxFlow(S, T));
    return 0;
}
```

## 21.最长k可重区间集问题

拆点建图，超级源点$S$向$S1$连边，流量为$k$，费用为0，表示最多取$k$个开头的区间；$S1$向$A_i$连边，流量为1，费用为0；$A_i$向$B_i$连边，费用为该区间权值，表示取这个区间；$B_i$向所有在其右侧且与它不相交的$A_i$连边，流量为1，费用为0；$B_i$向$T$连边，流量为1，费用为0，跑$S$到$T$的费用流。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;

int l[505], r[505], c[505];

int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    int S = 0, T = 2 * n + 1, S1 = T + 1;
    ans.init(S1);
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d%d", &l[i], &r[i]);
        if(l[i] > r[i]) swap(l[i], r[i]);
        ans.addEdge(i, i + n, 1, -(r[i] - l[i]));
    }
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= n; j ++)
            if(r[i] <= l[j]) ans.addEdge(i + n, j, 1, 0);
    ans.addEdge(S, S1, k, 0);
    for(int i = 1; i <= n; i ++)
    {
        ans.addEdge(S1, i, 1, 0);
        ans.addEdge(i + n, T, 1, 0);
    }
    printf("%d\n", -ans.mincostMaxFlow(S, T));
    return 0;
}
```

## 22.最长k可重线段集问题

跟上一题模型其实是一样的，换了个方法。

把线段投影到X轴上，就转化成了区间集问题，但是因为存在`x=r`这样的线段，如果直接建图会产生负环，需要拆点。

离散化区间端点，相邻的点连边，流量为INF，费用为0；区间端点`L[i]`向`R[i]`连流量为1的边，边权为`-val[i]`，S和T分别向最左和最右端点连流量为k，费用为0的边。跑费用流即为答案。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}
}ans;

inline int dis(int x1, int y1, int x2, int y2) {
    return sqrt(1ll * (x2 - x1) * (x2 - x1) + 1ll *(y2 - y1) * (y2 - y1));
}

int n, L[505], R[505], val[505];
map<int, int> M;

int discretization()
{
    vector<int> v;
    for(int i = 1; i <= n; i ++) v.push_back(L[i]), v.push_back(R[i]);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for(int i = 0; i < v.size(); i ++) M[v[i]] = i + 1;
    for(int i = 1; i <= n; i ++) L[i] = M[L[i]], R[i] = M[R[i]];
    return v.size();
}

int main()
{
    int k, a, b, c, d;
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d%d%d%d", &a, &b, &c, &d);
        val[i] = dis(a, b, c, d);
        L[i] = a * 2, R[i] = c * 2;
        if(L[i] > R[i]) swap(L[i], R[i]);
        if(L[i] == R[i]) R[i] ++;
        else L[i] ++;
    }
    int m = discretization();
    int S = 0, T = m + 1;
    ans.init(T);
    ans.addEdge(S, 1, k, 0), ans.addEdge(m, T, k, 0);
    for(int i = 1; i < m; i ++) ans.addEdge(i, i + 1, inf, 0);
    for(int i = 1; i <= n; i ++) ans.addEdge(L[i], R[i], 1, -val[i]);
    printf("%d\n", -ans.mincostMaxFlow(S, T));
    return 0;
}
```



## 23.火星探险问题

拆点跑费用流，输出路径

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 10000 + 10;
const int inf = 0x3f3f3f3f;

struct Edge { int from, to, cap, flow, cost; };

int a[50][50], id[50][50];

struct MCMF
{
	int n, m;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool inq[maxn];
	int dis[maxn], path[maxn], a[maxn];

	void init(int n)
	{
		this->n = n;
		for(int i = 0;i <= n;i ++)
			G[i].clear();
		edges.clear();
	}

	void addEdge(int from, int to, int cap, int cost)
	{
		edges.push_back(Edge{from, to, cap, 0, cost});
		edges.push_back(Edge{to, from, 0, 0, -cost});
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool Bellman_Ford(int s, int t, int& flow, int& cost)
	{
		for(int i = 0; i<= n; i++) dis[i] = inf;
		memset(inq, 0, sizeof inq);
		dis[s]=0, inq[s]=true, path[s]=0, a[s]=inf;
		queue<int> Q;
		Q.push(s);
		while(!Q.empty())
		{
			int u = Q.front(); Q.pop();
			inq[u] = false;
			for(int i = 0; i < G[u].size(); i++)
			{
				Edge& e = edges[G[u][i]];
				if(e.cap > e.flow && dis[e.to] > dis[u] + e.cost)
				{
					dis[e.to] = dis[u] + e.cost;
					path[e.to] = G[u][i];
					a[e.to] = min(a[u], e.cap - e.flow);
					if(!inq[e.to])
					{
						Q.push(e.to);
						inq[e.to] = true;
					}
				}
			}
		}
		if(dis[t] == inf) return false;
		flow += a[t];
		cost += dis[t] * a[t];
		for(int u = t; u != s; u = edges[path[u]].from)
		{
			edges[path[u]].flow += a[t];
			edges[path[u] ^ 1].flow -= a[t];
		}
		return true;
	}

	int mincostMaxFlow(int s, int t)
	{
		int flow = 0, cost = 0;
		while(Bellman_Ford(s, t, flow, cost));
		return cost;
	}

	void printPath(int cnt, int n, int m)
	{
	    int p = id[1][1];
	    while(p != id[n][m])
        {
            int x = (p - 1) / m, y = (p - 1) % m;
            for(auto i : G[p + n * m])
            {
                int tmp = edges[i].to;
                int xx = (tmp - 1) / m, yy = (tmp - 1) % m;
                if(xx <= x && yy <= y) continue;
                if(edges[i].flow > 0)
                {
                    edges[i].flow --;
                    //printf("%d %d %d %d\n", edges[i].from, edges[i].to, edges[i].cap, edges[i].flow);
                    //printf("%d %d\n", xx + 1, yy + 1);
                    if(xx > x) printf("%d 0\n", cnt);
                    else printf("%d 1\n", cnt);
                    p = tmp;
                    break;
                }
            }
        }
	}
}ans;

int main()
{
    int x, n, m;
    scanf("%d%d%d", &x, &m, &n);
    int S = 0, T = 2 * n * m + 1, tot = 0;
    ans.init(T);
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
            scanf("%d", &a[i][j]), id[i][j] = ++tot;
    for(int i = 1; i <= n; i ++)
    {
        for(int j = 1; j <= m; j ++)
        {
            if(i + 1 <= n) ans.addEdge(id[i][j] + n * m, id[i + 1][j], inf, 0);
            if(j + 1 <= m) ans.addEdge(id[i][j] + n * m, id[i][j + 1], inf, 0);
            if(a[i][j] == 0 || a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, inf, 0);
            if(a[i][j] == 2) ans.addEdge(id[i][j], id[i][j] + n * m, 1, -1);
        }
    }
    ans.addEdge(S, id[1][1], x, 0);
    ans.addEdge(id[n][m] + n * m, T, x, 0);
    ans.mincostMaxFlow(S, T);
    for(int i = 1; i <= x; i ++) ans.printPath(i, n, m);
    return 0;
}
```

## 24.骑士共存问题

显然所给模型是二分图，最大独立集-不可选的边即为答案。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_V = 50000 + 10;
const int INF = 0x3f3f3f3f;

//用于表示边的结构体（终点，流量，反向边）
struct edge{int to, cap, rev;};

vector<edge> G[MAX_V];	//图的邻接表表示
int level[MAX_V];	//顶点到源点的距离标号
int iter[MAX_V];	//当前弧

void add(int from, int to, int cap)
{
	G[from].push_back((edge){to, cap, G[to].size()});
	G[to].push_back((edge){from, 0, G[from].size() - 1});
}

//计算从源点出发的距离标号
void bfs(int s)
{
	memset(level, -1, sizeof(level));
	queue<int> que;
	level[s] = 0;
	que.push(s);
	while(!que.empty())
	{
		int v = que.front(); que.pop();
		for(int i = 0; i < G[v].size(); i++)
		{
			edge &e = G[v][i];
			if(e.cap > 0 && level[e.to] < 0)
			{
				level[e.to] = level[v] + 1;
				que.push(e.to);
			}
		}
	}
}

//通过DFS寻找增广路
int dfs(int v, int t, int f)
{
	if(v == t) return f;
	for(int &i = iter[v]; i<G[v].size(); i++)
	{
		edge &e = G[v][i];
		if(e.cap > 0 && level[v] < level[e.to])
		{
			int d = dfs(e.to, t, min(f, e.cap));
			if(d > 0)
			{
				e.cap -= d;
				G[e.to][e.rev].cap += d;
				return d;
			}
		}
	}
	return 0;
}

//求解从s到t的最大流
int max_flow(int s, int t)
{
	int flow = 0;
	for(;;)
	{
		bfs(s);
		if(level[t] < 0) return flow;
		memset(iter, 0, sizeof(iter));
		int f;
		while((f = dfs(s,t,INF)) > 0) flow += f;
	}
}

int n, vis[205][205];

int dx[8] = {-2, -1, -2, -1, 2, 1, 2, 1};
int dy[8] = {-1, -2, 1, 2, -1, -2, 1, 2};

int id(int x, int y) { return (x - 1) * n + y; }

bool check(int x, int y) { return x > 0 && x <= n && y > 0 && y <= n && !vis[x][y]; }

int main()
{
    int m, u, v;
    scanf("%d%d", &n, &m);
    int S = 0, T = n * n + 1;
    for(int i = 0; i < m; i ++)
    {
        scanf("%d%d", &u, &v);
        vis[u][v] = 1;
    }
    for(int x = 1; x <= n; x ++)
    {
        for(int y = 1; y <= n; y ++)
        {
            if(!check(x, y)) continue;
            if((x + y) % 2) add(S, id(x, y), 1);
            else add(id(x, y), T, 1);
            if((x + y) % 2 == 0) continue;
            for(int i = 0; i < 8; i ++)
            {
                int fx = x + dx[i], fy = y + dy[i];
                if(check(fx, fy)) add(id(x, y), id(fx, fy), 1);
            }
        }
    }
    printf("%d\n", n * n - max_flow(S, T) - m);
    return 0;
}
```

