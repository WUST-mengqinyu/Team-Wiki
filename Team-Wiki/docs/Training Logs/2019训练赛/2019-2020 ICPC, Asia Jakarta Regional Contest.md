| Name                                                         | Date       | Solved |  A   |  B   |  C   |  D   |  E   |  F   |  G   |  H   |  I   |  J   |  K   |  L   |
| ------------------------------------------------------------ | ---------- | ------ | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| [2019-2020 ICPC, Asia Jakarta Regional Contest](http://codeforces.com/contest/1252) | 2019/10/31 | 9/12   |  O   |  .   |  O   |  .   |  O   |  Ø   |  O   |  O   |  .   |  Ø   |  O   |  Ø   |

##  A. Copying Homework 

给一个长度为n的序列a，输出序列b使\(\sum_{i=1}^n{|b_i-a_i|}≥n\)。

输出n-a[i]即可。

##  C. Even Path 

给定一个网格，点(i,j)的值为R[i]+c[j]，判断是否存在从\((sx,sy)\)走到\((tx,ty)\)的全为奇数的路径。

判断sx-tx，sy-ty的R,C值是否同时全为奇数或者全为偶数，前缀和搞一下就好。

## E. Songwriter

已知序列中的每个值和上一个值的关系（上升/下降/不变），上升/下降的范围为[1,k]，要求序列的所有值都在[l,r]区间内，构造字典序最小的合法序列，如果没有，输出-1。

从倒推求出每个值的区间范围，如果最大值小于l或最小值大于r则无解，否则递推构造序列并使每个值尽可能小。

##  F. Regular Forestation 

给一棵树，求去掉一个点是的剩余的森林中的无根树全部同构，最大的同构个数。

显然，只有当这棵树仅有一个重心且它的子树大小都相等时才可能有解，然后判无根树同构后直接输出重心的度数即可。

## G. Performance Review

给定一个序列，做m次修改，第i次修改给出一个序列`a`将前k个小的替换为`a[i][0],a[i][1],a[i][k-1]`这些数字，问m次修改后初始的第1个人是否仍在序列中。

q次询问，每次修改第i次修改的第j个值，将其修改为x，并回答询问。

记录第1个人在第i次修改后的rank，显然对于q次修改最多只会改变一位，也就是使`(j,n)`这个区间的每一个值+1或-1，修改后判断(1,n)的rank是否都>0即可。

##  H. Twin Buildings 

给定n块矩形，选择一块或两块，并在其中放入大小相同的两块矩形，问放入的矩形的面积最大可以是多少。

可以选择在一块或两块矩形中放入，如果是一块就是矩形面积/2，如果是两块，首先使每个矩形的L大于W，按照W降序排序，记录L的前缀最大值preL，遍历，当前矩形的最大贡献即为`min(preL, a[i].L)*a[i].W`。

## J. Tiling Terrace

给一个01串，给三种子串分别有abc权值（0\00\010），要求把原串分割成多个这三种串，其中a串最多只能有k个，求最大权值和，保证1的个数不超过50

显然dp一下，用`dp[i][j]`表示前`i`位，有`j`个c串，最多的b串个数。

那么显然可以通过枚举c串个数进行枚举答案。

设n1为取的a串，n2为取的b串，n3为取的c串个数

那么由于枚举的是c串个数，n2的最大值，n1的个数可以计算出来。

然后考虑将n2替换成n1的情况即可。

##  K. Addition Robot 

给一段AB串，操作1为翻转，即把L,R区间内的A变B，B变A；操作2为查询，顺序遍历子串`S[l-r]`,传入A，B两个值，如果串的当前值为A，使A=A+B，否则使B=A+B，输出计算后的A，B。

把运算处理成2x2的矩阵，用线段树维护处理操作。

##  L. Road Construction

给定一棵基环树上的边，每一条边可以被指定类的工人维修，求能使树上点联通的维修方案。

如果对于边和工人一一连边，边数可能达到$NK$，考虑简化边数。

对于每组边对应的类型数$M_i$，有$\sum_{i=1}^n M_i<=10000$，所以让树边与工人类型数连边，并对每种类型的工人计数，连向汇点即可。

对于一棵基环树，要选$n-1$条边使其联通，假设其环上有k条边，必须选择“环上的k-1条边”和“环外的所有边”。dfs求出基环树上的环，存储“环外的边”为A集合，“环上的边”为B集合。

首先对起点向A集合中的点连边，判断是否全部匹配；再对起点向B集合中的点连边，判断总的流量是否$>=n-1$即可。