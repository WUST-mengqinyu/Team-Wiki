| Name                                                         | Date      | Solved |  A   |  B   |  C   |  D   |  E   |  F   |  G   |  H   |  I   |  J   |  K   |  L   |
| ------------------------------------------------------------ | --------- | ------ | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| [2019 China Collegiate Programming Contest Qinhuangdao Onsite](http://acm.hdu.edu.cn/contests/contest_show.php?cid=872) | 2019/9/28 | 7/12 | O | . | . | O | O | O | . | . | O | O | O | . |

## A、Angle Beats

## D、Decimal

题意：求`1/x`是否为有限循环小数。

题解：显然如果`x`是`10^n`的因子它才是有限循环小数，即`x`只有2和5两种因子

## E、Escape

题意：有a个机器人从网格图最上方出发，有b个出口在网格图最下方，机器人只能直走或通过装置转弯，一个方格只能放一个装置；机器人无法从装置以外的方向进入装置所在的方格，也无法通过障碍物，问所有机器人是否都能到达下方出口。

题解：空方格最多从横向/纵向各经过一次，有障碍物的方格横向+纵向最多经过一次；拆点建图，一张图为纵向路径，另一张图为横向路径，纵向点与横向点连边，所有流量均为1，跑网络流判断max_flow是否等于a。

## F、Forest Program

题意：给一个仙人掌群，求有多少种删边方案可以将其变成森林

题解：显然对每个环，至少要删掉一条边即可，其他的边任意删。所以对每棵仙人掌dfs求出每个环的大小x，求出`2^x-1`的积，然后乘上不在环上的边的条数p,`2^p`，两者相乘就是答案。

## I、Invoker

题意：给出卡尔的10种技能，组成技能的组合可以是无序的但是释放本身是有序的，求出最少需要多少次按键（含R键）。

题解：不含R键进行三进制编码，由于数据范围很小直接暴力搜出27种编码互相之间的距离，比如`QQQ`和`QEE`，他们最长的后缀-前缀匹配为1（即`Q`），由于数据范围实在太小直接平方处理即可，当然exkmp专门解这个的。然后dp，`dp[i][j]`表示到第i个技能，现在队列中的状态为j的最少步数。`dp[i][j] = min(dp[i - 1][k] + mp[j][k])`即可，不合法的直接去掉，这里由于数据过小直接暴力cmp即可。然后代码写了挺长的。

## J、MUV LUV EXTRA

题意：给一个无限循环小数的前n位并猜测循环节，求`a*当前已经出现的循环总长度-b*循环节长度`的最大值。

题解：对于同一后缀显然取其最小循环节，翻转串跑KMP，遍历一下每个点求最大值即可（res初值应该设负数而不是0因为b可能比a大，wa了一发）。

## K、MUV LUV UNLIMITED

题意：给一棵有根树，两个人博弈，a先手，每次每个人必须至少删掉一个叶子节点，也只能删掉叶子节点，求谁最先把树删空。

题解：思考博弈了很久发现的一个结论是：如果是多条链组成的树（即只有根节点有出度大于1）时，只有
    - 1、有且仅有一条链为奇数长度
    - 2、大于1条链且所有链为奇数长度
    
    是后手必胜，因为可以发现其他情况先手可以将状态转移为全奇数的情况，然后后手就没了，因为最后只剩一个（长度为0偶数）的时候是先手赢。

然后考虑一下如果存在一个叶子节点的父节点有多余1个子节点，则先手必胜。

证明如下：计满足先手必胜的叶子节点为x，其他所有叶子节点集合为S
    - 1、如果删掉x后为先手败状态，那么当前删掉x它就是必胜态
    - 2、如果删掉x后为先手胜状态，那么首先S在这种状态是没有改变的，所以后手必然会选择一个`S‘ \in S`使得下个状态为先手败状态，由于S’是S的子集，那么先手如果取`S' \and x`必然进入先手败状态，为先手必胜态。

两者结合即是：如果按1缩点到某个度数大于1的点，它存在先手必胜态即是先手必胜，否则后手胜，如果找不到度数大于1的点即是一条链按奇偶输出即可。

然后就直接按两种情况计算即可，建树会爆内存，直接按topsort序模拟即可。
