| Name                                                         | Date       | Solved |  A   |  B   |  C   |  D   |  E   |  F   |  G   |  H   |  I   |  J   |
| ------------------------------------------------------------ | ---------- | ------ | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| [Contest Name](https://link) | 9999/1/1 | 0/0   |  O   |  .   |  .   |  .   |  .   |  O   |  .   |  .   |  .   |  O   |


## A. 

*solved by: Verly 03:25:17(-8)  upsolved by:*

题意：给一个全为ab的字符串，对于其中任一后缀，第i位的值为i到前一个相同字符的距离（如果s[i]第一次出现，值为0），对后缀赋的值排序。

对于某一个后缀串s‘，

??? note "Code"
    ```cpp
    #include <bits/stdc++.h>

    using namespace std;
    typedef long long ll;

    const int maxn = 3e5 + 10;
    int s[maxn];
    char b[maxn];
    int sa[maxn], t[maxn], t2[maxn], c[maxn], n;

    //build_sa(n + 1, 130), sa, height下标从1开始,rk下标从0开始
    void build_sa(int n, int m) {
    int *x = t, *y = t2;
    for (int i = 0; i < m; i++) c[i] = 0;
    for (int i = 0; i < n; i++) c[x[i] = s[i]]++;
    for (int i = 1; i < m; i++) c[i] += c[i - 1];
    for (int i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;
    for (int k = 1; k <= n; k <<= 1) {
        int p = 0;
        for (int i = n - k; i < n; i++) y[p++] = i;
        for (int i = 0; i < n; i++) if (sa[i] >= k) y[p++] = sa[i] - k;
        for (int i = 0; i < m; i++) c[i] = 0;
        for (int i = 0; i < n; i++) c[x[y[i]]]++;
        for (int i = 0; i < m; i++) c[i] += c[i - 1];
        for (int i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i];
        swap(x, y);
        p = 1;
        x[sa[0]] = 0;
        for (int i = 1; i < n; i++)
            x[sa[i]] = y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++;
        if (p >= n) break;
        m = p;
    }
    }

    int rk[maxn];

    void getHeight() {
    for(int i = 1; i <= n; i++) rk[sa[i]] = i;
    }

    int nex[maxn];
    vector<pair<int, int>> resp[maxn];
    int resq[maxn];

    int main() {
        while (scanf("%d", &n) != EOF) {
            scanf("%s", b);
            for (int i = 0; i <= n; i++) resp[i].clear(), resq[i] = -1, nex[i] = 0;
            s[n] = s[n + 1] = 0;
            int lasa = -1, lasb = -1;
            for (int i = 0; i < n; i++) {
                if (b[i] == 'a') {
                    if (lasa == -1) s[i] = 50;
                    else s[i] = i - lasa + 50;
                    lasa = i;
                } else if (b[i] == 'b') {
                    if (lasb == -1) s[i] = 50;
                    else s[i] = i - lasb + 50;
                    lasb = i;
                }
            }
            lasa = -1, lasb = -1;
            for (int i = n - 1; i >= 0; i--) {
                if (b[i] == 'a') {
                    nex[i] = lasb;
                    lasa = i;
                } else if (b[i] == 'b') {
                    nex[i] = lasa;
                    lasb = i;
                }
            }
            build_sa(n + 1, n + 55);
            for (int i = 0; i <= n + 1; ++i) rk[i] = 0;
            getHeight();
            for (int i = 0; i < n - 1; i++) {
                if (nex[i] == -1) resq[n - i] = i;
                else {
                    int len = nex[i] - i + 1;
                    resp[len].push_back({rk[nex[i] + 1], i});
                }
            }
            for (int i = 0; i <= n; i++) sort(resp[i].begin(), resp[i].end());
            printf("%d", n);
            for (int i = 0; i <= n; i++) {
                for (auto x : resp[i]) printf(" %d", x.second + 1);
                if (resq[i] != -1) printf(" %d", resq[i] + 1);
            }
            puts("");
        }
        return 0;
    }

