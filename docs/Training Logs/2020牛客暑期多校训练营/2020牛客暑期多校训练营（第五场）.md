| Name                                                         | Date       | Solved |  A   |  B   |  C   |  D   |  E   |  F   |  G   |  H   |  I   |  J   |  K   |
| ------------------------------------------------------------ | ---------- | ------ | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| [2020牛客暑期多校训练营（第五场）](https://ac.nowcoder.com/acm/contest/5670) | 2020/7/25 | 7/10   |  Ø   |  Ø   |  .   |  Ø   |  O   |  O   |  .   |  Ø   |  O   |  .   |  .   |


## A. Portal

*upsolved by: Verly*

题意：给定一张n个点的无向图，每次你可以在当前点建立一个传送门，或者取消在任意位置的传送门，同时最多可以建立两个传送门，建立/撤销传送门不消耗时间，人员可以在传送阵之间任意传送。给定k个任务，第i个任务是先去a[i]再到b[i]，初始在点1，求完成所有任务消耗的最短距离。

把任务拆成2×k个，则每次任务就是从p[i - 1]走到p[i]，p[0]=1。

考虑状态转移，因为每个任务结束时一定在p[i]处，因为实际上记录两个传送门是没有意义的（传送门需要到节点使用，一定可以取消其中一个传送门然后在当前所在节点建一个新的），所以只需要记录一个传送门的位置。`dp[i][j]`表示做第i个任务时，有一个在j点的传送门。

考虑状态转移：

- 从p[i]走到p[i+1]/传送到j走到p[i+1]，传送门j位置不变

- 从p[i]走到k再走到p[i+1]，从j或k走到p[i+1]，取消j的传送门

- 从p[i]传送到j走到k，从j或k走到p[i+1]，取消j的传送门

??? note "Code"
    ```cpp
    #include <bits/stdc++.h>
    
    using namespace std;
    typedef long long ll;
    
    const int maxn = 600 + 10;
    int mp[maxn][maxn], p[maxn];
    ll dp[maxn][maxn];
    
    int main()
    {
        memset(mp, 0x3f, sizeof mp);
        int n, m, k;
        scanf("%d%d%d", &n, &m, &k);
        for(int i = 0; i <= n; i ++) mp[i][i] = 0;
        while(m --)
        {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            mp[u][v] = mp[v][u] = min(mp[u][v], w);
        }
        for(int k = 1; k <= n; k ++)
            for(int i = 1; i <= n; i ++)
                for(int j = 1; j <= n; j ++)
                    mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
        memset(dp, 0x3f, sizeof dp);
        k *= 2, p[0] = 1, dp[0][1] = 0;
        for(int i = 1; i <= k; i ++)
        {
            scanf("%d", &p[i]);
            for(int j = 1; j <= n; j ++)
            {
                dp[i][j] = min(dp[i][j], dp[i - 1][j] + min(mp[p[i - 1]][p[i]], mp[j][p[i]]));
                for(int k = 1; k <= n; k ++)
                {
                    dp[i][k] = min(dp[i][k], dp[i - 1][j] + mp[p[i - 1]][k] + min(mp[j][p[i]], mp[k][p[i]]));
                    dp[i][k] = min(dp[i][k], dp[i - 1][j] + mp[j][k] + min(mp[j][p[i]], mp[k][p[i]]));
                }
            }
        }
        ll res = 0x3f3f3f3f3f3f3f3f;
        for(int i = 1; i <= n; i ++) res = min(res, dp[k][i]);
        printf("%lld\n", res);
        return 0;
    }
    ```

## B. Graph

*upsolved by: Verly*

题意：给一棵树，可以任意加边或者删边，但要保证任何时刻整棵树联通，并且树上任何一个环的亦或和为0。求操作后最小的边权和。

可以发现任意两个点连边的权值是固定的，考虑对边权做处理，将根到点的边权异或和下方到点权，这样点权异或后就是边的权值。对下放后的点权做异或最小生成树即可，做法是把点权加入01字典树做子树合并。

??? note "Code"
    ```cpp
    #include <bits/stdc++.h>

    using namespace std;
    typedef long long ll;

    const int maxn = 1e5 + 10;

    ll res = 0;
    int trie[maxn * 30][2], val[maxn], tot;
    vector<int> ve[maxn * 30];
    vector<pair<int, int> > edge[maxn];

    void init(int u, int pre)
    {	
        for(auto x : edge[u]) if(x.first != pre)
        {
            int v = x.first, w = x.second;
            val[v] = val[u] ^ w;
            init(v, u);
        }
    }

    void ins(int x, int pos)
    {
        int root = 0;
        for(int i = 29; i >= 0; i --) 
        {
            int id = (x >> i) & 1;
            if(!trie[root][id]) trie[root][id] = ++ tot;
            root = trie[root][id];
            ve[root].push_back(pos);
        }
    }

    int find(int root, int x, int pos)
    {
        if(pos == -1) return 0;
        int idx = (x >> pos) & 1; 
        if(trie[root][idx]) return find(trie[root][idx], x, pos - 1);
        else return (1 << pos) + find(trie[root][!idx], x, pos - 1); 
    }

    void dfs(int root, int pos)
    {
        if(pos == -1) return;
        int l = trie[root][0], r = trie[root][1];
        if(l) dfs(l, pos - 1);
        if(r) dfs(r, pos - 1);
        if(l && r)
        {
            res += (1 << pos);
            int mn = (1 << pos) - 1;
            for(int i : ve[l]) mn = min(mn, find(r, val[i], pos - 1));
            res += mn;
        }
    }

    int main()
    {
        int n;
        scanf("%d", &n);
        for(int i = 1; i < n; i ++)
        {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            edge[u].push_back({v, w});
            edge[v].push_back({u, w});
        }
        init(0, -1);
        for(int i = 0; i < n; i ++) ins(val[i], i);
        dfs(0, 29);
        printf("%lld\n", res);
        return 0;
    }
    ```

## D. Drop Voicing

*upsolved by: Verly*

题意：操作1表示对整个序列做任意次旋转操作，操作2表示对前n-1个数做任意次旋转操作，问要在不同操作1后最少操作多少次操作2使排列有序。

操作2相当于把在最后一位的串放到前n-1个串的任意位置，所以对环求LIS即可。

??? note "Code"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main()
    {
        cout << "Hello World!"<< endl;
        return 0
    }
    ```

## A. 

*solved by: xx 00:00(-x) upsolved by:*

??? note "Code"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main()
    {
        cout << "Hello World!"<< endl;
        return 0
    }
    ```

## A. 

*solved by: xx 00:00(-x) upsolved by:*

??? note "Code"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main()
    {
        cout << "Hello World!"<< endl;
        return 0
    }
    ```
